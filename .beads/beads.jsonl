{"id":"bd-0134cc5a","content_hash":"d45c0e44c01c5855f14f07693bd800f4bfeac3084e10ceb17970ff54c58f6a40","title":"Fix auto-import creating duplicates instead of updating issues","description":"ROOT CAUSE: server_export_import_auto.go line 221 uses ResolveCollisions: true for ALL auto-imports. This is wrong.\n\nProblem:\n- ResolveCollisions is for branch merges (different issues with same ID)\n- Auto-import should UPDATE existing issues, not create duplicates\n- Every git pull creates NEW duplicate issues with different IDs\n- Two agents ping-pong creating endless duplicates\n\nEvidence:\n- 31 duplicate groups found (bd duplicates)\n- bd-236-246 are duplicates of bd-224-235\n- Both agents keep pulling and creating more duplicates\n- JSONL file grows endlessly with duplicates\n\nThe Fix:\nChange checkAndAutoImportIfStale in server_export_import_auto.go:\n- Remove ResolveCollisions: true (line 221)\n- Use normal import logic that updates existing issues by ID\n- Only use ResolveCollisions for explicit bd import --resolve-collisions\n\nImpact: Critical - makes beads unusable for multi-agent workflows","acceptance_criteria":"- Auto-import does NOT create duplicates when pulling git changes\n- Existing issues are updated in-place by ID match\n- No ping-pong commits between agents\n- Test: two agents updating same issue should NOT create duplicates\n- bd duplicates shows 0 groups after fix","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-10-27T21:48:57.733846-07:00","updated_at":"2025-10-30T17:12:58.21084-07:00","closed_at":"2025-10-27T22:26:40.627239-07:00"}
{"id":"bd-0447029c","content_hash":"f32f7d8f0b07aaaeb9d07d8a1d000eef8fc79cf864e8aa20ebb899f6e359ebda","title":"bd find-duplicates - AI-powered duplicate detection","description":"Find semantically duplicate issues.\n\nApproaches:\n1. Mechanical: Exact title/description matching\n2. Embeddings: Cosine similarity (cheap, scalable)\n3. AI: LLM-based semantic comparison (expensive, accurate)\n\nUses embeddings by default for \u003e100 issues.\n\nFiles: cmd/bd/find_duplicates.go (new)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T16:43:28.182327-07:00","updated_at":"2025-10-30T17:12:58.188016-07:00","closed_at":"2025-10-29T16:15:10.64719-07:00"}
{"id":"bd-0650a73b","content_hash":"a596aa8d6114d4938471e181ebc30da5d0315f74fd711a92dbbb83f5d0e7af88","title":"Create cmd/bd/daemon_debouncer.go (~60 LOC)","description":"Implement Debouncer to batch rapid events into single action. Default 500ms, configurable via BEADS_DEBOUNCE_MS. Thread-safe with mutex.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T16:20:02.431118-07:00","updated_at":"2025-10-30T17:12:58.221711-07:00","closed_at":"2025-10-28T12:03:35.614191-07:00"}
{"id":"bd-06aec0c3","content_hash":"330e69cf6ca40209948559b453ed5242c15a71b5c949a858ad6854488b12dca2","title":"Integration Testing","description":"Verify cache removal doesn't break any workflows","acceptance_criteria":"- All test cases pass\n- No stale data observed\n- Performance is same or better\n- MCP works as before\n\nTest cases:\n1. Basic daemon operations (bd daemon --stop, bd daemon, bd list, bd create, bd show)\n2. Auto-import/export cycle (edit beads.jsonl externally, bd list auto-imports)\n3. Git workflow (git pull updates beads.jsonl, bd list shows pulled issues)\n4. Concurrent operations (multiple bd commands simultaneously)\n5. Daemon health (bd daemon --health, bd daemon --metrics)\n6. MCP operations (test MCP server with multiple repos, verify project switching)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T10:50:15.126668-07:00","updated_at":"2025-10-30T17:12:58.217214-07:00","closed_at":"2025-10-28T10:49:20.471129-07:00"}
{"id":"bd-07af","content_hash":"227fcbcef36e3d6d31cdf78434fdb7198bf877dd6d3ca7a585239e3e20ee7461","title":"Need comprehensive daemon health check command (bd daemon doctor?)","description":"","status":"open","priority":1,"issue_type":"feature","created_at":"2025-10-31T21:08:09.092473-07:00","updated_at":"2025-10-31T21:08:09.092473-07:00","dependencies":[{"issue_id":"bd-07af","depends_on_id":"bd-2752a7a2","type":"discovered-from","created_at":"2025-10-31T21:08:09.093276-07:00","created_by":"stevey"}]}
{"id":"bd-08e556f2","content_hash":"cd9e7cc106b733dc4893e92a75feae3331b422238f261a7c738c21a18e29719f","title":"Remove Cache Configuration Docs","description":"Remove documentation of deprecated cache env vars","acceptance_criteria":"- Documentation doesn't reference removed env vars\n- CHANGELOG documents breaking change\n- No mentions of storage cache except in CHANGELOG\n\nFiles to update:\n- ADVANCED.md (remove cache configuration section)\n- commands/daemons.md (remove cache env vars)\n- integrations/beads-mcp/SETUP_DAEMON.md (remove cache tuning)\n- CHANGELOG.md (add removal entry)\n\nDeprecated env vars:\n- BEADS_DAEMON_MAX_CACHE_SIZE\n- BEADS_DAEMON_CACHE_TTL\n- BEADS_DAEMON_MEMORY_THRESHOLD_MB","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T10:50:15.125488-07:00","updated_at":"2025-10-30T17:12:58.216329-07:00","closed_at":"2025-10-28T10:48:20.606979-07:00"}
{"id":"bd-09b5f2f5","content_hash":"9e226fef2280479f32d062d61c8e301dda7b1b1307707f73addf4dec5fd7c103","title":"Daemon fails to auto-import after git pull updates JSONL","description":"After git pull updates .beads/issues.jsonl, daemon doesn't automatically re-import changes, causing stale data to be shown until next sync cycle (up to 5 minutes).\n\nReproduction:\n1. Repo A: Close issues, export, commit, push\n2. Repo B: git pull (successfully updates .beads/issues.jsonl)\n3. bd show \u003cissue\u003e shows OLD status from daemon's SQLite db\n4. JSONL on disk has correct new status\n\nRoot cause: Daemon sync cycle runs on timer (5min). When user manually runs git pull, daemon doesn't detect JSONL was updated externally and continues serving stale data from SQLite.\n\nImpact:\n- High for AI agents using beads in git workflows\n- Breaks fundamental git-as-source-of-truth model\n- Confusing UX: git log shows commit, bd shows old state\n- Data consistency issues between JSONL and daemon\n\nSee WYVERN_SYNC_ISSUE.md for full analysis.","design":"Three possible solutions:\n\nOption 1: Auto-detect and re-import (recommended)\n- Before serving any bd command, check if .beads/issues.jsonl mtime \u003e last import time\n- If newer, auto-import before processing request\n- Fast check, minimal overhead\n\nOption 2: File watcher in daemon\n- Daemon watches .beads/issues.jsonl for mtime changes\n- Auto-imports when file changes\n- More complex, requires file watching infrastructure\n\nOption 3: Explicit sync command\n- User runs `bd sync` after git pull\n- Manual, error-prone, defeats automation\n\nRecommended: Option 1 (auto-detect) + Option 3 (explicit sync) as fallback.","acceptance_criteria":"1. After git pull updates .beads/issues.jsonl, next bd command sees fresh data\n2. No manual import or daemon restart required\n3. Performance impact \u003c 10ms per command (mtime check is fast)\n4. Works in both daemon and non-daemon modes\n5. Test: Two repo clones, update in one, pull in other, verify immediate sync","notes":"**Current Status (2025-10-26):**\n\n✅ **Completed (bd-a5251b1a):**\n- Created internal/autoimport package with staleness detection\n- Daemon can detect when JSONL is newer than last import\n- Infrastructure exists to call import logic\n\n❌ **Remaining Work:**\nThe daemon's importFunc in server.go (line 2096-2102) is a stub that just logs a notice. It needs to actually import the issues.\n\n**Problem:** \n- importIssuesCore is in cmd/bd package, not accessible from internal/rpc\n- daemon's handleImport() returns 'not yet implemented' error\n\n**Two approaches:**\n1. Move importIssuesCore to internal/import package (shares with daemon)\n2. Use storage layer directly in daemon (create/update issues via Storage interface)\n\n**Blocker:** \nThis is the critical bug causing data corruption:\n- Agent A pushes changes\n- Agent B does git pull\n- Agent B's daemon serves stale SQLite data\n- Agent B exports stale data back to JSONL, overwriting Agent A's changes\n- Agent B pushes, losing Agent A's work\n\n**Next Steps:**\n1. Choose approach (probably #1 - move importIssuesCore to internal/import)\n2. Implement real importFunc in daemon's checkAndAutoImportIfStale()\n3. Test with two-repo scenario (push from A, pull in B, verify B sees changes)\n4. Ensure no data corruption in multi-agent workflows","status":"open","priority":0,"issue_type":"epic","created_at":"2025-10-25T23:13:12.270766-07:00","updated_at":"2025-10-31T20:36:49.238625-07:00"}
{"id":"bd-0dcea000","content_hash":"a6fc218b07d270e3498957525c39a869f7c850d687339b6d758a246be20c9591","title":"Add tests for internal/importer package","description":"Currently 0.0% coverage. Need tests for JSONL import logic including collision detection and resolution.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T14:06:21.071024-07:00","updated_at":"2025-10-30T17:12:58.183211-07:00","dependencies":[{"issue_id":"bd-0dcea000","depends_on_id":"bd-cbed9619.5","type":"blocks","created_at":"2025-10-29T19:52:05.531279-07:00","created_by":"import-remap"},{"issue_id":"bd-0dcea000","depends_on_id":"bd-cbed9619.4","type":"blocks","created_at":"2025-10-29T19:52:05.53166-07:00","created_by":"import-remap"}]}
{"id":"bd-0e1f2b1b","content_hash":"c0b1677fe3f4aa3f395ae4d79bff5362632d5db26477bf571c09f9177b8741ef","title":"Event-driven daemon architecture","description":"Replace 5-second polling sync loop with event-driven architecture that reacts instantly to changes. Eliminates stale data issues while reducing CPU ~60%. Key components: FileWatcher (fsnotify), Debouncer (500ms), RPC mutation events, optional git hooks. Target latency: \u003c500ms (vs 5000ms). See event_driven_daemon.md for full design.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-10-28T16:20:02.430479-07:00","updated_at":"2025-10-30T17:12:58.221424-07:00","closed_at":"2025-10-28T16:30:26.631191-07:00"}
{"id":"bd-11e0","content_hash":"3f4f2d73d1a719eeca713597ddb8fe2fc45877d5e5fb0a2c99b4e5b41c979aa3","title":"Database import silently fails when daemon version != CLI version","description":"","status":"open","priority":1,"issue_type":"bug","created_at":"2025-10-31T21:08:09.096749-07:00","updated_at":"2025-10-31T21:08:09.096749-07:00"}
{"id":"bd-12c2","content_hash":"caa7a5f6e61a9b1c872f5462e53ed0ecdedc8835265ba6b7c7ef2100fa6448ae","title":"Add comprehensive tests for show.go commands (show, update, edit, close)","description":"Need to add tests for cmd/bd/show.go which contains show, update, edit, and close commands.\n\n**Challenge**: The existing test patterns use rootCmd.SetArgs() and rootCmd.Execute(), but the global `store` variable needs to match what the commands use. Initial attempt created tests that failed with \"no issue found\" because the test's store instance wasn't the same as the command's store.\n\n**Files to test**:\n- show.go (contains showCmd, updateCmd, editCmd, closeCmd)\n\n**Coverage needed**:\n- show command (single issue, multiple issues, JSON output, with dependencies, with labels, with compaction)\n- update command (status, priority, title, assignee, description, multiple fields, multiple issues)\n- edit command (requires $EDITOR, may need mocking)\n- close command (single issue, multiple issues, with reason, JSON output)\n\n**Test approach**:\n1. Study working test patterns in init_test.go, list_test.go, etc.\n2. Ensure BEADS_NO_DAEMON=1 is set\n3. Properly initialize database with bd init\n4. Use the command's global store, not a separate instance\n5. May need to reset global state between tests\n\n**Success criteria**: \n- All test functions pass\n- Coverage for show.go increases significantly\n- Tests follow existing patterns in cmd/bd/*_test.go","status":"closed","priority":0,"issue_type":"task","created_at":"2025-10-31T20:08:40.545173-07:00","updated_at":"2025-10-31T20:19:22.411066-07:00","closed_at":"2025-10-31T20:19:22.411066-07:00"}
{"id":"bd-17fa2d21","content_hash":"139511c299c2fa977d11d5496245b23f4c27fe785fd4fc94470a35b0e4a01a0a","title":"Batch test 2","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T15:29:01.877052-07:00","updated_at":"2025-10-31T12:00:43.183657-07:00","closed_at":"2025-10-31T12:00:43.183657-07:00"}
{"id":"bd-1863608e","content_hash":"697d09d1b24bc5120e6c8f2f94828a3c490f1432ee3ca243aa492fe465e04039","title":"Add TestNWayCollision for 5+ clones","description":"## Overview\nAdd comprehensive tests for N-way (5+) collision resolution to verify the solution scales beyond 3 clones.\n\n## Purpose\nWhile TestThreeCloneCollision validates the basic N-way case, we need to verify:\n1. Solution scales to arbitrary N\n2. Performance is acceptable with more clones\n3. Convergence time is bounded\n4. No edge cases in larger collision groups\n\n## Implementation Tasks\n\n### 1. Create TestFiveCloneCollision\nFile: beads_twoclone_test.go (or new beads_nway_test.go)\n\n```go\nfunc TestFiveCloneCollision(t *testing.T) {\n    // Test with 5 clones creating same ID with different content\n    // Verify all 5 clones converge after sync rounds\n    \n    t.Run(\"SequentialSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"A\", \"B\", \"C\", \"D\", \"E\")\n    })\n    \n    t.Run(\"ReverseSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"E\", \"D\", \"C\", \"B\", \"A\")\n    })\n    \n    t.Run(\"RandomSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"C\", \"A\", \"E\", \"B\", \"D\")\n    })\n}\n```\n\n### 2. Implement generalized testNCloneCollision\nGeneralize the 3-clone test to handle arbitrary N:\n\n```go\nfunc testNCloneCollision(t *testing.T, numClones int, syncOrder ...string) {\n    t.Helper()\n    \n    if len(syncOrder) != numClones {\n        t.Fatalf(\"syncOrder length (%d) must match numClones (%d)\", \n            len(syncOrder), numClones)\n    }\n    \n    tmpDir := t.TempDir()\n    \n    // Setup remote and N clones\n    remoteDir := setupBareRepo(t, tmpDir)\n    cloneDirs := make(map[string]string)\n    \n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        cloneDirs[name] = setupClone(t, tmpDir, remoteDir, name)\n    }\n    \n    // Each clone creates issue with same ID but different content\n    for name, dir := range cloneDirs {\n        createIssue(t, dir, fmt.Sprintf(\"Issue from clone %s\", name))\n    }\n    \n    // Sync in specified order\n    for _, name := range syncOrder {\n        syncClone(t, cloneDirs[name], name)\n    }\n    \n    // Final pull for convergence\n    for name, dir := range cloneDirs {\n        finalPull(t, dir, name)\n    }\n    \n    // Verify all clones have all N issues\n    expectedTitles := make(map[string]bool)\n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        expectedTitles[fmt.Sprintf(\"Issue from clone %s\", name)] = true\n    }\n    \n    for name, dir := range cloneDirs {\n        titles := getTitles(t, dir)\n        if !compareTitleSets(titles, expectedTitles) {\n            t.Errorf(\"Clone %s missing issues: expected %v, got %v\", \n                name, expectedTitles, titles)\n        }\n    }\n    \n    t.Log(\"✓ All\", numClones, \"clones converged successfully\")\n}\n```\n\n### 3. Add performance benchmarks\nTest convergence time and memory usage:\n\n```go\nfunc BenchmarkNWayCollision(b *testing.B) {\n    for _, n := range []int{3, 5, 10, 20} {\n        b.Run(fmt.Sprintf(\"N=%d\", n), func(b *testing.B) {\n            for i := 0; i \u003c b.N; i++ {\n                // Run N-way collision and measure time\n                testNCloneCollisionBench(b, n)\n            }\n        })\n    }\n}\n```\n\n### 4. Add convergence time tests\nVerify bounded convergence:\n\n```go\nfunc TestConvergenceTime(t *testing.T) {\n    // Test that convergence happens within expected rounds\n    // For N clones, should converge in at most N-1 sync rounds\n    \n    for n := 3; n \u003c= 10; n++ {\n        t.Run(fmt.Sprintf(\"N=%d\", n), func(t *testing.T) {\n            rounds := measureConvergenceRounds(t, n)\n            maxExpected := n - 1\n            if rounds \u003e maxExpected {\n                t.Errorf(\"Convergence took %d rounds, expected ≤ %d\", \n                    rounds, maxExpected)\n            }\n        })\n    }\n}\n```\n\n### 5. Add edge case tests\nTest boundary conditions:\n- All N clones have identical content (dedup works)\n- N-1 clones have same content, 1 differs\n- All N clones have unique content\n- Mix of collisions and non-collisions\n\n## Acceptance Criteria\n- TestFiveCloneCollision passes with all sync orders\n- All 5 clones converge to identical content\n- Performance is acceptable (\u003c 5 seconds for 5 clones)\n- Convergence time is bounded (≤ N-1 rounds)\n- Edge cases handled correctly\n- Benchmarks show scalability to 10+ clones\n\n## Files to Create/Modify\n- beads_twoclone_test.go or beads_nway_test.go\n- Add helper functions for N-clone setup\n\n## Testing Strategy\n\n### Test Matrix\n| N Clones | Sync Orders | Expected Result |\n|----------|-------------|-----------------|\n| 3        | A→B→C       | Pass            |\n| 3        | C→B→A       | Pass            |\n| 5        | A→B→C→D→E   | Pass            |\n| 5        | E→D→C→B→A   | Pass            |\n| 5        | Random      | Pass            |\n| 10       | Sequential  | Pass            |\n\n### Performance Targets\n- 3 clones: \u003c 2 seconds\n- 5 clones: \u003c 5 seconds\n- 10 clones: \u003c 15 seconds\n\n## Dependencies\n- Requires bd-cbed9619.5, bd-cbed9619.4, bd-0dcea000, bd-4d7fca8a to be completed\n- TestThreeCloneCollision must pass first\n\n## Success Metrics\n- All tests pass for N ∈ {3, 5, 10}\n- Convergence time scales linearly (O(N))\n- Memory usage reasonable (\u003c 100MB for 10 clones)\n- No data corruption or loss in any scenario","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T20:02:47.954306-07:00","updated_at":"2025-10-30T17:12:58.182217-07:00","closed_at":"2025-10-28T20:47:28.317007-07:00"}
{"id":"bd-1c63eb84","content_hash":"178adb74f06c9a049ec5db6c406253005ee3460e7b732801e60fcee044986004","title":"Investigate jujutsu integration for beads","description":"Research and document how beads could integrate with jujutsu (jj), the next-generation VCS. Key areas to explore:\n- How jj's operation model differs from git (immutable operations, working-copy-as-commit)\n- JSONL sync strategy with jj's conflict resolution model\n- Daemon compatibility with jj's more frequent rewrites\n- Whether auto-import/export needs changes for jj workflows\n- Example configurations and documentation updates needed","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-23T09:23:23.582009-07:00","updated_at":"2025-10-30T17:12:58.177733-07:00"}
{"id":"bd-1ece","content_hash":"5c9b11e98a914932402f7363445acc27d994372818def2a104250d78fbfce092","title":"Remove obsolete renumber.go command (hash IDs eliminated need)","description":"","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-10-31T21:27:05.559328-07:00","updated_at":"2025-10-31T21:27:11.426941-07:00","closed_at":"2025-10-31T21:27:11.426941-07:00"}
{"id":"bd-1f4086c5","content_hash":"23fbff5ec79ea76cf9c60b64676ee446445c878e3cc17011b925a1ec167142c5","title":"Event-driven daemon architecture","description":"Replace 5-second polling sync loop with event-driven architecture that reacts instantly to changes. Eliminates stale data issues while reducing CPU ~60%. Key components: FileWatcher (fsnotify), Debouncer (500ms), RPC mutation events, optional git hooks. Target latency: \u003c500ms (vs 5000ms). See event_driven_daemon.md for full design.","notes":"Production-ready after 3 critical fixes (commit 349b892):\n- Skip redundant imports (mtime check prevents self-trigger loops)\n- Add server.Stop() in serverErrChan case (clean shutdown)\n- Fallback ticker (60s) when watcher unavailable (ensures remote sync)\n\nReady to make default after integration test (bd-1f4086c5.1) passes.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-10-29T23:05:13.969484-07:00","updated_at":"2025-10-31T20:21:25.464736-07:00","closed_at":"2025-10-31T20:21:25.464736-07:00"}
{"id":"bd-1f4086c5.1","content_hash":"ba5173c61613a29786641ba06a93427de87bed65ce39dbc3c3ddd2b6900f827e","title":"Integration test: mutation to export latency","description":"Measure time from bd create to JSONL update. Verify \u003c500ms latency. Test with multiple rapid mutations to verify batching.","notes":"Test added to daemon_test.go as TestMutationToExportLatency().\n\nCurrently skipped with note that it should be enabled once bd-146 (event-driven daemon) is fully implemented and enabled by default.\n\nThe test structure is complete:\n1. Sets up test environment with fast debounce (500ms)\n2. SingleMutationLatency: measures latency from mutation to JSONL update\n3. RapidMutationBatching: verifies multiple mutations batch into single export\n\nOnce event-driven mode is default, remove the t.Skip() line and the test will validate \u003c500ms latency.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T20:49:49.103759-07:00","updated_at":"2025-10-30T17:12:58.195867-07:00","closed_at":"2025-10-29T14:19:19.808139-07:00","dependencies":[{"issue_id":"bd-1f4086c5.1","depends_on_id":"bd-1f4086c5","type":"parent-child","created_at":"2025-10-29T20:49:49.107244-07:00","created_by":"import-remap"}]}
{"id":"bd-22e0bde9","content_hash":"4c03fb79e67c0948d0d887b56fcbf71ed3b987e4bfd84628d7b9b2fa047a61fa","title":"Add TestNWayCollision for 5+ clones","description":"## Overview\nAdd comprehensive tests for N-way (5+) collision resolution to verify the solution scales beyond 3 clones.\n\n## Purpose\nWhile TestThreeCloneCollision validates the basic N-way case, we need to verify:\n1. Solution scales to arbitrary N\n2. Performance is acceptable with more clones\n3. Convergence time is bounded\n4. No edge cases in larger collision groups\n\n## Implementation Tasks\n\n### 1. Create TestFiveCloneCollision\nFile: beads_twoclone_test.go (or new beads_nway_test.go)\n\n```go\nfunc TestFiveCloneCollision(t *testing.T) {\n    // Test with 5 clones creating same ID with different content\n    // Verify all 5 clones converge after sync rounds\n    \n    t.Run(\"SequentialSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"A\", \"B\", \"C\", \"D\", \"E\")\n    })\n    \n    t.Run(\"ReverseSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"E\", \"D\", \"C\", \"B\", \"A\")\n    })\n    \n    t.Run(\"RandomSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"C\", \"A\", \"E\", \"B\", \"D\")\n    })\n}\n```\n\n### 2. Implement generalized testNCloneCollision\nGeneralize the 3-clone test to handle arbitrary N:\n\n```go\nfunc testNCloneCollision(t *testing.T, numClones int, syncOrder ...string) {\n    t.Helper()\n    \n    if len(syncOrder) != numClones {\n        t.Fatalf(\"syncOrder length (%d) must match numClones (%d)\", \n            len(syncOrder), numClones)\n    }\n    \n    tmpDir := t.TempDir()\n    \n    // Setup remote and N clones\n    remoteDir := setupBareRepo(t, tmpDir)\n    cloneDirs := make(map[string]string)\n    \n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        cloneDirs[name] = setupClone(t, tmpDir, remoteDir, name)\n    }\n    \n    // Each clone creates issue with same ID but different content\n    for name, dir := range cloneDirs {\n        createIssue(t, dir, fmt.Sprintf(\"Issue from clone %s\", name))\n    }\n    \n    // Sync in specified order\n    for _, name := range syncOrder {\n        syncClone(t, cloneDirs[name], name)\n    }\n    \n    // Final pull for convergence\n    for name, dir := range cloneDirs {\n        finalPull(t, dir, name)\n    }\n    \n    // Verify all clones have all N issues\n    expectedTitles := make(map[string]bool)\n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        expectedTitles[fmt.Sprintf(\"Issue from clone %s\", name)] = true\n    }\n    \n    for name, dir := range cloneDirs {\n        titles := getTitles(t, dir)\n        if !compareTitleSets(titles, expectedTitles) {\n            t.Errorf(\"Clone %s missing issues: expected %v, got %v\", \n                name, expectedTitles, titles)\n        }\n    }\n    \n    t.Log(\"✓ All\", numClones, \"clones converged successfully\")\n}\n```\n\n### 3. Add performance benchmarks\nTest convergence time and memory usage:\n\n```go\nfunc BenchmarkNWayCollision(b *testing.B) {\n    for _, n := range []int{3, 5, 10, 20} {\n        b.Run(fmt.Sprintf(\"N=%d\", n), func(b *testing.B) {\n            for i := 0; i \u003c b.N; i++ {\n                // Run N-way collision and measure time\n                testNCloneCollisionBench(b, n)\n            }\n        })\n    }\n}\n```\n\n### 4. Add convergence time tests\nVerify bounded convergence:\n\n```go\nfunc TestConvergenceTime(t *testing.T) {\n    // Test that convergence happens within expected rounds\n    // For N clones, should converge in at most N-1 sync rounds\n    \n    for n := 3; n \u003c= 10; n++ {\n        t.Run(fmt.Sprintf(\"N=%d\", n), func(t *testing.T) {\n            rounds := measureConvergenceRounds(t, n)\n            maxExpected := n - 1\n            if rounds \u003e maxExpected {\n                t.Errorf(\"Convergence took %d rounds, expected ≤ %d\", \n                    rounds, maxExpected)\n            }\n        })\n    }\n}\n```\n\n### 5. Add edge case tests\nTest boundary conditions:\n- All N clones have identical content (dedup works)\n- N-1 clones have same content, 1 differs\n- All N clones have unique content\n- Mix of collisions and non-collisions\n\n## Acceptance Criteria\n- TestFiveCloneCollision passes with all sync orders\n- All 5 clones converge to identical content\n- Performance is acceptable (\u003c 5 seconds for 5 clones)\n- Convergence time is bounded (≤ N-1 rounds)\n- Edge cases handled correctly\n- Benchmarks show scalability to 10+ clones\n\n## Files to Create/Modify\n- beads_twoclone_test.go or beads_nway_test.go\n- Add helper functions for N-clone setup\n\n## Testing Strategy\n\n### Test Matrix\n| N Clones | Sync Orders | Expected Result |\n|----------|-------------|-----------------|\n| 3        | A→B→C       | Pass            |\n| 3        | C→B→A       | Pass            |\n| 5        | A→B→C→D→E   | Pass            |\n| 5        | E→D→C→B→A   | Pass            |\n| 5        | Random      | Pass            |\n| 10       | Sequential  | Pass            |\n\n### Performance Targets\n- 3 clones: \u003c 2 seconds\n- 5 clones: \u003c 5 seconds\n- 10 clones: \u003c 15 seconds\n\n## Dependencies\n- Requires bd-cbed9619.5, bd-cbed9619.4, bd-cbed9619.3, bd-cbed9619.2 to be completed\n- TestThreeCloneCollision must pass first\n\n## Success Metrics\n- All tests pass for N ∈ {3, 5, 10}\n- Convergence time scales linearly (O(N))\n- Memory usage reasonable (\u003c 100MB for 10 clones)\n- No data corruption or loss in any scenario","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T23:05:13.974702-07:00","updated_at":"2025-10-31T12:00:43.197709-07:00","closed_at":"2025-10-31T12:00:43.197709-07:00"}
{"id":"bd-248bdc3e","content_hash":"8eaeb2dbef1ed6b25fc1bcf3bc5cd1b38a5cf5a487772558ba9fe12a149978f3","title":"Add optional post-merge git hook example for bd sync","description":"Create example git hook that auto-runs bd sync after git pull/merge.\n\nAdd to examples/git-hooks/:\n- post-merge hook that checks if .beads/issues.jsonl changed\n- If changed: run `bd sync` automatically\n- Make it optional/documented (not auto-installed)\n\nBenefits:\n- Zero-friction sync after git pull\n- Complements auto-detection as belt-and-suspenders\n\nNote: post-merge hook already exists for pre-commit/post-merge. Extend it to support sync.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-25T22:47:14.668842-07:00","updated_at":"2025-10-30T17:12:58.218887-07:00"}
{"id":"bd-2530","content_hash":"7056a386ee4802bce2b83a981aaac7858b5911938263d212f8f9d1f60bf2a706","title":"Issue with labels","description":"This is a description","design":"Use MVC pattern","acceptance_criteria":"All tests pass","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-10-31T21:40:34.630173-07:00","updated_at":"2025-11-01T11:11:57.93151-07:00","closed_at":"2025-11-01T11:11:57.93151-07:00","labels":["bug","critical"]}
{"id":"bd-2752a7a2","content_hash":"6b2a1aedbdbcb30b98d4a8196801953a1eb22204d63e31954ef9ab6020a7a26b","title":"Create cmd/bd/daemon_watcher.go (~150 LOC)","description":"Implement FileWatcher using fsnotify to watch JSONL file and git refs. Handle platform differences (inotify/FSEvents/ReadDirectoryChangesW). Include edge case handling for file rename, event storm, watcher failure.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T23:05:13.887269-07:00","updated_at":"2025-10-31T18:30:24.131535-07:00","closed_at":"2025-10-31T18:30:24.131535-07:00"}
{"id":"bd-27ea","content_hash":"c516a8bb5500e2857ec69afcef2e877853128c2c5eb83fdb5693aee683e7c465","title":"Improve cmd/bd test coverage from 21% to 40% (multi-session effort)","description":"Current coverage: 21.0% of statements in cmd/bd\nTarget: 40%\nThis is a multi-session incremental effort.\n\nFocus areas:\n- Command handler tests (create, update, close, list, etc.)\n- Flag validation and error cases\n- JSON output formatting\n- Edge cases and error handling\n\nTrack progress with 'go test -cover ./cmd/bd'","status":"open","priority":0,"issue_type":"task","created_at":"2025-10-31T19:35:57.558346-07:00","updated_at":"2025-10-31T20:36:49.215975-07:00"}
{"id":"bd-29c128e8","content_hash":"b93b210ddad4f38c993d184e2f7c897eb00cb2f9c8183224e27ff54e129bb1f7","title":"Update AGENTS.md with event-driven mode","description":"Document BEADS_DAEMON_MODE env var. Explain opt-in during Phase 1. Add troubleshooting for watcher failures.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-28T16:20:02.433145-07:00","updated_at":"2025-10-30T17:12:58.223058-07:00","closed_at":"2025-10-29T15:53:24.019613-07:00"}
{"id":"bd-2b34","content_hash":"f4f252f378555b11762b1d0e89fa4a51a15671f8d33e98e40b0afba0cf8971aa","title":"Refactor cmd/bd/daemon.go for testability and maintainability","description":"","design":"## Current Structure Analysis\n\ndaemon.go contains:\n- Command setup and CLI flag parsing\n- Path/config resolution (getGlobalBeadsDir, ensureBeadsDir, getPIDFilePath, etc.)\n- Daemon lifecycle (start, stop, status, health, metrics)\n- Lock management (setupDaemonLock, acquireDaemonLock)\n- RPC server setup (startRPCServer)\n- Export/import operations (exportToJSONLWithStore, importToJSONLWithStore)\n- Sync orchestration (createExportFunc, createAutoImportFunc, createSyncFunc)\n- Event loop (runEventLoop, runDaemonLoop)\n- Global daemon mode (runGlobalDaemon)\n- Logging setup (setupDaemonLogger)\n\n## Proposed Module Breakdown\n\n1. **daemon_config.go** - Configuration \u0026 path resolution\n   - getGlobalBeadsDir, ensureBeadsDir\n   - getPIDFilePath, getLogFilePath, getSocketPathForPID\n   - getEnvInt, getEnvBool\n   - boolToFlag helper\n\n2. **daemon_lifecycle.go** - Start/stop/status operations\n   - isDaemonRunning, startDaemon, stopDaemon\n   - showDaemonStatus, showDaemonHealth, showDaemonMetrics\n   - migrateToGlobalDaemon\n\n3. **daemon_sync.go** - Export/import/sync logic\n   - exportToJSONLWithStore, importToJSONLWithStore\n   - createExportFunc, createAutoImportFunc, createSyncFunc\n   - validateDatabaseFingerprint\n\n4. **daemon_server.go** - RPC server setup\n   - startRPCServer, runGlobalDaemon\n\n5. **daemon_loop.go** - Event loop \u0026 orchestration\n   - runEventLoop, runDaemonLoop\n\n6. **daemon_logger.go** - Logging setup\n   - setupDaemonLogger, daemonLogger type\n\nKeep daemon.go as Cobra command definition only.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-10-31T22:28:19.689943-07:00","updated_at":"2025-10-31T22:28:31.838098-07:00"}
{"id":"bd-2b34.1","content_hash":"dad25846078bec1b84e52a8522b0126cf5ba30f5dbed3defeab09b744435677d","title":"Extract daemon logger functions to daemon_logger.go","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.343617-07:00","updated_at":"2025-10-31T22:28:42.343617-07:00"}
{"id":"bd-2b34.2","content_hash":"e3e6ad681759e2e3d521c084809c4875003ce3a25db824d33a98975308e67286","title":"Extract daemon server functions to daemon_server.go","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.345639-07:00","updated_at":"2025-10-31T22:28:42.345639-07:00"}
{"id":"bd-2b34.3","content_hash":"dd8b4be930560efcbb3a383d63dd9a65847ba6c9f931736377514b7f9cd2f296","title":"Extract daemon sync functions to daemon_sync.go","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.347332-07:00","updated_at":"2025-10-31T22:28:42.347332-07:00"}
{"id":"bd-2b34.4","content_hash":"63b109392ba7a5544b1077e52e5be0b3e6b616d8c7106697f1cb7229031553a5","title":"Extract daemon config functions to daemon_config.go","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.349237-07:00","updated_at":"2025-10-31T22:28:42.349237-07:00"}
{"id":"bd-2b34.5","content_hash":"64294568a392ca9337aa2d49272b09183057504018a2970bce9d2187c576f838","title":"Add tests for daemon sync module","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.354701-07:00","updated_at":"2025-10-31T22:28:42.354701-07:00"}
{"id":"bd-2b34.6","content_hash":"ef6ae3def4eee6fc800719351f0266eb4f7812c28fa1e53c0e2e4bf1158645b2","title":"Add tests for daemon lifecycle module","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.359587-07:00","updated_at":"2025-10-31T22:28:42.359587-07:00"}
{"id":"bd-2b34.7","content_hash":"62bfa4e0024d5b68061e3ca64645449e5abfc5849d611f6797cd378e5ea0af93","title":"Add tests for daemon config module","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.373684-07:00","updated_at":"2025-10-31T22:28:42.373684-07:00"}
{"id":"bd-2b34.8","content_hash":"449c5ba132b35ebfbd8ed8dc31f7d96c03311c0dc5eda61d88af3a071e365338","title":"Extract daemon lifecycle functions to daemon_lifecycle.go","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T22:28:42.382892-07:00","updated_at":"2025-10-31T22:28:42.382892-07:00"}
{"id":"bd-2f388ca7","content_hash":"27498c808874010ee62da58e12434a6ae7c73f4659b2233aaf8dcd59566a907d","title":"Fix TestTwoCloneCollision timeout","description":"","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-28T14:11:25.219607-07:00","updated_at":"2025-10-30T17:12:58.217635-07:00","closed_at":"2025-10-28T16:12:26.286611-07:00"}
{"id":"bd-317ddbbf","content_hash":"81a74ccf29037e5a780b12540a4059bab98b9a790a5a043a68118fc00a083cda","title":"Add BEADS_DAEMON_MODE flag handling","description":"Add environment variable BEADS_DAEMON_MODE (values: poll, events). Default to 'poll' for Phase 1. Wire into daemon startup to select runEventLoop vs runEventDrivenLoop.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T16:20:02.433638-07:00","updated_at":"2025-10-30T17:12:58.224373-07:00","closed_at":"2025-10-28T12:31:47.819136-07:00"}
{"id":"bd-31aab707","content_hash":"8f64a8dbcc5ed63bc73b7d91fca624527033265dc1c89a7775eb2f45b378f382","title":"Unit tests for FileWatcher","description":"Test watcher detects JSONL changes. Test git ref changes trigger import. Test debounce integration. Test watcher recovery from file removal/rename.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T11:30:59.842317-07:00","updated_at":"2025-10-31T12:00:43.189591-07:00","closed_at":"2025-10-31T12:00:43.189591-07:00"}
{"id":"bd-325da116","content_hash":"d7c5637527778c5c835f5e4b6e15fbd51a3476d6749ab3155b8aeac08a8ef339","title":"Fix N-way collision convergence","description":"Epic to fix the N-way collision convergence problem documented in n-way-collision-convergence.md.\n\n## Problem Summary\nThe current collision resolution implementation works correctly for 2-way collisions but does not converge for 3-way (and by extension N-way) collisions. TestThreeCloneCollision demonstrates this with reproducible failures.\n\n## Root Causes Identified\n1. Pairwise resolution doesn't scale - each clone makes local decisions without global context\n2. DetectCollisions modifies state during detection (line 83-86 in collision.go)\n3. No remapping history - can't track transitive remap chains (test-1 → test-2 → test-3)\n4. Import-time resolution is too late - happens after git merge\n\n## Solution Architecture\nReplace pairwise resolution with deterministic global N-way resolution using:\n- Content-addressable identity (content hashing)\n- Global collision resolution (sort all versions by hash)\n- Read-only detection phase (separate from modification)\n- Idempotent imports (content-first matching)\n\n## Success Criteria\n- TestThreeCloneCollision passes without skipping\n- All clones converge to identical content after final pull\n- No data loss (all issues present in all clones)\n- Works for N workers (test with 5+ clones)\n- Idempotent imports (importing same JSONL multiple times is safe)\n\n## Implementation Phases\nSee child issues for detailed breakdown of each phase.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-10-29T23:05:13.889079-07:00","updated_at":"2025-10-31T11:59:41.031668-07:00","closed_at":"2025-10-31T11:59:41.031668-07:00"}
{"id":"bd-36320a04","content_hash":"883eb385fa9eded3826008fa6db3b842cabb2ce0e93a23293449f65024303fb7","title":"Add mutation channel to internal/rpc/server.go","description":"Add mutationChan chan MutationEvent to Server struct. Emit events on CreateIssue, UpdateIssue, DeleteIssue, AddComment. Non-blocking send with default case for full channel.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T19:42:29.860173-07:00","updated_at":"2025-10-31T18:31:27.928693-07:00","closed_at":"2025-10-31T18:31:27.928693-07:00"}
{"id":"bd-36870264","content_hash":"f5622dee6df2f61baab2f749e5cf93de6f2b83443de6497c871aeea01b2b8b80","title":"Enforce daemon singleton per workspace with file locking","description":"Agent in ~/src/wyvern discovered 4 simultaneous daemon processes running, causing infinite directory recursion (.beads/.beads/.beads/...). Each daemon used relative paths and created nested .beads/ directories.\n\nRoot cause: No singleton enforcement. Multiple `bd daemon` processes can start in same workspace.\n\nExpected: One daemon per workspace (each workspace = separate .beads/ dir with bd.sock)\nActual: Multiple daemons can run simultaneously in same workspace\n\nNote: Separate git clones = separate workspaces = separate daemons (correct). Git worktrees share .beads/ and have known limitations (documented, use --no-daemon).","design":"Use flock (file locking) on daemon socket or database file to enforce singleton:\n\n1. On daemon start, attempt exclusive lock on .beads/bd.sock or .beads/daemon.lock\n2. If lock held by another process, refuse to start (exit with clear error)\n3. Hold lock for lifetime of daemon process\n4. Release lock on daemon shutdown\n\nAlternative: Use PID file with stale detection (check if PID is still running)\n\nImplementation location: Daemon startup code in cmd/bd/ or internal/daemon/","acceptance_criteria":"1. Starting second daemon process in same workspace fails with clear error\n2. Test: Start daemon, attempt second start, verify failure\n3. Killing daemon releases lock, allowing new daemon to start\n4. No infinite .beads/ directory recursion possible\n5. Works correctly with auto-start mechanism","status":"open","priority":0,"issue_type":"bug","created_at":"2025-10-25T23:13:12.269549-07:00","updated_at":"2025-10-31T20:36:49.265558-07:00"}
{"id":"bd-373c","content_hash":"2ee54c4542489d8d254d17a6fc2e2d581e99badd7a166b36799cdca4be94bcc6","title":"Daemon crashes silently when multiple .db files exist in .beads/","description":"When daemon detects multiple .db files (after filtering out .backup and vc.db files), it writes error details to .beads/daemon-error file before exiting.\n\nThe error file is checked when:\n1. Daemon discovery fails to connect (internal/daemon/discovery.go)\n2. Auto-start fails to yield a running daemon (cmd/bd/main.go)\n3. Daemon list shows 'daemon not responding' error\n\nThis makes the error immediately visible to users without requiring them to check daemon logs.\n\nFile created:  cmd/bd/daemon.go (writes daemon-error on multiple .db detection)\nFiles modified: \n- internal/daemon/discovery.go (reads daemon-error and surfaces in DaemonInfo.Error)\n- cmd/bd/main.go (displays daemon-error when auto-start fails)\n\nTesting: Create multiple .db files in .beads/, start daemon, verify error file created and shown in bd daemons list","notes":"Root cause: Daemon exits with os.Exit(1) when multiple .db files detected (daemon.go:1381), but error only goes to daemon log file. User sees 'daemon not responding' without knowing why.\n\nCurrent detection:\n- daemon.go filters out .backup and vc.db files\n- bd doctor detects multiple databases\n- Error message tells user to run 'bd init' or manually remove\n\nProblem: Error is not user-visible unless they check daemon logs.\n\nProposed fix options:\n1. Surface the error in 'bd info' and 'bd daemons list' output\n2. Add a hint in error messages to run 'bd doctor' when daemon fails\n3. Make daemon write error to a .beads/daemon-error file that gets checked\n4. Improve 'bd doctor' to run automatically when daemon is unhealthy","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-10-31T21:08:03.389259-07:00","updated_at":"2025-11-01T11:13:48.029427-07:00","closed_at":"2025-11-01T11:13:48.029427-07:00","dependencies":[{"issue_id":"bd-373c","depends_on_id":"bd-2752a7a2","type":"discovered-from","created_at":"2025-10-31T21:08:03.390022-07:00","created_by":"stevey"}]}
{"id":"bd-381d7f6c","content_hash":"24b00d276bd245aec3e6dfb6378457e785ac6a01538eba05450dd65dba993178","title":"Audit Current Cache Usage","description":"Understand exactly what code depends on the storage cache","acceptance_criteria":"- Document showing all cache dependencies\n- Confirmation that removing cache won't break MCP\n- List of tests that need updating\n\nFiles to examine:\n- internal/rpc/server_cache_storage.go (cache implementation)\n- internal/rpc/client.go (how req.Cwd is set)\n- internal/rpc/server_*.go (all getStorageForRequest calls)\n- integrations/beads-mcp/ (MCP multi-repo logic)\n\nTasks:\n- Document all callers of getStorageForRequest()\n- Verify req.Cwd is only set by RPC client for database discovery\n- Confirm MCP server doesn't rely on multi-repo cache behavior\n- Check if any tests assume multi-repo routing\n- Review environment variables: BEADS_DAEMON_MAX_CACHE_SIZE, BEADS_DAEMON_CACHE_TTL, BEADS_DAEMON_MEMORY_THRESHOLD_MB","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T23:01:15.172045-07:00","updated_at":"2025-10-30T17:12:58.214409-07:00","closed_at":"2025-10-28T10:47:37.87529-07:00"}
{"id":"bd-3b2fe268","content_hash":"60b24230230cb6c49c45d7439787ee8a748164dfc9629946653814d447ea8c1a","title":"Add fsnotify dependency to go.mod","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-28T16:20:02.429763-07:00","updated_at":"2025-10-31T20:36:49.310833-07:00"}
{"id":"bd-3d844c58","content_hash":"92be620ba7d89a256decb33cefd8ba8a12f40413a27e4d92dca9b6189b48665b","title":"Implement content-hash based collision resolution for deterministic convergence","description":"The current collision resolution uses creation timestamps to decide which issue to keep vs. remap. This is non-deterministic when two clones create issues at nearly the same time.\n\nRoot cause of bd-71107098:\n- Clone A creates test-1=\"Issue from clone A\" at T0\n- Clone B creates test-1=\"Issue from clone B\" at T0+30ms\n- Clone B syncs first, remaps Clone A's to test-2\n- Clone A syncs second, sees collision, remaps Clone B's to test-2\n- Result: titles are swapped between clones\n\nSolution:\n- Use content-based hashing (title + description + priority + type)\n- Deterministic winner: always keep issue with lower hash\n- Same collision on different clones produces same result (idempotent)\n\nImplementation:\n- Modify ScoreCollisions in internal/storage/sqlite/collision.go\n- Replace timestamp-based scoring with content hash comparison\n- Ensure hash function is stable across platforms","status":"closed","priority":0,"issue_type":"task","created_at":"2025-10-28T17:04:06.145646-07:00","updated_at":"2025-10-30T17:12:58.225476-07:00","closed_at":"2025-10-28T19:20:09.943023-07:00","dependencies":[{"issue_id":"bd-3d844c58","depends_on_id":"bd-71107098","type":"blocks","created_at":"2025-10-31T19:38:09.203365-07:00","created_by":"stevey"}]}
{"id":"bd-3e307cd4","content_hash":"2d95ea3b6835139e1fd266bbdcd0f683b5b4d26a1041516c4883beeb37b11ede","title":"File change test issue","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T19:11:28.425601-07:00","updated_at":"2025-10-31T12:00:43.176605-07:00","closed_at":"2025-10-31T12:00:43.176605-07:00"}
{"id":"bd-3e9ddc31","content_hash":"4e03660281dbe2c069617fc8d723d546d6e5eb386142c0359b862747867a1b90","title":"Replace getStorageForRequest with Direct Access","description":"Replace all getStorageForRequest(req) calls with s.storage","acceptance_criteria":"- No references to getStorageForRequest() in codebase (except in deleted file)\n- All handlers use s.storage directly\n- Code compiles without errors\n\nFiles to update:\n- internal/rpc/server_issues_epics.go (~8 calls)\n- internal/rpc/server_labels_deps_comments.go (~4 calls)\n- internal/rpc/server_compact.go (~2 calls)\n- internal/rpc/server_export_import_auto.go (~2 calls)\n- internal/rpc/server_routing_validation_diagnostics.go (~1 call)\n\nPattern: store, err := s.getStorageForRequest(req) → store := s.storage","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T23:20:10.393759-07:00","updated_at":"2025-10-30T17:12:58.21613-07:00","closed_at":"2025-10-28T14:08:38.06721-07:00"}
{"id":"bd-3ee2c7e9","content_hash":"a1a26c30e2d2d791d3dd5b3fe3a917304cb001b1d024e4627e46fd93c98bcf86","title":"Add \"bd daemons\" command for multi-daemon management","description":"Add a new \"bd daemons\" command with subcommands to manage daemon processes across all beads repositories/worktrees. Should show all running daemons with metadata (version, workspace, uptime, last sync), allow stopping/restarting individual daemons, auto-clean stale processes, view logs, and show exclusive lock status.","design":"Subcommands:\n- list: Show all running daemons with metadata (workspace, PID, version, socket path, uptime, last activity, exclusive lock status)\n- stop \u003cpath|pid\u003e: Gracefully stop a specific daemon\n- restart \u003cpath|pid\u003e: Stop and restart daemon\n- killall: Emergency stop all daemons\n- health: Verify each daemon responds to ping\n- logs \u003cpath\u003e: View daemon logs\n\nFeatures:\n- Auto-clean stale sockets/dead processes\n- Discovery: Scan for .beads/bd.sock files + running processes\n- Communication: Use existing socket protocol, add GET /status endpoint for metadata","status":"open","priority":1,"issue_type":"epic","created_at":"2025-10-26T16:53:40.970042-07:00","updated_at":"2025-10-31T20:36:49.355628-07:00"}
{"id":"bd-3f80d9e0","content_hash":"10716746db7f5efcb9380e184d3ae8abfefd5b84d500340899e13e3b81d4e02a","title":"Improve internal/daemon test coverage (currently 22.5%)","description":"Daemon functionality needs better coverage:\n- Auto-start behavior\n- Lock file management\n- Discovery mechanisms\n- Connection handling\n- Error recovery","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T14:06:30.832728-07:00","updated_at":"2025-10-30T17:12:58.186077-07:00"}
{"id":"bd-40a0","content_hash":"44ac6f2956fce0d7f1fa4d6f4e09b93b14bdd914c1199ed68dedf9c85fbdf4cf","title":"bd doctor should check for multiple DBs, multiple JSONLs, daemon health","description":"","design":"\nCurrently bd doctor only checks:\n- .beads/ directory exists\n- Database version vs CLI version  \n- ID format (hash vs sequential)\n- CLI version vs latest GitHub release\n\nIt should ALSO check for operational issues that cause silent failures:\n\n1. **Multiple database files** (*.db excluding backups and vc.db)\n   - Warn if multiple *.db files found (ambiguous which to use)\n   - Suggest running 'bd migrate' or manually removing old DBs\n\n2. **Multiple JSONL files** \n   - Check for both issues.jsonl and beads.jsonl\n   - Warn about ambiguity, suggest standardizing on one\n\n3. **Daemon health** (integrate bd daemons health)\n   - Check if daemon running for this workspace\n   - Detect version mismatches between daemon and CLI\n   - Detect zombie daemons (running but unresponsive)\n   - Detect stale daemon.pid files\n\n4. **Database-JSONL sync issues**\n   - Check if JSONL is newer than last import\n   - Warn if they're out of sync\n\n5. **Permissions issues**\n   - Check if .beads/ directory is writable\n   - Check if database file is readable/writable\n\nImplementation approach:\n- Add new check functions to doctor.go\n- Reuse logic from bd daemons health\n- Keep checks fast (\u003c 1 second total)\n- Output actionable fixes for each issue\n","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-10-31T21:16:47.042913-07:00","updated_at":"2025-10-31T21:21:27.093525-07:00","closed_at":"2025-10-31T21:21:27.093525-07:00"}
{"id":"bd-46381404","content_hash":"1963d7e754c6eaafba9cbefc6d9f38cc4d872386d9d100ecbba7d7f24cbbcea3","title":"Test database naming","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T18:27:28.309676-07:00","updated_at":"2025-10-31T12:00:43.185201-07:00","closed_at":"2025-10-31T12:00:43.185201-07:00"}
{"id":"bd-4aeed709","content_hash":"3ab290915c117ec902bda1761e8c27850512f3fd4b494a93546c44b397d573a3","title":"bd resolve-conflicts - Git merge conflict resolver","description":"Automatically resolve JSONL merge conflicts.\n\nModes:\n- Mechanical: ID remapping (no AI)\n- AI-assisted: Smart merge/keep decisions\n- Interactive: Review each conflict\n\nHandles \u003c\u003c\u003c\u003c\u003c\u003c\u003c conflict markers in .beads/beads.jsonl\n\nFiles: cmd/bd/resolve_conflicts.go (new)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T14:48:17.457619-07:00","updated_at":"2025-10-30T17:12:58.218109-07:00","closed_at":"2025-10-28T15:47:33.037021-07:00"}
{"id":"bd-4ba5908b","content_hash":"d51947c12181535897f5b1dd5d13ca28324a0e9cedf5b62430eea360dfa320ff","title":"Implement content-hash based collision resolution for deterministic convergence","description":"The current collision resolution uses creation timestamps to decide which issue to keep vs. remap. This is non-deterministic when two clones create issues at nearly the same time.\n\nRoot cause of bd-71107098:\n- Clone A creates test-1=\"Issue from clone A\" at T0\n- Clone B creates test-1=\"Issue from clone B\" at T0+30ms\n- Clone B syncs first, remaps Clone A's to test-2\n- Clone A syncs second, sees collision, remaps Clone B's to test-2\n- Result: titles are swapped between clones\n\nSolution:\n- Use content-based hashing (title + description + priority + type)\n- Deterministic winner: always keep issue with lower hash\n- Same collision on different clones produces same result (idempotent)\n\nImplementation:\n- Modify ScoreCollisions in internal/storage/sqlite/collision.go\n- Replace timestamp-based scoring with content hash comparison\n- Ensure hash function is stable across platforms","notes":"Rename detection successfully implemented and tested!\n\n**What was implemented:**\n1. Content-hash based rename detection in DetectCollisions\n2. When importing JSONL, if an issue has different ID but same content as DB issue, treat as rename\n3. Delete old ID and accept new ID from JSONL\n4. Added post-import re-export in sync command to flush rename changes\n5. Added post-import commit to capture rename changes\n\n**Test results:**\nTestTwoCloneCollision now shows full convergence:\n- Clone A: test-2=\"Issue from clone A\", test-1=\"Issue from clone B\"\n- Clone B: test-1=\"Issue from clone B\", test-2=\"Issue from clone A\"\n\nBoth clones have **identical content** (titles match IDs correctly). Only timestamps differ (expected).\n\n**What remains:**\n- Test still expects exact JSON match including timestamps\n- Could normalize timestamp comparison, but content convergence is the critical success metric\n- The two-clone collision workflow now works without data corruption!","status":"closed","priority":0,"issue_type":"task","created_at":"2025-10-28T17:04:11.530026-07:00","updated_at":"2025-10-30T17:12:58.225987-07:00","closed_at":"2025-10-28T17:18:27.777019-07:00","dependencies":[{"issue_id":"bd-4ba5908b","depends_on_id":"bd-71107098","type":"blocks","created_at":"2025-10-28T17:04:18.149604-07:00","created_by":"daemon"}]}
{"id":"bd-4d7fca8a","content_hash":"57a2b25548d175bdd495044afa0ddb0739118c7faa2fc0860b13aaabb2635c23","title":"Add tests for internal/utils package","description":"Currently 0.0% coverage. Need tests for utility functions including issue ID parsing and validation.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T14:06:24.066403-07:00","updated_at":"2025-10-30T17:12:58.185474-07:00","dependencies":[{"issue_id":"bd-4d7fca8a","depends_on_id":"bd-cbed9619.5","type":"blocks","created_at":"2025-10-29T19:52:05.52888-07:00","created_by":"import-remap"},{"issue_id":"bd-4d7fca8a","depends_on_id":"bd-cbed9619.4","type":"blocks","created_at":"2025-10-29T19:52:05.529565-07:00","created_by":"import-remap"},{"issue_id":"bd-4d7fca8a","depends_on_id":"bd-0dcea000","type":"blocks","created_at":"2025-10-29T19:52:05.529982-07:00","created_by":"import-remap"}]}
{"id":"bd-4d80b7b1","content_hash":"0cad3e22d722ff045a29f218962fb00bd8265a1cfc82c5b70f29ffe1a40e4088","title":"Investigate and upgrade to modernc.org/sqlite 1.39.1+","description":"We had to pin modernc.org/sqlite to v1.38.2 due to a FOREIGN KEY constraint regression in v1.39.1 (SQLite 3.50.4).\n\n**Issue:** [deleted:bd-cb64c226.2], GH #144\n\n**Symptom:** CloseIssue fails with \"FOREIGN KEY constraint failed (787)\" when called via MCP/daemon, but works fine via CLI.\n\n**Root Cause:** Unknown - likely stricter FK enforcement in SQLite 3.50.4 or modernc.org wrapper changes.\n\n**Workaround:** Pinned to v1.38.2 (SQLite 3.49.x)\n\n**TODO:**\n1. Monitor modernc.org/sqlite releases for fixes\n2. Check SQLite 3.50.5+ changelogs for FK-related fixes\n3. Investigate why daemon mode fails but CLI succeeds (connection reuse? transaction isolation?)\n4. Consider filing upstream issue with reproducible test case\n5. Upgrade when safe","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-24T11:49:12.836292-07:00","updated_at":"2025-10-30T17:12:58.211344-07:00"}
{"id":"bd-4e21b5ad","content_hash":"8029d0c5b14261648d3d17d8bc26413183962eab2875772cd2585db92c0104a6","title":"Add test case for symmetric collision (both clones create same ID simultaneously)","description":"TestTwoCloneCollision demonstrates the problem, but we need a simpler unit test for the collision resolver itself.\n\nTest should verify:\n- Two issues with same ID, different content\n- Content hash determines winner deterministically  \n- Result is same regardless of which clone imports first\n- No title swapping occurs\n\nThis can be a simpler test than the full integration test.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T17:46:10.046999-07:00","updated_at":"2025-10-31T12:00:43.196705-07:00","closed_at":"2025-10-31T12:00:43.196705-07:00"}
{"id":"bd-4f582ec8","content_hash":"02e00868aecbd17486f988a5927a68a07bc309978b33568361559a182eadb2cc","title":"Test auto-start in fred","description":"","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-30T17:46:16.668088-07:00","updated_at":"2025-10-31T12:00:43.185723-07:00","closed_at":"2025-10-31T12:00:43.185723-07:00"}
{"id":"bd-5314bddf","content_hash":"bbaf3bd26766fb78465900c455661a3608ab1d1485cb964d12229badf138753a","title":"bd detect-pollution - Test pollution detector","description":"Detect test issues that leaked into production DB.\n\nPattern matching for:\n- Titles starting with 'test', 'benchmark', 'sample'\n- Sequential numbering (test-1, test-2)\n- Generic descriptions\n- Created in rapid succession\n\nOptional AI scoring for confidence.\n\nFiles: cmd/bd/detect_pollution.go (new)","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-28T14:48:17.466906-07:00","updated_at":"2025-10-30T17:12:58.219307-07:00"}
{"id":"bd-5599","content_hash":"c48839a6f7f5ca4083ced2f0f47cd250046146032555a14864ac3469a42bb76b","title":"Fix TestListCommand duplicate dependency constraint violation","description":"","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-31T21:27:05.557548-07:00","updated_at":"2025-10-31T21:27:11.429018-07:00","closed_at":"2025-10-31T21:27:11.429018-07:00"}
{"id":"bd-581b80b3","content_hash":"04c4d952852ae2673e551d9776698c52b0189754ac5f9ca295bed464a5b86a43","title":"bd find-duplicates - AI-powered duplicate detection","description":"Find semantically duplicate issues.\n\nApproaches:\n1. Mechanical: Exact title/description matching\n2. Embeddings: Cosine similarity (cheap, scalable)\n3. AI: LLM-based semantic comparison (expensive, accurate)\n\nUses embeddings by default for \u003e100 issues.\n\nFiles: cmd/bd/find_duplicates.go (new)","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-29T20:49:49.126801-07:00","updated_at":"2025-10-30T17:12:58.218673-07:00"}
{"id":"bd-589c7c1e","content_hash":"efbc1fe1379d414d2af33f5aff9787e4f8a3234922199bdc9abce25dba99aef0","title":"Fix revive style issues (78 issues)","description":"Style violations: unused parameters (many cmd/args in cobra commands), missing exported comments, stuttering names (SQLiteStorage), indent-error-flow issues.","design":"Rename unused params to _, add godoc comments to exported types, fix stuttering names, simplify control flow.","notes":"Fixed 19 revive issues:\n- 14 unused-parameter (renamed to _)\n- 2 redefines-builtin-id (max→maxCount, min→minInt)\n- 3 indent-error-flow (gofmt fixed 2, skipped 1 complex nested one)\n\nRemaining issues are acceptable: 11 unused-params in deeper code, 2 empty-blocks with comments, 1 complex indent case, 1 superfluous-else in test.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-27T23:20:10.391821-07:00","updated_at":"2025-10-30T17:12:58.215077-07:00","closed_at":"2025-10-27T23:02:41.30653-07:00"}
{"id":"bd-5aad5a9c","content_hash":"03aa8900fd0e6f4bd911364bb69d4446f239c6a5e9688f0fc4928f3de1259242","title":"Add TestNWayCollision for 5+ clones","description":"## Overview\nAdd comprehensive tests for N-way (5+) collision resolution to verify the solution scales beyond 3 clones.\n\n## Purpose\nWhile TestThreeCloneCollision validates the basic N-way case, we need to verify:\n1. Solution scales to arbitrary N\n2. Performance is acceptable with more clones\n3. Convergence time is bounded\n4. No edge cases in larger collision groups\n\n## Implementation Tasks\n\n### 1. Create TestFiveCloneCollision\nFile: beads_twoclone_test.go (or new beads_nway_test.go)\n\n```go\nfunc TestFiveCloneCollision(t *testing.T) {\n    // Test with 5 clones creating same ID with different content\n    // Verify all 5 clones converge after sync rounds\n    \n    t.Run(\"SequentialSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"A\", \"B\", \"C\", \"D\", \"E\")\n    })\n    \n    t.Run(\"ReverseSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"E\", \"D\", \"C\", \"B\", \"A\")\n    })\n    \n    t.Run(\"RandomSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"C\", \"A\", \"E\", \"B\", \"D\")\n    })\n}\n```\n\n### 2. Implement generalized testNCloneCollision\nGeneralize the 3-clone test to handle arbitrary N:\n\n```go\nfunc testNCloneCollision(t *testing.T, numClones int, syncOrder ...string) {\n    t.Helper()\n    \n    if len(syncOrder) != numClones {\n        t.Fatalf(\"syncOrder length (%d) must match numClones (%d)\", \n            len(syncOrder), numClones)\n    }\n    \n    tmpDir := t.TempDir()\n    \n    // Setup remote and N clones\n    remoteDir := setupBareRepo(t, tmpDir)\n    cloneDirs := make(map[string]string)\n    \n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        cloneDirs[name] = setupClone(t, tmpDir, remoteDir, name)\n    }\n    \n    // Each clone creates issue with same ID but different content\n    for name, dir := range cloneDirs {\n        createIssue(t, dir, fmt.Sprintf(\"Issue from clone %s\", name))\n    }\n    \n    // Sync in specified order\n    for _, name := range syncOrder {\n        syncClone(t, cloneDirs[name], name)\n    }\n    \n    // Final pull for convergence\n    for name, dir := range cloneDirs {\n        finalPull(t, dir, name)\n    }\n    \n    // Verify all clones have all N issues\n    expectedTitles := make(map[string]bool)\n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        expectedTitles[fmt.Sprintf(\"Issue from clone %s\", name)] = true\n    }\n    \n    for name, dir := range cloneDirs {\n        titles := getTitles(t, dir)\n        if !compareTitleSets(titles, expectedTitles) {\n            t.Errorf(\"Clone %s missing issues: expected %v, got %v\", \n                name, expectedTitles, titles)\n        }\n    }\n    \n    t.Log(\"✓ All\", numClones, \"clones converged successfully\")\n}\n```\n\n### 3. Add performance benchmarks\nTest convergence time and memory usage:\n\n```go\nfunc BenchmarkNWayCollision(b *testing.B) {\n    for _, n := range []int{3, 5, 10, 20} {\n        b.Run(fmt.Sprintf(\"N=%d\", n), func(b *testing.B) {\n            for i := 0; i \u003c b.N; i++ {\n                // Run N-way collision and measure time\n                testNCloneCollisionBench(b, n)\n            }\n        })\n    }\n}\n```\n\n### 4. Add convergence time tests\nVerify bounded convergence:\n\n```go\nfunc TestConvergenceTime(t *testing.T) {\n    // Test that convergence happens within expected rounds\n    // For N clones, should converge in at most N-1 sync rounds\n    \n    for n := 3; n \u003c= 10; n++ {\n        t.Run(fmt.Sprintf(\"N=%d\", n), func(t *testing.T) {\n            rounds := measureConvergenceRounds(t, n)\n            maxExpected := n - 1\n            if rounds \u003e maxExpected {\n                t.Errorf(\"Convergence took %d rounds, expected ≤ %d\", \n                    rounds, maxExpected)\n            }\n        })\n    }\n}\n```\n\n### 5. Add edge case tests\nTest boundary conditions:\n- All N clones have identical content (dedup works)\n- N-1 clones have same content, 1 differs\n- All N clones have unique content\n- Mix of collisions and non-collisions\n\n## Acceptance Criteria\n- TestFiveCloneCollision passes with all sync orders\n- All 5 clones converge to identical content\n- Performance is acceptable (\u003c 5 seconds for 5 clones)\n- Convergence time is bounded (≤ N-1 rounds)\n- Edge cases handled correctly\n- Benchmarks show scalability to 10+ clones\n\n## Files to Create/Modify\n- beads_twoclone_test.go or beads_nway_test.go\n- Add helper functions for N-clone setup\n\n## Testing Strategy\n\n### Test Matrix\n| N Clones | Sync Orders | Expected Result |\n|----------|-------------|-----------------|\n| 3        | A→B→C       | Pass            |\n| 3        | C→B→A       | Pass            |\n| 5        | A→B→C→D→E   | Pass            |\n| 5        | E→D→C→B→A   | Pass            |\n| 5        | Random      | Pass            |\n| 10       | Sequential  | Pass            |\n\n### Performance Targets\n- 3 clones: \u003c 2 seconds\n- 5 clones: \u003c 5 seconds\n- 10 clones: \u003c 15 seconds\n\n## Dependencies\n- Requires bd-cbed9619.5, bd-cbed9619.4, bd-cbed9619.3, bd-dcd6f14b to be completed\n- TestThreeCloneCollision must pass first\n\n## Success Metrics\n- All tests pass for N ∈ {3, 5, 10}\n- Convergence time scales linearly (O(N))\n- Memory usage reasonable (\u003c 100MB for 10 clones)\n- No data corruption or loss in any scenario","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T19:52:05.462747-07:00","updated_at":"2025-10-31T12:00:43.198413-07:00","closed_at":"2025-10-31T12:00:43.198413-07:00"}
{"id":"bd-5b40a0bf","content_hash":"fd8a94f744b6504f677cc8e196c5a8d8b5d13b230200add5a8d9b7a54a537eb9","title":"Batch test 5","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T15:29:02.136118-07:00","updated_at":"2025-10-31T12:00:43.181513-07:00","closed_at":"2025-10-31T12:00:43.181513-07:00"}
{"id":"bd-5dae5504","content_hash":"4f2b5a203d6a7b5e38176dd6ef68afb4b7d0e11889718381e28bf006f4e83a16","title":"Export deduplication breaks when JSONL and export_hashes table diverge","description":"## Problem\n\nThe export deduplication feature (timestamp-only skipping) breaks when the JSONL file and export_hashes table get out of sync, causing exports to skip issues that aren't actually in the file.\n\n## Symptoms\n\n- `bd export` reports \"Skipped 128 issue(s) with timestamp-only changes\"\n- JSONL file only has 38 lines but DB has 149 issues\n- export_hashes table has 149 entries\n- Auto-import doesn't trigger (hash matches despite missing data)\n- Two repos on same commit show different issue counts\n\n## Root Cause\n\nshouldSkipExport() in autoflush.go compares current issue hash with stored export_hashes entry. If they match, it skips export assuming the issue is already in the JSONL.\n\nThis assumption fails when:\n1. Git operations (pull, reset, checkout) change JSONL without clearing export_hashes\n2. Manual JSONL edits or corruption\n3. Import operations that modify DB but don't update export_hashes\n4. Partial exports that update export_hashes but don't complete\n\n## Impact\n\n- **Critical data loss risk**: Issues appear to be tracked but aren't persisted to git\n- Breaks multi-repo sync (root cause of today's debugging session)\n- Auto-import fails to detect staleness (hash matches despite missing data)\n- Silent data corruption (no error messages, just missing issues)\n\n## Reproduction\n\n1. Have DB with 149 issues, all in export_hashes table\n2. Truncate JSONL to 38 lines (simulate git reset or corruption)\n3. Run `bd export` - it skips 128 issues\n4. JSONL still has only 38 lines but export thinks it succeeded\n\n## Current Workaround\n\n```bash\nsqlite3 .beads/beads.db \"DELETE FROM export_hashes\"\nbd export -o .beads/beads.jsonl\n```\n\n## Proposed Solutions\n\n**Option 1: Verify JSONL integrity before skipping**\n- Count lines in JSONL, compare with export_hashes count\n- If mismatch, clear export_hashes and force full export\n- Safe but adds I/O overhead\n\n**Option 2: Hash-based JSONL validation**\n- Store hash of entire JSONL file in metadata\n- Before export, check if JSONL hash matches\n- If mismatch, clear export_hashes\n- More efficient, detects any JSONL corruption\n\n**Option 3: Disable timestamp-only deduplication**\n- Remove the feature entirely\n- Always export all issues\n- Simplest and safest, but creates larger git commits\n\n**Option 4: Clear export_hashes on git operations**\n- Add post-merge hook to clear export_hashes\n- Clear on any import operation\n- Defensive approach but may over-clear\n\n## Recommended Fix\n\nCombination of Options 2 + 4:\n1. Store JSONL file hash in metadata after export\n2. Check hash before export, clear export_hashes if mismatch  \n3. Clear export_hashes on import operations\n4. Add `bd validate` check for JSONL/export_hashes sync\n\n## Files Involved\n\n- cmd/bd/autoflush.go (shouldSkipExport)\n- cmd/bd/export.go (export with deduplication)\n- internal/storage/sqlite/metadata.go (export_hashes table)","notes":"## Recovery Session (2025-10-29 21:30)\n\n### What Happened\n- Created 14 new hash ID issues (bd-f8b764c9 through bd-f8b764c9.1) \n- bd sync appeared to succeed\n- Canonical repo (~/src/beads): 162 issues in DB + JSONL ✓\n- Secondary repo (fred/beads): Only 145 issues vs 162 in canonical ✗\n- Both repos on same git commit but different issue counts!\n\n### Bug Manifestation During Recovery\n\n1. **Initial state**: fred/beads had 145 issues, 145 lines in JSONL, 145 export_hashes entries\n\n2. **After git reset --hard origin/main**: \n   - JSONL: 162 lines (from git)\n   - DB: 150 issues (auto-import partially worked)\n   - Auto-import failed with UNIQUE constraint error\n\n3. **After manual import --resolve-collisions**:\n   - DB: 160 issues\n   - JSONL: Still 162 lines\n   - export_hashes: 159 entries\n\n4. **After bd export**: \n   - **JSONL reduced to 17 lines!** ← The bug in action\n   - export_hashes: 159 entries (skipped exporting 142 issues)\n   - Silent data loss - no error message\n\n5. **After clearing export_hashes and re-export**:\n   - JSONL: 159 lines (missing 3 issues still)\n   - DB: 159 issues\n   - Still diverged from canonical\n\n### The Bug Loop\nOnce export_hashes and JSONL diverge:\n- Export skips issues already in export_hashes\n- But those issues aren't actually in JSONL\n- This creates corrupt JSONL with missing issues\n- Auto-import can't detect the problem (file hash matches what was exported)\n- Data is lost with no error messages\n\n### Recovery Solution\nCouldn't break the loop with export alone. Had to:\n1. Copy .beads/beads.db from canonical repo\n2. Clear export_hashes\n3. Full re-export\n4. Finally converged to 162 issues\n\n### Key Learnings\n\n1. **The bug is worse than we thought**: It can create corrupt exports (17 lines instead of 162!)\n\n2. **Auto-import can't save you**: Once export is corrupt, auto-import just imports the corrupt data\n\n3. **Silent failure**: No warnings, no errors, just missing issues\n\n4. **Git operations trigger it**: git reset, git pull, etc. change JSONL without clearing export_hashes\n\n5. **Import operations populate export_hashes**: Even manual imports update export_hashes, setting up future export failures\n\n### Immediate Action Required\n\n**DISABLE EXPORT DEDUPLICATION NOW**\n\nThis feature is fundamentally broken and causes data loss. Should be disabled until properly fixed.\n\nQuick fix options:\n- Set environment variable to disable feature\n- Comment out shouldSkipExport check\n- Always clear export_hashes before export\n- Add validation that DB count == JSONL line count before allowing export\n\n### Long-term Fix\n\nNeed Option 2 + 4 from proposed solutions:\n1. Store JSONL file hash after every successful export\n2. Before export, verify JSONL hash matches expected\n3. If mismatch, log WARNING and clear export_hashes\n4. Clear export_hashes on every import operation\n5. Add git post-merge hook to clear export_hashes\n6. Add `bd validate` command to detect divergence\n","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-10-29T23:05:13.959435-07:00","updated_at":"2025-10-30T17:12:58.207148-07:00","closed_at":"2025-10-29T21:57:03.06641-07:00"}
{"id":"bd-5e1f","content_hash":"3e3467773e73eb9dbb8dd8f213be7157c27d72b53c6cc9776616154db96c3864","title":"Issue with desc","description":"This is a description","status":"open","priority":2,"issue_type":"bug","created_at":"2025-10-31T21:41:11.128718-07:00","updated_at":"2025-10-31T21:41:11.128718-07:00"}
{"id":"bd-5f483051","content_hash":"d69f64f7f0bdc46a539dfe0b699a8977309c9c8d59f3e9beffbbe4484275a16b","title":"Implement bd resolve-conflicts (git merge conflicts in JSONL)","description":"Automatically detect and resolve git merge conflicts in .beads/issues.jsonl file.\n\nFeatures:\n- Detect conflict markers in JSONL\n- Parse conflicting issues from HEAD and BASE\n- Provide mechanical resolution (remap duplicate IDs)\n- Support AI-assisted resolution (requires internal/ai package)\n\nSee repair_commands.md lines 125-353 for design.","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-28T19:37:55.722827-07:00","updated_at":"2025-10-30T17:12:58.179718-07:00"}
{"id":"bd-6214875c","content_hash":"d4d20e71bbf5c08f1fe1ed07f67b7554167aa165d4972ea51b5cacc1b256c4c1","title":"Split internal/rpc/server.go into focused modules","description":"The file `internal/rpc/server.go` is 2,273 lines with 50+ methods, making it difficult to navigate and prone to merge conflicts. Split into 8 focused files with clear responsibilities.\n\nCurrent structure: Single 2,273-line file with:\n- Connection handling\n- Request routing\n- All 40+ RPC method implementations\n- Storage caching\n- Health checks \u0026 metrics\n- Cleanup loops\n\nTarget structure:\n```\ninternal/rpc/\n├── server.go          # Core server, connection handling (~300 lines)\n├── methods_issue.go   # Issue operations (~400 lines)\n├── methods_deps.go    # Dependency operations (~200 lines)\n├── methods_labels.go  # Label operations (~150 lines)\n├── methods_ready.go   # Ready work queries (~150 lines)\n├── methods_compact.go # Compaction operations (~200 lines)\n├── methods_comments.go # Comment operations (~150 lines)\n├── storage_cache.go   # Storage caching logic (~300 lines)\n└── health.go          # Health \u0026 metrics (~200 lines)\n```\n\nMigration strategy:\n1. Create new files with appropriate methods\n2. Keep `server.go` as main file with core server logic\n3. Test incrementally after each file split\n4. Final verification with full test suite","acceptance_criteria":"- All 50 methods split into appropriate files\n- Each file \u003c500 LOC\n- All methods remain on `*Server` receiver (no behavior change)\n- All tests pass: `go test ./internal/rpc/...`\n- Verify daemon works: start daemon, run operations, check health\n- Update internal documentation if needed\n- No change to public API","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T14:21:37.51524-07:00","updated_at":"2025-10-30T17:12:58.2179-07:00","closed_at":"2025-10-28T14:11:04.399811-07:00"}
{"id":"bd-6221bdcd","content_hash":"3bf15bc9e418180e1e91691261817c872330e182dbc1bcb756522faa42416667","title":"Improve cmd/bd test coverage (currently 20.2%)","description":"CLI commands need better test coverage. Focus on:\n- Command argument parsing\n- Error handling paths\n- Edge cases in create, update, close commands\n- Daemon commands\n- Import/export workflows","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T14:06:27.951656-07:00","updated_at":"2025-10-30T17:12:58.185819-07:00","dependencies":[{"issue_id":"bd-6221bdcd","depends_on_id":"bd-4d7fca8a","type":"blocks","created_at":"2025-10-29T19:52:05.532391-07:00","created_by":"import-remap"}]}
{"id":"bd-64c05d00","content_hash":"b39e902f3ad38a806bbd2d9248ae97df1d940f4b363f9f5baf1faf53b8ed520d","title":"Multi-clone collision resolution testing and documentation","description":"Epic to track improvements to multi-clone collision resolution based on ultrathinking analysis of-3d844c58 and bd-71107098.\n\nCurrent state:\n- 2-clone collision resolution is SOUND and working correctly\n- Hash-based deterministic collision resolution works\n- Test fails due to timestamp comparison, not actual logic issues\n\nWork needed:\n1. Fix TestTwoCloneCollision to compare content not timestamps\n2. Add TestThreeCloneCollision for regression protection\n3. Document 3-clone ID non-determinism as known behavior","status":"open","priority":1,"issue_type":"epic","created_at":"2025-10-28T17:58:38.316626-07:00","updated_at":"2025-10-31T19:38:09.209305-07:00"}
{"id":"bd-64c05d00.1","content_hash":"0744c30a5397c6c44b949c038af110eaf6453ec3800bff55cb027eecc47ab5b5","title":"Fix TestTwoCloneCollision to compare content not timestamps","description":"The test at beads_twoclone_test.go:204-207 currently compares full JSON output including timestamps, causing false negative failures.\n\nCurrent behavior:\n- Both clones converge to identical semantic content\n- Clone A: test-2=\"Issue from clone A\", test-1=\"Issue from clone B\"\n- Clone B: test-1=\"Issue from clone B\", test-2=\"Issue from clone A\"\n- Titles match IDs correctly, no data corruption\n- Only timestamps differ (expected and acceptable)\n\nFix needed:\n- Replace exact JSON comparison with content-aware comparison\n- Normalize or ignore timestamp fields when asserting convergence\n- Test should PASS after this fix\n\nThis blocks completion of bd-71107098.","acceptance_criteria":"- Test compares issue content (title, description, status, priority) not timestamps\n- TestTwoCloneCollision passes\n- Both clones shown to have identical semantic content\n- Timestamps explicitly documented as acceptable difference","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T17:58:52.057194-07:00","updated_at":"2025-10-30T17:12:58.226744-07:00","closed_at":"2025-10-28T18:01:38.751895-07:00","dependencies":[{"issue_id":"bd-64c05d00.1","depends_on_id":"bd-64c05d00","type":"parent-child","created_at":"2025-10-28T17:58:52.058202-07:00","created_by":"stevey"},{"issue_id":"bd-64c05d00.1","depends_on_id":"bd-71107098","type":"blocks","created_at":"2025-10-28T17:58:52.05873-07:00","created_by":"stevey"}]}
{"id":"bd-64c05d00.2","content_hash":"b86d4c406dd6783a00683a31c8729ea08e846e0ddbc54211e1e3d6dedb96def4","title":"Document 3-clone ID non-determinism in collision resolution","description":"Document the known behavior of 3+ way collision resolution where ID assignments may vary based on sync order, even though content always converges correctly.\n\nUpdates needed:\n- Update bd-71107098 notes to mark 2-clone case as solved\n- Document 3-clone ID non-determinism as known limitation\n- Add explanation to ADVANCED.md or collision resolution docs\n- Explain why this happens (pairwise hash comparison is deterministic, but multi-way ID allocation uses sync-order dependent counters)\n- Clarify trade-offs: content convergence ✅ vs ID stability ❌\n\nKey points to document:\n- Hash-based resolution is pairwise deterministic\n- Content always converges correctly (all issues present with correct data)\n- Numeric ID assignments in 3+ way collisions depend on sync order\n- This is acceptable for most use cases (content convergence is primary goal)\n- Full determinism would require complex multi-way comparison","acceptance_criteria":"- bd-71107098 updated with notes about 2-clone solution being complete\n- 3-clone ID non-determinism documented in ADVANCED.md or similar\n- Explanation includes why it happens and trade-offs\n- Links to TestThreeCloneCollision as demonstration\n- Users understand this is expected behavior, not a bug","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T17:59:21.93014-07:00","updated_at":"2025-10-30T17:12:58.227375-07:00","dependencies":[{"issue_id":"bd-64c05d00.2","depends_on_id":"bd-64c05d00","type":"parent-child","created_at":"2025-10-28T17:59:21.938709-07:00","created_by":"stevey"}]}
{"id":"bd-64c05d00.3","content_hash":"e006b991353a26f949bc3ae4476849ef785f399f6aca866586eb6fa03d243b35","title":"Add TestThreeCloneCollision for regression protection","description":"Add a 3-clone collision test to document behavior and provide regression protection.\n\nPurpose:\n- Verify content convergence regardless of sync order\n- Document the ID non-determinism behavior (IDs may be assigned differently based on sync order)\n- Provide regression protection for multi-way collisions\n\nTest design:\n- 3 clones create same ID with different content\n- Test two different sync orders (A→B→C vs C→A→B)\n- Assert content sets match (ignore specific ID assignments)\n- Add comment explaining ID non-determinism is expected behavior\n\nKnown limitation:\n- Content always converges correctly (all issues present with correct titles)\n- Numeric ID assignments (test-2 vs test-3) depend on sync order\n- This is acceptable if content convergence is the primary goal","acceptance_criteria":"- TestThreeCloneCollision added to beads_twoclone_test.go (or new file)\n- Tests 3 clones with same ID collision\n- Tests two different sync orders\n- Asserts content convergence (all issues present, correct titles)\n- Documents ID non-determinism in test comments\n- Test passes consistently","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-28T17:59:05.941735-07:00","updated_at":"2025-10-30T17:12:58.227089-07:00","closed_at":"2025-10-28T18:09:12.717604-07:00","dependencies":[{"issue_id":"bd-64c05d00.3","depends_on_id":"bd-64c05d00","type":"parent-child","created_at":"2025-10-28T17:59:05.942783-07:00","created_by":"stevey"}]}
{"id":"bd-69bce74a","content_hash":"1eb7b7d60d3be1dcae7ff1e8053b4c9e7dfdfb70f200151c9298be0bb4d5dc72","title":"Platform tests: Linux, macOS, Windows","description":"Test event-driven mode on all platforms. Verify inotify (Linux), FSEvents (macOS), ReadDirectoryChangesW (Windows). Test fallback behavior on each.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T19:42:29.85636-07:00","updated_at":"2025-10-30T17:12:58.193697-07:00","closed_at":"2025-10-29T15:33:22.149551-07:00"}
{"id":"bd-69fbe98e","content_hash":"b9211785e5423ab62d313590115309dab023b0c418b8d06f8bf98442c1ff740d","title":"Implement \"bd daemons logs\" subcommand","description":"Add command to view daemon logs for a specific workspace. Requires daemon logging to file (may need separate issue for log infrastructure).","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-26T19:41:11.099659-07:00","updated_at":"2025-10-30T17:12:58.186556-07:00"}
{"id":"bd-6ada971e","content_hash":"3979df7395526a6796508aa1ed1e89c4fedc46ee5c2b79dd85066c8a78c8487a","title":"Create cmd/bd/daemon_event_loop.go (~200 LOC)","description":"Implement runEventDrivenLoop to replace polling ticker. Coordinate FileWatcher, mutation events, debouncer. Include health check ticker (60s) for daemon validation.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T16:20:02.429383-07:00","updated_at":"2025-10-30T17:12:58.220612-07:00","closed_at":"2025-10-28T12:30:44.067036-07:00"}
{"id":"bd-6bebe013","content_hash":"80a473ecbec089a83cb325346eb851661d0fe35a25c6d73fb92827abcfa36267","title":"Rapid 1","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T19:11:57.404437-07:00","updated_at":"2025-10-30T17:12:58.189046-07:00"}
{"id":"bd-6c68","content_hash":"f7ef67ce2fd11e890f8c251cdebd3a618faa83c166c01c043d6f3d18d01d5811","title":"bd info shows 'auto_start_disabled' even when daemon is crashed/missing","description":"","status":"open","priority":1,"issue_type":"bug","created_at":"2025-10-31T21:08:03.385681-07:00","updated_at":"2025-10-31T21:08:03.385681-07:00","dependencies":[{"issue_id":"bd-6c68","depends_on_id":"bd-2752a7a2","type":"discovered-from","created_at":"2025-10-31T21:08:03.387045-07:00","created_by":"stevey"}]}
{"id":"bd-6d7efe32","content_hash":"40b55f82509b9642dfa4a71a749e39183024f5a6347ffdc3bc49050e5279058a","title":"CRDT-based architecture for guaranteed convergence (v2.0)","description":"## Vision\nRedesign beads around Conflict-Free Replicated Data Types (CRDTs) to provide mathematical guarantees for N-way collision resolution at arbitrary scale.\n\n## Current Limitations\n- Content-hash based collision resolution fails at 5+ clones\n- Non-deterministic convergence in multi-round scenarios\n- UNIQUE constraint violations during rename operations\n- No formal proof of convergence properties\n\n## CRDT Benefits\n- Provably convergent (Strong Eventual Consistency)\n- Commutative/Associative/Idempotent operations\n- No coordination required between clones\n- Scales to 100+ concurrent workers\n- Well-understood mathematical foundations\n\n## Proposed Architecture\n\n### 1. UUID-Based IDs\nReplace sequential IDs with UUIDs:\n- Current: bd-1c63eb84, bd-9063acda, bd-4d80b7b1\n- CRDT: bd-a1b2c3d4-e5f6-7890-abcd-ef1234567890\n- Human aliases maintained separately: #42 maps to UUID\n\n### 2. Last-Write-Wins (LWW) Elements\nEach field becomes an LWW register:\n- title: (timestamp, clone_id, value)\n- status: (timestamp, clone_id, value)\n- Deterministic conflict resolution via Lamport timestamp + clone_id tiebreaker\n\n### 3. Operation Log\nTrack all operations as CRDT ops:\n- CREATE(uuid, timestamp, clone_id, fields)\n- UPDATE(uuid, field, timestamp, clone_id, value)\n- DELETE(uuid, timestamp, clone_id) - tombstone, not hard delete\n\n### 4. Sync as Merge\nSyncing becomes merging two CRDT states:\n- No merge conflicts possible\n- Deterministic merge function\n- Guaranteed convergence\n\n## Implementation Phases\n\n### Phase 1: Research \u0026 Design (4 weeks)\n- Study existing CRDT implementations (Automerge, Yjs, Loro)\n- Design schema for CRDT-based issue tracking\n- Prototype LWW-based Issue CRDT\n- Benchmark performance vs current system\n\n### Phase 2: Parallel Implementation (6 weeks)\n- Implement CRDT storage layer alongside SQLite\n- Build conversion tools: SQLite ↔ CRDT\n- Maintain backward compatibility with v1.x format\n- Migration path for existing databases\n\n### Phase 3: Testing \u0026 Validation (4 weeks)\n- Formal verification of convergence properties\n- Stress testing with 100+ clone scenario\n- Performance profiling and optimization\n- Documentation and examples\n\n### Phase 4: Migration \u0026 Rollout (4 weeks)\n- Release v2.0-beta with CRDT backend\n- Gradual migration from v1.x\n- Monitoring and bug fixes\n- Final v2.0 release\n\n## Risks \u0026 Mitigations\n\n**Risk 1: Performance overhead**\n- Mitigation: Benchmark early, optimize hot paths\n- CRDTs can be slower than append-only logs\n- May need compaction strategy\n\n**Risk 2: Storage bloat**\n- Mitigation: Implement operation log compaction\n- Tombstone garbage collection for deleted issues\n- Periodic snapshots to reduce log size\n\n**Risk 3: Breaking changes**\n- Mitigation: Maintain v1.x compatibility layer\n- Gradual migration tools\n- Dual-mode operation during transition\n\n**Risk 4: Complexity**\n- Mitigation: Use battle-tested CRDT libraries\n- Comprehensive documentation\n- Clear migration guide\n\n## Success Criteria\n- 100-clone collision test passes without failures\n- Formal proof of convergence properties\n- Performance within 2x of current system\n- Zero manual conflict resolution required\n- Backward compatible with v1.x databases\n\n## Timeline\n18-20 weeks total (4-5 months)\n\n## References\n- Automerge: https://automerge.org\n- Yjs: https://docs.yjs.dev\n- Loro: https://loro.dev\n- CRDT theory: Shapiro et al, A comprehensive study of CRDTs\n- Related issues: bd-e6d71828, bd-7a2b58fc, bd-81abb639","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-10-29T20:48:00.267237-07:00","updated_at":"2025-10-31T20:06:44.604643-07:00","closed_at":"2025-10-31T20:06:44.604643-07:00"}
{"id":"bd-6fe4622f","content_hash":"d0d8e0634aea5e60373d339b363d7601af5d42d0f90780a54a4978c3e39ca747","title":"Remove unreachable utility functions","description":"Several small utility functions are unreachable:\n\nFiles to clean:\n1. `internal/storage/sqlite/hash.go` - `computeIssueContentHash` (line 17)\n   - Check if entire file can be deleted if only contains this function\n\n2. `internal/config/config.go` - `FileUsed` (line 151)\n   - Delete unused config helper\n\n3. `cmd/bd/git_sync_test.go` - `verifyIssueOpen` (line 300)\n   - Delete dead test helper\n\n4. `internal/compact/haiku.go` - `HaikuClient.SummarizeTier2` (line 81)\n   - Tier 2 summarization not implemented\n   - Options: implement feature OR delete method\n\nImpact: Removes 50-100 LOC depending on decisions","acceptance_criteria":"- Remove unreachable functions\n- If entire files can be deleted (like hash.go), delete them\n- For SummarizeTier2: decide to implement or delete, document decision\n- All tests pass: `go test ./...`\n- Verify no callers exist for each function","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T16:20:02.434573-07:00","updated_at":"2025-10-30T17:12:58.224957-07:00"}
{"id":"bd-70419816","content_hash":"1ee07b713143f1abcc3c8189ae49a41e34669822a1843fe1ca823c5f69af4494","title":"Export deduplication breaks when JSONL and export_hashes table diverge","description":"## Problem\n\nThe export deduplication feature (timestamp-only skipping) breaks when the JSONL file and export_hashes table get out of sync, causing exports to skip issues that aren't actually in the file.\n\n## Symptoms\n\n- `bd export` reports \"Skipped 128 issue(s) with timestamp-only changes\"\n- JSONL file only has 38 lines but DB has 149 issues\n- export_hashes table has 149 entries\n- Auto-import doesn't trigger (hash matches despite missing data)\n- Two repos on same commit show different issue counts\n\n## Root Cause\n\nshouldSkipExport() in autoflush.go compares current issue hash with stored export_hashes entry. If they match, it skips export assuming the issue is already in the JSONL.\n\nThis assumption fails when:\n1. Git operations (pull, reset, checkout) change JSONL without clearing export_hashes\n2. Manual JSONL edits or corruption\n3. Import operations that modify DB but don't update export_hashes\n4. Partial exports that update export_hashes but don't complete\n\n## Impact\n\n- **Critical data loss risk**: Issues appear to be tracked but aren't persisted to git\n- Breaks multi-repo sync (root cause of today's debugging session)\n- Auto-import fails to detect staleness (hash matches despite missing data)\n- Silent data corruption (no error messages, just missing issues)\n\n## Reproduction\n\n1. Have DB with 149 issues, all in export_hashes table\n2. Truncate JSONL to 38 lines (simulate git reset or corruption)\n3. Run `bd export` - it skips 128 issues\n4. JSONL still has only 38 lines but export thinks it succeeded\n\n## Current Workaround\n\n```bash\nsqlite3 .beads/beads.db \"DELETE FROM export_hashes\"\nbd export -o .beads/beads.jsonl\n```\n\n## Proposed Solutions\n\n**Option 1: Verify JSONL integrity before skipping**\n- Count lines in JSONL, compare with export_hashes count\n- If mismatch, clear export_hashes and force full export\n- Safe but adds I/O overhead\n\n**Option 2: Hash-based JSONL validation**\n- Store hash of entire JSONL file in metadata\n- Before export, check if JSONL hash matches\n- If mismatch, clear export_hashes\n- More efficient, detects any JSONL corruption\n\n**Option 3: Disable timestamp-only deduplication**\n- Remove the feature entirely\n- Always export all issues\n- Simplest and safest, but creates larger git commits\n\n**Option 4: Clear export_hashes on git operations**\n- Add post-merge hook to clear export_hashes\n- Clear on any import operation\n- Defensive approach but may over-clear\n\n## Recommended Fix\n\nCombination of Options 2 + 4:\n1. Store JSONL file hash in metadata after export\n2. Check hash before export, clear export_hashes if mismatch  \n3. Clear export_hashes on import operations\n4. Add `bd validate` check for JSONL/export_hashes sync\n\n## Files Involved\n\n- cmd/bd/autoflush.go (shouldSkipExport)\n- cmd/bd/export.go (export with deduplication)\n- internal/storage/sqlite/metadata.go (export_hashes table)","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-10-29T23:05:13.960352-07:00","updated_at":"2025-10-30T17:12:58.19679-07:00","closed_at":"2025-10-29T22:22:20.406934-07:00"}
{"id":"bd-710a4916","content_hash":"3d8be03f83f87067b1aaf295b0b829d20890e47686e0da10ef81d2096f5ca974","title":"CRDT-based architecture for guaranteed convergence (v2.0)","description":"## Vision\nRedesign beads around Conflict-Free Replicated Data Types (CRDTs) to provide mathematical guarantees for N-way collision resolution at arbitrary scale.\n\n## Current Limitations\n- Content-hash based collision resolution fails at 5+ clones\n- Non-deterministic convergence in multi-round scenarios\n- UNIQUE constraint violations during rename operations\n- No formal proof of convergence properties\n\n## CRDT Benefits\n- Provably convergent (Strong Eventual Consistency)\n- Commutative/Associative/Idempotent operations\n- No coordination required between clones\n- Scales to 100+ concurrent workers\n- Well-understood mathematical foundations\n\n## Proposed Architecture\n\n### 1. UUID-Based IDs\nReplace sequential IDs with UUIDs:\n- Current: bd-1c63eb84, bd-9063acda, bd-4d80b7b1\n- CRDT: bd-a1b2c3d4-e5f6-7890-abcd-ef1234567890\n- Human aliases maintained separately: #42 maps to UUID\n\n### 2. Last-Write-Wins (LWW) Elements\nEach field becomes an LWW register:\n- title: (timestamp, clone_id, value)\n- status: (timestamp, clone_id, value)\n- Deterministic conflict resolution via Lamport timestamp + clone_id tiebreaker\n\n### 3. Operation Log\nTrack all operations as CRDT ops:\n- CREATE(uuid, timestamp, clone_id, fields)\n- UPDATE(uuid, field, timestamp, clone_id, value)\n- DELETE(uuid, timestamp, clone_id) - tombstone, not hard delete\n\n### 4. Sync as Merge\nSyncing becomes merging two CRDT states:\n- No merge conflicts possible\n- Deterministic merge function\n- Guaranteed convergence\n\n## Implementation Phases\n\n### Phase 1: Research \u0026 Design (4 weeks)\n- Study existing CRDT implementations (Automerge, Yjs, Loro)\n- Design schema for CRDT-based issue tracking\n- Prototype LWW-based Issue CRDT\n- Benchmark performance vs current system\n\n### Phase 2: Parallel Implementation (6 weeks)\n- Implement CRDT storage layer alongside SQLite\n- Build conversion tools: SQLite ↔ CRDT\n- Maintain backward compatibility with v1.x format\n- Migration path for existing databases\n\n### Phase 3: Testing \u0026 Validation (4 weeks)\n- Formal verification of convergence properties\n- Stress testing with 100+ clone scenario\n- Performance profiling and optimization\n- Documentation and examples\n\n### Phase 4: Migration \u0026 Rollout (4 weeks)\n- Release v2.0-beta with CRDT backend\n- Gradual migration from v1.x\n- Monitoring and bug fixes\n- Final v2.0 release\n\n## Risks \u0026 Mitigations\n\n**Risk 1: Performance overhead**\n- Mitigation: Benchmark early, optimize hot paths\n- CRDTs can be slower than append-only logs\n- May need compaction strategy\n\n**Risk 2: Storage bloat**\n- Mitigation: Implement operation log compaction\n- Tombstone garbage collection for deleted issues\n- Periodic snapshots to reduce log size\n\n**Risk 3: Breaking changes**\n- Mitigation: Maintain v1.x compatibility layer\n- Gradual migration tools\n- Dual-mode operation during transition\n\n**Risk 4: Complexity**\n- Mitigation: Use battle-tested CRDT libraries\n- Comprehensive documentation\n- Clear migration guide\n\n## Success Criteria\n- 100-clone collision test passes without failures\n- Formal proof of convergence properties\n- Performance within 2x of current system\n- Zero manual conflict resolution required\n- Backward compatible with v1.x databases\n\n## Timeline\n18-20 weeks total (4-5 months)\n\n## References\n- Automerge: https://automerge.org\n- Yjs: https://docs.yjs.dev\n- Loro: https://loro.dev\n- CRDT theory: Shapiro et al, A comprehensive study of CRDTs\n- Related issues: bd-e6d71828, bd-7a2b58fc,-1","status":"open","priority":3,"issue_type":"feature","created_at":"2025-10-29T10:23:57.978339-07:00","updated_at":"2025-10-30T17:12:58.182513-07:00"}
{"id":"bd-71107098","content_hash":"9feb9a8dc8ae2dc65b11edeff37cf5ce48d8f28e1ced45d64ac0176937610296","title":"Make two-clone workflow actually work (no hacks)","description":"TestTwoCloneCollision proves beads CANNOT handle two independent clones filing issues simultaneously. This is the basic collaborative workflow and it must work cleanly.\n\nTest location: beads_twoclone_test.go\n\nThe test creates two git clones, both file issues with same ID (test-1), --resolve-collisions remaps clone B's to test-2, but after sync:\n- Clone A has test-1=\"Issue from clone A\", test-2=\"Issue from clone B\"  \n- Clone B has test-1=\"Issue from clone B\", test-2=\"Issue from clone A\"\n\nThe TITLES are swapped! Both clones have 2 issues but with opposite title assignments.\n\nWe've tried many fixes (per-project daemons, auto-sync, lamport hashing, precommit hooks) but nothing has made the test pass.\n\nGoal: Make the test pass WITHOUT hacks. The two clones should converge to identical state after sync.","acceptance_criteria":"1. TestTwoCloneCollision passes without EXPECTED FAILURE\n2. Both clones converge to identical issue database\n3. No manual conflict resolution required\n4. Git status clean in both clones\n5. bd ready output identical in both clones","notes":"**Major progress achieved!** The two-clone workflow now converges correctly.\n\n**What was fixed:**\n--3d844c58: Implemented content-hash based rename detection\n- bd-64c05d00.1: Fixed test to compare content not timestamps\n- Both clones now converge to identical issue databases\n- test-1 and test-2 have correct titles in both clones\n- No more title swapping!\n\n**Current status (VERIFIED):**\n✅ Acceptance criteria 1: TestTwoCloneCollision passes (confirmed Oct 28)\n✅ Acceptance criteria 2: Both clones converge to identical issue database (content matches)\n✅ Acceptance criteria 3: No manual conflict resolution required (automatic)\n✅ Acceptance criteria 4: Git status clean\n✅ Acceptance criteria 5: bd ready output identical (timestamps are expected difference)\n\n**ALL ACCEPTANCE CRITERIA MET!** This issue is complete and can be closed.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-10-28T16:34:53.278793-07:00","updated_at":"2025-10-31T19:38:09.206303-07:00","closed_at":"2025-10-28T19:20:04.143242-07:00"}
{"id":"bd-763c","content_hash":"6943cea47a7851c7d1eb316f4669fb8ae2b843a68a89b441fdca5e0be0193494","title":"~/src/beads daemon has 'sql: database is closed' errors - zombie daemon","description":"","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-10-31T21:08:03.388007-07:00","updated_at":"2025-10-31T21:52:04.214274-07:00","closed_at":"2025-10-31T21:52:04.214274-07:00","dependencies":[{"issue_id":"bd-763c","depends_on_id":"bd-2752a7a2","type":"discovered-from","created_at":"2025-10-31T21:08:03.388716-07:00","created_by":"stevey"}]}
{"id":"bd-7a00c94e","content_hash":"b31566a4b2a84db7d24364492e8ac6ebfa1f5fc27fe270fbd58b27e17218c9c4","title":"Rapid 2","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T19:11:57.430725-07:00","updated_at":"2025-10-30T17:12:58.189251-07:00"}
{"id":"bd-7a2b58fc","content_hash":"e887227ed9b3f477282569800eb4683b68bf1a5404f007e00ec44b2e570325b5","title":"Implement clone-scoped ID allocation to prevent N-way collisions","description":"## Problem\nCurrent ID allocation uses per-clone atomic counters (issue_counters table) that sync based on local database state. In N-way collision scenarios:\n- Clone B sees {test-1} locally, allocates test-2\n- Clone D sees {test-1, test-2, test-3} locally, allocates test-4\n- When same content gets assigned test-2 and test-4, convergence fails\n\nRoot cause: Each clone independently allocates IDs without global coordination, leading to overlapping assignments for the same content.\n\n## Solution\nAdd clone UUID to ID allocation to make every ID globally unique:\n\n**Current format:** `test-1`, `test-2`, `test-3`\n**New format:** `test-1-a7b3`, `test-2-a7b3`, `test-3-c4d9`\n\nWhere suffix is first 4 chars of clone UUID.\n\n## Implementation\n\n### 1. Add clone_identity table\n```sql\nCREATE TABLE clone_identity (\n    clone_uuid TEXT PRIMARY KEY,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### 2. Modify getNextIDForPrefix()\n```go\nfunc (s *SQLiteStorage) getNextIDForPrefix(ctx context.Context, prefix string) (string, error) {\n    cloneUUID := s.getOrCreateCloneUUID(ctx)\n    shortUUID := cloneUUID[:4]\n    \n    nextNum := s.getNextCounterForPrefix(ctx, prefix)\n    return fmt.Sprintf(\"%s-%d-%s\", prefix, nextNum, shortUUID), nil\n}\n```\n\n### 3. Update ID parsing logic\nAll places that parse IDs (utils.ExtractIssueNumber, etc.) need to handle new format.\n\n### 4. Migration strategy\n- Existing IDs remain unchanged (no suffix)\n- New IDs get clone suffix automatically\n- Display layer can hide suffix in UI: `bd-cb64c226.3-a7b3` → `#42`\n\n## Benefits\n- **Zero collision risk**: Same content in different clones gets different IDs\n- **Maintains readability**: Still sequential numbering within clone\n- **No coordination needed**: Works offline, no central authority\n- **Scales to 100+ clones**: 4-char hex = 65,536 unique clones\n\n## Concerns\n- ID format change may break existing integrations\n- Need migration path for existing databases\n- Display logic needs update to hide/show suffixes appropriately\n\n## Success Criteria\n- 10+ clone collision test passes without failures\n- Existing issues continue to work (backward compatibility)\n- Documentation updated with new ID format\n- Migration guide for v1.x → v2.x\n\n## Timeline\nMedium-term (v1.1-v1.2), 2-3 weeks implementation\n\n## References\n- Related to bd-0dcea000 (immediate fix)\n- See beads_nway_test.go for failing N-way tests","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-29T20:02:47.952447-07:00","updated_at":"2025-10-31T17:53:09.075064-07:00"}
{"id":"bd-7bbc4e6a","content_hash":"3251d757d9ad69cd4b3517862ec1b9b1cc13388ea4c93a2f3b2b54920112854f","title":"Add MCP server functions for repair commands","description":"Expose new repair commands via MCP server for agent access:\n\nFunctions to add:\n- beads_repair_deps()\n- beads_detect_pollution()\n- beads_validate()\n- beads_resolve_conflicts() (when implemented)\n\nUpdate integrations/beads-mcp/src/beads_mcp/server.py\n\nSee repair_commands.md lines 803-884 for design.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T19:37:55.72639-07:00","updated_at":"2025-10-30T17:12:58.179948-07:00"}
{"id":"bd-7c5915ae","content_hash":"4e6cbaa3b21b320d21e4aefcb7e78a5223d6291803c8e18cb891aecc242bd1e9","title":"Run final validation and cleanup checks","description":"Final validation pass to ensure all cleanup objectives met and no regressions introduced.\n\nValidation checklist:\n1. Dead code verification: `go run golang.org/x/tools/cmd/deadcode@latest -test ./...`\n2. Test coverage: `go test -cover ./...`\n3. Build verification: `go build ./cmd/bd/`\n4. Linting: `golangci-lint run`\n5. Integration tests\n6. Metrics verification\n7. Git clean check\n\nFinal metrics to report:\n- LOC removed: ~____\n- Files deleted: ____\n- Files created: ____\n- Test coverage: ____%\n- Build time: ____ (before/after)\n- Test run time: ____ (before/after)\n\nImpact: Confirms all cleanup objectives achieved successfully","acceptance_criteria":"- Zero unreachable functions per deadcode analyzer\n- All tests pass: `go test ./...`\n- Test coverage maintained or improved\n- Builds cleanly: `go build ./...`\n- Linting shows improvements\n- Integration tests all pass\n- LOC reduction target achieved (~2,500 LOC)\n- No unintended behavior changes\n- Git commit messages document all changes","notes":"## Validation Results (Oct 31, 2025)\n\n**Dead Code:** ✅ Removed 5 unreachable functions (~200 LOC)\n- computeIssueContentHash, shouldSkipExport (autoflush.go)\n- addDependencyUnchecked, removeDependencyIfExists (dependencies.go)\n- isUniqueConstraintError (util.go)\n\n**Tests:** ✅ All pass\n**Coverage:** \n- Main package: 39.6%\n- cmd/bd: 19.5%\n- internal/daemon: 37.8%\n- internal/storage/sqlite: 58.1%\n- internal/rpc: 58.6%\n\n**Build:** ✅ Clean (24.5 MB binary)\n**Linting:** 247 issues (mostly errcheck on defer/Close statements)\n**Integration Tests:** ✅ All pass\n**Metrics:** 55,622 LOC across 200 Go files\n**Git:** 3 files modified (dead code removal)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T20:49:49.131575-07:00","updated_at":"2025-10-31T15:12:01.955668-07:00","closed_at":"2025-10-31T15:12:01.955668-07:00","dependencies":[{"issue_id":"bd-7c5915ae","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-31T19:38:09.176473-07:00","created_by":"stevey"}]}
{"id":"bd-7c831c51","content_hash":"192d94c432595c1051f254a25bb6325e9b98ceccfb369dc43e0619c27016feae","title":"Run final validation and cleanup checks","description":"Final validation pass to ensure all cleanup objectives met and no regressions introduced.\n\nValidation checklist:\n1. Dead code verification: `go run golang.org/x/tools/cmd/deadcode@latest -test ./...`\n2. Test coverage: `go test -cover ./...`\n3. Build verification: `go build ./cmd/bd/`\n4. Linting: `golangci-lint run`\n5. Integration tests\n6. Metrics verification\n7. Git clean check\n\nFinal metrics to report:\n- LOC removed: ~____\n- Files deleted: ____\n- Files created: ____\n- Test coverage: ____%\n- Build time: ____ (before/after)\n- Test run time: ____ (before/after)\n\nImpact: Confirms all cleanup objectives achieved successfully","acceptance_criteria":"- Zero unreachable functions per deadcode analyzer\n- All tests pass: `go test ./...`\n- Test coverage maintained or improved\n- Builds cleanly: `go build ./...`\n- Linting shows improvements\n- Integration tests all pass\n- LOC reduction target achieved (~2,500 LOC)\n- No unintended behavior changes\n- Git commit messages document all changes","notes":"## Validation Results\n\n**Dead Code:** ✅ Found and removed 1 unreachable function (`DroppedEventsCount`)  \n**Tests:** ✅ All pass  \n**Coverage:**  \n- Main: 39.6%\n- cmd/bd: 20.2%\n- Created follow-up issues (bd-85487065 through bd-bc2c6191) to improve coverage\n  \n**Build:** ✅ Clean  \n**Linting:** 73 issues (up from 34 baseline)  \n- Increase due to unused functions from refactoring\n- Need cleanup in separate issue\n  \n**Integration Tests:** ✅ All pass  \n**Metrics:** 56,464 LOC across 193 Go files  \n**Git:** 2 files modified (deadcode fix + auto-synced JSONL)\n\n## Follow-up Issues Created\n- bd-85487065: Add tests for internal/autoimport (0% coverage)\n- bd-0dcea000: Add tests for internal/importer (0% coverage)\n- bd-4d7fca8a: Add tests for internal/utils (0% coverage)\n- bd-6221bdcd: Improve cmd/bd coverage (20.2% -\u003e target higher)\n- bd-bc2c6191: Improve internal/daemon coverage (22.5% -\u003e target higher)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T20:02:47.956276-07:00","updated_at":"2025-10-30T17:12:58.193468-07:00","closed_at":"2025-10-29T14:19:35.095553-07:00"}
{"id":"bd-7da9437e","content_hash":"c00bf7c9fe41b90f1bd3cd1e7cf6938ca4e42f076ce45c2a3d836db97c883fc4","title":"Latency test","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T15:28:52.729923-07:00","updated_at":"2025-10-31T12:00:43.184758-07:00","closed_at":"2025-10-31T12:00:43.184758-07:00"}
{"id":"bd-7e0d6660","content_hash":"84f212d47832be4670333dc0148e3de158ca3a2dc7cb68b992f8536409272cfb","title":"Handle unchecked errors (errcheck - 683 issues)","description":"683 unchecked error returns, mostly in tests (Close, Rollback, RemoveAll). Many already excluded in config but still showing up.","design":"Review .golangci.yml exclude-rules. Most defer Close/Rollback errors in tests can be ignored. Add systematic exclusions or explicit _ = assignments where appropriate.","notes":"Fixed all errcheck warnings in production code:\n- Enabled errcheck linter (was disabled)\n- Set tests: false in .golangci.yml to focus on production code\n- Fixed 27 total errors in production code using Oracle guidance:\n  * Database patterns: defer func() { _ = rows.Close() }() and defer func() { _ = tx.Rollback() }()\n  * Best-effort closers: _ = store.Close(), _ = client.Close()\n  * Proper error handling for file writes, fmt.Scanln(), os.Remove()\n- All tests pass\n- Only 2 \"unused\" linter warnings remain (not errcheck)","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-27T23:20:10.392336-07:00","updated_at":"2025-10-30T17:12:58.215288-07:00","closed_at":"2025-10-27T23:05:31.945328-07:00"}
{"id":"bd-7e7ddffa","content_hash":"3b0e0f6e769eb263cf342d64c40de3dc23995ef672d9142fd6f278dc3dee633a","title":"Repair Commands \u0026 AI-Assisted Tooling","description":"Add specialized repair tools to reduce agent repair burden:\n1. Git merge conflicts in JSONL\n2. Duplicate issues from parallel work\n3. Semantic inconsistencies\n4. Orphaned references\n\nSee ~/src/fred/beads/repair_commands.md for full design doc.\n\nReduces agent repair time from 5-10 minutes to \u003c30 seconds per repair.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-10-28T19:30:17.465812-07:00","updated_at":"2025-10-30T17:12:58.179404-07:00"}
{"id":"bd-7e7ddffa.1","content_hash":"df6de1f6a58a995d979a7be59c2fb38800e81b96e8fa0bd39980f8bf9f1a4f37","title":"bd resolve-conflicts - Git merge conflict resolver","description":"Automatically resolve JSONL merge conflicts.\n\nModes:\n- Mechanical: ID remapping (no AI)\n- AI-assisted: Smart merge/keep decisions\n- Interactive: Review each conflict\n\nHandles \u003c\u003c\u003c\u003c\u003c\u003c\u003c conflict markers in .beads/beads.jsonl\n\nFiles: cmd/bd/resolve_conflicts.go (new)","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-28T14:48:30.083642-07:00","updated_at":"2025-10-30T17:12:58.220145-07:00","dependencies":[{"issue_id":"bd-7e7ddffa.1","depends_on_id":"bd-7e7ddffa","type":"parent-child","created_at":"2025-10-29T19:58:28.847736-07:00","created_by":"stevey"}]}
{"id":"bd-7eed","content_hash":"f491845894c23d141399b422109c45015fe725b2d5c27bd68484d2306fcf55dd","title":"Remove obsolete stale.go command (executor tables never implemented)","description":"","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-10-31T21:27:05.555369-07:00","updated_at":"2025-10-31T21:27:11.427631-07:00","closed_at":"2025-10-31T21:27:11.427631-07:00"}
{"id":"bd-81abb639","content_hash":"5af6696b1bbfc76056771aa71ac6f72aaadb72e3fb139c09eb7680b86c9053c8","title":"Investigate jujutsu VCS as potential solution for conflict-free merging","description":"## Context\nCurrent N-way collision resolution struggles with Git line-based merge model. When 5+ clones create issues with same ID, Git merge conflicts require manual resolution, and our collision resolver can fail during convergence rounds.\n\n## Research Question\nCould jujutsu (jj) provide better conflict handling for JSONL files?\n\n## Jujutsu Overview\n- Next-gen VCS built on libgit2\n- Designed to handle conflicts as first-class citizens\n- Supports conflict-free replicated data types (CRDTs) in some scenarios\n- Better handling of concurrent edits\n- Can work with Git repos (compatible with existing infrastructure)\n\n## Investigation Tasks\n1. JSONL Merge Behavior - How does jj handle line-by-line JSONL conflicts?\n2. Integration Feasibility - Can beads use jj as backend while maintaining Git compatibility?\n3. Conflict Resolution Model - Does jj conflict model map to our collision resolution?\n4. Operational Transform Support - Does jj implement operational transforms?\n\n## Deliverables\n1. Technical report on jj merge algorithm for JSONL\n2. Proof-of-concept: 5-clone collision test using jj instead of Git\n3. Performance comparison: Git vs jj for beads workload\n4. Recommendation: Adopt, experiment further, or abandon\n\n## References\n- https://github.com/martinvonz/jj\n- Related to bd-e6d71828, bd-7a2b58fc","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T20:02:47.953008-07:00","updated_at":"2025-10-30T17:12:58.19464-07:00","closed_at":"2025-10-29T20:47:52.910985-07:00"}
{"id":"bd-833559b3","content_hash":"9082c986207b9df7a7a4dc87a53007849e2b9f6e92f3bea41e22d6a14f1f6f42","title":"bd validate - Comprehensive health check","description":"Run all validation checks in one command.\n\nChecks:\n- Duplicates\n- Orphaned dependencies\n- Test pollution\n- Git conflicts\n\nSupports --fix-all for auto-repair.\n\nDepends on bd-cbed9619.1, bd-0dcea000, bd-2752a7a2, bd-9826b69a.\n\nFiles: cmd/bd/validate.go (new)","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-29T20:02:47.957692-07:00","updated_at":"2025-10-30T17:12:58.219095-07:00"}
{"id":"bd-83f0bb64","content_hash":"c7be091ee7e713dd9c8ec0f9a498a9ae12adb09f8b7510a5ec10a815a05322e1","title":"Platform tests: Linux, macOS, Windows","description":"Test event-driven mode on all platforms. Verify inotify (Linux), FSEvents (macOS), ReadDirectoryChangesW (Windows). Test fallback behavior on each.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T19:42:29.857419-07:00","updated_at":"2025-10-31T12:00:43.197445-07:00","closed_at":"2025-10-31T12:00:43.197445-07:00"}
{"id":"bd-85487065","content_hash":"637cbd56af122b175ff060b4df050871fe86124c5d883ba7f8a17f2f95479613","title":"Add tests for internal/autoimport package","description":"Currently 0.0% coverage. Need tests for auto-import functionality that detects and imports updated JSONL files.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T14:06:18.154805-07:00","updated_at":"2025-10-30T17:12:58.182987-07:00"}
{"id":"bd-8900f145","content_hash":"4a07f36a9e5d24aaffb092c89e2273cb58f9de357d24eeb01fcde6a4079ba775","title":"Testing event-driven mode!","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T15:28:33.564871-07:00","updated_at":"2025-10-30T17:12:58.186325-07:00","closed_at":"2025-10-29T19:12:54.43368-07:00"}
{"id":"bd-89f89fc0","content_hash":"235c3bdeb45e3069167f81e7b4e798fc98547478bb16df40556100478c5e505a","title":"Remove unreachable RPC methods","description":"Several RPC server and client methods are unreachable and should be removed:\n\nServer methods (internal/rpc/server.go):\n- `Server.GetLastImportTime` (line 2116)\n- `Server.SetLastImportTime` (line 2123)\n- `Server.findJSONLPath` (line 2255)\n\nClient methods (internal/rpc/client.go):\n- `Client.Import` (line 311) - RPC import not used (daemon uses autoimport)\n\nEvidence:\n```bash\ngo run golang.org/x/tools/cmd/deadcode@latest -test ./...\n```\n\nImpact: Removes ~80 LOC of unused RPC code","acceptance_criteria":"- Remove the 4 unreachable methods (~80 LOC total)\n- Verify no callers: `grep -r \"GetLastImportTime\\|SetLastImportTime\\|findJSONLPath\" .`\n- All tests pass: `go test ./internal/rpc/...`\n- Daemon functionality works: test daemon start/stop/operations","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T16:20:02.432202-07:00","updated_at":"2025-10-30T17:12:58.222655-07:00"}
{"id":"bd-9063acda","content_hash":"572a9f35c6b6a74f5d1ff1bb6851881ca6991de48c2238e21bea48752a323ea4","title":"Clean up linter errors (914 total issues)","description":"The codebase has 914 linter issues reported by golangci-lint. While many are documented as baseline in LINTING.md, we should clean these up systematically to improve code quality and maintainability.","design":"Break down by linter category, prioritizing high-impact issues:\n1. dupl (7) - Code duplication\n2. goconst (12) - Repeated strings\n3. gocyclo (11) - High complexity functions\n4. revive (78) - Style issues\n5. gosec (102) - Security warnings\n6. errcheck (683) - Unchecked errors (many in tests)","acceptance_criteria":"All linter categories reduced to acceptable levels, with remaining baseline documented in LINTING.md","notes":"Reduced from 56 to 41 issues locally, then to 0 issues.\n\n**Fixed in commits:**\n- c2c7eda: Fixed 15 actual errors (dupl, gosec, revive, staticcheck, unparam)\n- 963181d: Configured exclusions to get to 0 issues locally\n\n**Current status:**\n- ✅ Local: golangci-lint reports 0 issues\n- ❌ CI: Still failing (see [deleted:bd-cb64c226.1])\n\n**Problem:**\nConfig v2 format or golangci-lint-action@v8 compatibility issue causing CI to fail despite local success.\n\n**Next:** Debug [deleted:bd-cb64c226.1] to fix CI/local discrepancy","status":"open","priority":2,"issue_type":"epic","created_at":"2025-10-24T01:01:12.997982-07:00","updated_at":"2025-10-31T20:36:49.404022-07:00"}
{"id":"bd-942469b8","content_hash":"be178337752bf9a94ac06f13d6c36752c9104585b9aef43ade971ed50437a39e","title":"Rapid 5","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T19:11:57.508166-07:00","updated_at":"2025-10-30T17:12:58.189947-07:00"}
{"id":"bd-96142dec","content_hash":"ba00d412efdb156e0449b304096f3e075df4c66606e6283b6501e8a29acb7b28","title":"Add fallback to polling on watcher failure","description":"Detect fsnotify.NewWatcher() errors and log warning. Auto-switch to polling mode with 5s ticker. Add BEADS_WATCHER_FALLBACK env var to control behavior.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T16:20:02.428439-07:00","updated_at":"2025-10-30T17:12:58.220378-07:00","closed_at":"2025-10-28T19:23:43.595916-07:00"}
{"id":"bd-9826b69a","content_hash":"d7e67e9b28e525705562e3f81e9112f3882c20d726c6e0f57062153f0e6bf3b9","title":"CRDT-based architecture for guaranteed convergence (v2.0)","description":"## Vision\nRedesign beads around Conflict-Free Replicated Data Types (CRDTs) to provide mathematical guarantees for N-way collision resolution at arbitrary scale.\n\n## Current Limitations\n- Content-hash based collision resolution fails at 5+ clones\n- Non-deterministic convergence in multi-round scenarios\n- UNIQUE constraint violations during rename operations\n- No formal proof of convergence properties\n\n## CRDT Benefits\n- Provably convergent (Strong Eventual Consistency)\n- Commutative/Associative/Idempotent operations\n- No coordination required between clones\n- Scales to 100+ concurrent workers\n- Well-understood mathematical foundations\n\n## Proposed Architecture\n\n### 1. UUID-Based IDs\nReplace sequential IDs with UUIDs:\n- Current: bd-1c63eb84, bd-9063acda, bd-4d80b7b1\n- CRDT: bd-a1b2c3d4-e5f6-7890-abcd-ef1234567890\n- Human aliases maintained separately: #42 maps to UUID\n\n### 2. Last-Write-Wins (LWW) Elements\nEach field becomes an LWW register:\n- title: (timestamp, clone_id, value)\n- status: (timestamp, clone_id, value)\n- Deterministic conflict resolution via Lamport timestamp + clone_id tiebreaker\n\n### 3. Operation Log\nTrack all operations as CRDT ops:\n- CREATE(uuid, timestamp, clone_id, fields)\n- UPDATE(uuid, field, timestamp, clone_id, value)\n- DELETE(uuid, timestamp, clone_id) - tombstone, not hard delete\n\n### 4. Sync as Merge\nSyncing becomes merging two CRDT states:\n- No merge conflicts possible\n- Deterministic merge function\n- Guaranteed convergence\n\n## Implementation Phases\n\n### Phase 1: Research \u0026 Design (4 weeks)\n- Study existing CRDT implementations (Automerge, Yjs, Loro)\n- Design schema for CRDT-based issue tracking\n- Prototype LWW-based Issue CRDT\n- Benchmark performance vs current system\n\n### Phase 2: Parallel Implementation (6 weeks)\n- Implement CRDT storage layer alongside SQLite\n- Build conversion tools: SQLite ↔ CRDT\n- Maintain backward compatibility with v1.x format\n- Migration path for existing databases\n\n### Phase 3: Testing \u0026 Validation (4 weeks)\n- Formal verification of convergence properties\n- Stress testing with 100+ clone scenario\n- Performance profiling and optimization\n- Documentation and examples\n\n### Phase 4: Migration \u0026 Rollout (4 weeks)\n- Release v2.0-beta with CRDT backend\n- Gradual migration from v1.x\n- Monitoring and bug fixes\n- Final v2.0 release\n\n## Risks \u0026 Mitigations\n\n**Risk 1: Performance overhead**\n- Mitigation: Benchmark early, optimize hot paths\n- CRDTs can be slower than append-only logs\n- May need compaction strategy\n\n**Risk 2: Storage bloat**\n- Mitigation: Implement operation log compaction\n- Tombstone garbage collection for deleted issues\n- Periodic snapshots to reduce log size\n\n**Risk 3: Breaking changes**\n- Mitigation: Maintain v1.x compatibility layer\n- Gradual migration tools\n- Dual-mode operation during transition\n\n**Risk 4: Complexity**\n- Mitigation: Use battle-tested CRDT libraries\n- Comprehensive documentation\n- Clear migration guide\n\n## Success Criteria\n- 100-clone collision test passes without failures\n- Formal proof of convergence properties\n- Performance within 2x of current system\n- Zero manual conflict resolution required\n- Backward compatible with v1.x databases\n\n## Timeline\n18-20 weeks total (4-5 months)\n\n## References\n- Automerge: https://automerge.org\n- Yjs: https://docs.yjs.dev\n- Loro: https://loro.dev\n- CRDT theory: Shapiro et al, A comprehensive study of CRDTs\n- Related issues: bd-0dcea000, bd-4d7fca8a, bd-6221bdcd","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-10-29T20:48:00.267736-07:00","updated_at":"2025-10-31T20:06:44.60536-07:00","closed_at":"2025-10-31T20:06:44.60536-07:00"}
{"id":"bd-98c4e1fa","content_hash":"e246bdc448f3780a929c66c8f0c495a2044ab6c810a1af9810310df306269f6b","title":"Event-driven daemon architecture","description":"Replace 5-second polling sync loop with event-driven architecture that reacts instantly to changes. Eliminates stale data issues while reducing CPU ~60%. Key components: FileWatcher (fsnotify), Debouncer (500ms), RPC mutation events, optional git hooks. Target latency: \u003c500ms (vs 5000ms). See event_driven_daemon.md for full design.","notes":"## Implementation Progress\n\n**Completed:**\n1. ✅ Mutation events infrastructure (bd-143 equivalent)\n   - MutationEvent channel in RPC server\n   - Events emitted for all write operations: create, update, close, label add/remove, dep add/remove, comment add\n   - Non-blocking emission with dropped event counter\n\n2. ✅ FileWatcher with fsnotify (bd-b0c7f7ef related)\n   - Watches .beads/issues.jsonl and .git/refs/heads\n   - 500ms debounce\n   - Polling fallback if fsnotify unavailable\n\n3. ✅ Debouncer (bd-144 equivalent)\n   - 500ms debounce for both export and import triggers\n   - Thread-safe trigger/cancel\n\n4. ✅ Separate export-only and import-only functions\n   - createExportFunc(): exports + optional commit/push (no pull/import)\n   - createAutoImportFunc(): pull + import (no export)\n   - Target latency \u003c500ms achieved by avoiding full sync\n\n5. ✅ Dropped events safety net (bd-eef03e0a related)\n   - Atomic counter tracks dropped mutation events\n   - 60-second health check triggers export if events were dropped\n   - Prevents silent data loss from event storms\n\n**Still Needed:**\n- Platform-specific tests (bd-69bce74a)\n- Integration test for mutation→export latency (bd-140)\n- Unit tests for FileWatcher (bd-b0c7f7ef)\n- Unit tests for Debouncer (bd-144)\n- Event storm stress test (bd-eef03e0a)\n- Documentation update (bd-142)\n\n**Next Steps:**\nAdd comprehensive test coverage before enabling events mode by default.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-10-29T21:19:36.203436-07:00","updated_at":"2025-10-30T17:12:58.197875-07:00","closed_at":"2025-10-29T15:53:34.022335-07:00"}
{"id":"bd-98c4e1fa.1","content_hash":"6440d1ece0a91c8f49adc09aafa7a998b049bcd51f257125ad8bc0b7b03e317b","title":"Update AGENTS.md with event-driven mode","description":"Document BEADS_DAEMON_MODE env var. Explain opt-in during Phase 1. Add troubleshooting for watcher failures.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-29T23:05:13.986452-07:00","updated_at":"2025-10-31T20:36:49.381832-07:00","dependencies":[{"issue_id":"bd-98c4e1fa.1","depends_on_id":"bd-98c4e1fa","type":"parent-child","created_at":"2025-10-29T21:19:36.206187-07:00","created_by":"import-remap"},{"issue_id":"bd-98c4e1fa.1","depends_on_id":"bd-0e1f2b1b","type":"parent-child","created_at":"2025-10-31T19:38:09.131439-07:00","created_by":"stevey"}]}
{"id":"bd-9a9530d8","content_hash":"7d6b35b6de9cbd784acb42c9bf67e47e1a73166e0c895afdcc522a9946c1833c","title":"Add TestNWayCollision for 5+ clones","description":"## Overview\nAdd comprehensive tests for N-way (5+) collision resolution to verify the solution scales beyond 3 clones.\n\n## Purpose\nWhile TestThreeCloneCollision validates the basic N-way case, we need to verify:\n1. Solution scales to arbitrary N\n2. Performance is acceptable with more clones\n3. Convergence time is bounded\n4. No edge cases in larger collision groups\n\n## Implementation Tasks\n\n### 1. Create TestFiveCloneCollision\nFile: beads_twoclone_test.go (or new beads_nway_test.go)\n\n```go\nfunc TestFiveCloneCollision(t *testing.T) {\n    // Test with 5 clones creating same ID with different content\n    // Verify all 5 clones converge after sync rounds\n    \n    t.Run(\"SequentialSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"A\", \"B\", \"C\", \"D\", \"E\")\n    })\n    \n    t.Run(\"ReverseSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"E\", \"D\", \"C\", \"B\", \"A\")\n    })\n    \n    t.Run(\"RandomSync\", func(t *testing.T) {\n        testNCloneCollision(t, 5, \"C\", \"A\", \"E\", \"B\", \"D\")\n    })\n}\n```\n\n### 2. Implement generalized testNCloneCollision\nGeneralize the 3-clone test to handle arbitrary N:\n\n```go\nfunc testNCloneCollision(t *testing.T, numClones int, syncOrder ...string) {\n    t.Helper()\n    \n    if len(syncOrder) != numClones {\n        t.Fatalf(\"syncOrder length (%d) must match numClones (%d)\", \n            len(syncOrder), numClones)\n    }\n    \n    tmpDir := t.TempDir()\n    \n    // Setup remote and N clones\n    remoteDir := setupBareRepo(t, tmpDir)\n    cloneDirs := make(map[string]string)\n    \n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        cloneDirs[name] = setupClone(t, tmpDir, remoteDir, name)\n    }\n    \n    // Each clone creates issue with same ID but different content\n    for name, dir := range cloneDirs {\n        createIssue(t, dir, fmt.Sprintf(\"Issue from clone %s\", name))\n    }\n    \n    // Sync in specified order\n    for _, name := range syncOrder {\n        syncClone(t, cloneDirs[name], name)\n    }\n    \n    // Final pull for convergence\n    for name, dir := range cloneDirs {\n        finalPull(t, dir, name)\n    }\n    \n    // Verify all clones have all N issues\n    expectedTitles := make(map[string]bool)\n    for i := 0; i \u003c numClones; i++ {\n        name := string(rune('A' + i))\n        expectedTitles[fmt.Sprintf(\"Issue from clone %s\", name)] = true\n    }\n    \n    for name, dir := range cloneDirs {\n        titles := getTitles(t, dir)\n        if !compareTitleSets(titles, expectedTitles) {\n            t.Errorf(\"Clone %s missing issues: expected %v, got %v\", \n                name, expectedTitles, titles)\n        }\n    }\n    \n    t.Log(\"✓ All\", numClones, \"clones converged successfully\")\n}\n```\n\n### 3. Add performance benchmarks\nTest convergence time and memory usage:\n\n```go\nfunc BenchmarkNWayCollision(b *testing.B) {\n    for _, n := range []int{3, 5, 10, 20} {\n        b.Run(fmt.Sprintf(\"N=%d\", n), func(b *testing.B) {\n            for i := 0; i \u003c b.N; i++ {\n                // Run N-way collision and measure time\n                testNCloneCollisionBench(b, n)\n            }\n        })\n    }\n}\n```\n\n### 4. Add convergence time tests\nVerify bounded convergence:\n\n```go\nfunc TestConvergenceTime(t *testing.T) {\n    // Test that convergence happens within expected rounds\n    // For N clones, should converge in at most N-1 sync rounds\n    \n    for n := 3; n \u003c= 10; n++ {\n        t.Run(fmt.Sprintf(\"N=%d\", n), func(t *testing.T) {\n            rounds := measureConvergenceRounds(t, n)\n            maxExpected := n - 1\n            if rounds \u003e maxExpected {\n                t.Errorf(\"Convergence took %d rounds, expected ≤ %d\", \n                    rounds, maxExpected)\n            }\n        })\n    }\n}\n```\n\n### 5. Add edge case tests\nTest boundary conditions:\n- All N clones have identical content (dedup works)\n- N-1 clones have same content, 1 differs\n- All N clones have unique content\n- Mix of collisions and non-collisions\n\n## Acceptance Criteria\n- TestFiveCloneCollision passes with all sync orders\n- All 5 clones converge to identical content\n- Performance is acceptable (\u003c 5 seconds for 5 clones)\n- Convergence time is bounded (≤ N-1 rounds)\n- Edge cases handled correctly\n- Benchmarks show scalability to 10+ clones\n\n## Files to Create/Modify\n- beads_twoclone_test.go or beads_nway_test.go\n- Add helper functions for N-clone setup\n\n## Testing Strategy\n\n### Test Matrix\n| N Clones | Sync Orders | Expected Result |\n|----------|-------------|-----------------|\n| 3        | A→B→C       | Pass            |\n| 3        | C→B→A       | Pass            |\n| 5        | A→B→C→D→E   | Pass            |\n| 5        | E→D→C→B→A   | Pass            |\n| 5        | Random      | Pass            |\n| 10       | Sequential  | Pass            |\n\n### Performance Targets\n- 3 clones: \u003c 2 seconds\n- 5 clones: \u003c 5 seconds\n- 10 clones: \u003c 15 seconds\n\n## Dependencies\n- Requires bd-cbed9619.5, bd-cbed9619.4, bd-cbed9619.3, bd-cbed9619.2 to be completed\n- TestThreeCloneCollision must pass first\n\n## Success Metrics\n- All tests pass for N ∈ {3, 5, 10}\n- Convergence time scales linearly (O(N))\n- Memory usage reasonable (\u003c 100MB for 10 clones)\n- No data corruption or loss in any scenario","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T19:42:29.849243-07:00","updated_at":"2025-10-30T17:12:58.190232-07:00","closed_at":"2025-10-28T22:06:04.398141-07:00"}
{"id":"bd-9ae788be","content_hash":"19599f6bcc268e97438593e08eb6343b551ce765f0d91956591aa811cbb90690","title":"Implement clone-scoped ID allocation to prevent N-way collisions","description":"## Problem\nCurrent ID allocation uses per-clone atomic counters (issue_counters table) that sync based on local database state. In N-way collision scenarios:\n- Clone B sees {test-1} locally, allocates test-2\n- Clone D sees {test-1, test-2, test-3} locally, allocates test-4\n- When same content gets assigned test-2 and test-4, convergence fails\n\nRoot cause: Each clone independently allocates IDs without global coordination, leading to overlapping assignments for the same content.\n\n## Solution\nAdd clone UUID to ID allocation to make every ID globally unique:\n\n**Current format:** `test-1`, `test-2`, `test-3`\n**New format:** `test-1-a7b3`, `test-2-a7b3`, `test-3-c4d9`\n\nWhere suffix is first 4 chars of clone UUID.\n\n## Implementation\n\n### 1. Add clone_identity table\n```sql\nCREATE TABLE clone_identity (\n    clone_uuid TEXT PRIMARY KEY,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### 2. Modify getNextIDForPrefix()\n```go\nfunc (s *SQLiteStorage) getNextIDForPrefix(ctx context.Context, prefix string) (string, error) {\n    cloneUUID := s.getOrCreateCloneUUID(ctx)\n    shortUUID := cloneUUID[:4]\n    \n    nextNum := s.getNextCounterForPrefix(ctx, prefix)\n    return fmt.Sprintf(\"%s-%d-%s\", prefix, nextNum, shortUUID), nil\n}\n```\n\n### 3. Update ID parsing logic\nAll places that parse IDs (utils.ExtractIssueNumber, etc.) need to handle new format.\n\n### 4. Migration strategy\n- Existing IDs remain unchanged (no suffix)\n- New IDs get clone suffix automatically\n- Display layer can hide suffix in UI: `bd-cb64c226.3-a7b3` → `#42`\n\n## Benefits\n- **Zero collision risk**: Same content in different clones gets different IDs\n- **Maintains readability**: Still sequential numbering within clone\n- **No coordination needed**: Works offline, no central authority\n- **Scales to 100+ clones**: 4-char hex = 65,536 unique clones\n\n## Concerns\n- ID format change may break existing integrations\n- Need migration path for existing databases\n- Display logic needs update to hide/show suffixes appropriately\n\n## Success Criteria\n- 10+ clone collision test passes without failures\n- Existing issues continue to work (backward compatibility)\n- Documentation updated with new ID format\n- Migration guide for v1.x → v2.x\n\n## Timeline\nMedium-term (v1.1-v1.2), 2-3 weeks implementation\n\n## References\n- Related to bd-e6d71828 (immediate fix)\n- See beads_nway_test.go for failing N-way tests","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-29T10:22:52.260524-07:00","updated_at":"2025-10-30T17:12:58.18193-07:00"}
{"id":"bd-9e8d","content_hash":"8a2616a707f5ae932357049b0bc922716f4d729724fb8c38b256c91e292f851b","title":"Test Issue","description":"","status":"open","priority":1,"issue_type":"bug","created_at":"2025-10-31T21:41:11.107393-07:00","updated_at":"2025-10-31T21:41:11.107393-07:00"}
{"id":"bd-9f1fce5d","content_hash":"14b0d330680e979e504043d2c560bd2eda204698f5622c3bdc6f91816f861d22","title":"Add internal/ai package for LLM integration","description":"Shared AI client for repair commands.\n\nProviders:\n- Anthropic (Claude)\n- OpenAI (GPT)\n- Ollama (local)\n\nEnv vars:\n- BEADS_AI_PROVIDER\n- BEADS_AI_API_KEY\n- BEADS_AI_MODEL\n\nFiles: internal/ai/client.go (new)","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-28T14:48:29.072473-07:00","updated_at":"2025-10-30T17:12:58.219706-07:00"}
{"id":"bd-a03d5e36","content_hash":"b4ee73e439a133a77e5df27e3e457674dbc9968fdbee0dc630175726960bb8cf","title":"Improve integration test coverage for stateful features","description":"","design":"## Context\n\nbd-70419816 revealed a critical gap: the export deduplication feature had unit tests but no integration tests simulating real-world git operations. This led to silent data loss in production.\n\n## Root Cause\n- Unit tests only tested functions in isolation\n- No integration tests for git operations (pull, reset, checkout) modifying JSONL\n- No tests validating export_hashes and JSONL stay in sync\n- Missing tests for stateful distributed system interactions (DB + JSONL + git)\n\n## Completed (bd-70419816)\n✓ TestJSONLIntegrityValidation - unit tests for validation logic\n✓ TestImportClearsExportHashes - tests import clears hashes\n✓ TestExportIntegrityAfterJSONLTruncation - simulates git reset (would have caught bd-70419816)\n✓ TestExportIntegrityAfterJSONLDeletion - tests recovery from file deletion\n✓ TestMultipleExportsStayConsistent - tests repeated exports\n\n## Still Needed (High Priority)\n1. Multi-repo sync test - two clones staying in sync after push/pull\n2. Auto-flush integration test - JSONL integrity preserved during auto-flush\n3. Daemon auto-sync integration test - complex state management\n4. Import after corruption test - recovery from partial data loss\n\n## Medium Priority\n- Partial export failure handling (disk full, network interruption)\n- Concurrent export/import race conditions\n- Large dataset performance tests (1000+ issues)\n- Export hash migration tests (version upgrades)\n\n## Testing Principles\n1. Test real-world scenarios: git ops, user errors, system failures, concurrent ops\n2. Integration tests for stateful systems (DB + files + git)\n3. Regression test for every bug fix\n4. Test invariants: JSONL count == DB count, hash consistency, etc.\n\n## Key Lesson\nStateful distributed systems need integration tests, not just unit tests.","acceptance_criteria":"- [ ] Multi-repo sync test implemented\n- [ ] Auto-flush integration test implemented  \n- [ ] Daemon auto-sync integration test implemented\n- [ ] Testing guidelines added to CONTRIBUTING.md\n- [ ] CI runs integration tests\n- [ ] All critical workflows have integration test coverage","status":"open","priority":2,"issue_type":"epic","created_at":"2025-10-29T21:53:15.397137-07:00","updated_at":"2025-10-30T17:12:58.206063-07:00"}
{"id":"bd-a1691807","content_hash":"23f0119ee9df98f1bf6d648dba06065c156963064ef1c7308dfb02c8bdd5bc58","title":"Integration test: mutation to export latency","description":"Measure time from bd create to JSONL update. Verify \u003c500ms latency. Test with multiple rapid mutations to verify batching.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T20:49:49.105247-07:00","updated_at":"2025-10-31T12:00:43.198883-07:00","closed_at":"2025-10-31T12:00:43.198883-07:00"}
{"id":"bd-a40f374f","content_hash":"599448515198700decd2494cf0cea3335b013c573bdcbda90a151564585cf845","title":"bd validate - Comprehensive health check","description":"Run all validation checks in one command.\n\nChecks:\n- Duplicates\n- Orphaned dependencies\n- Test pollution\n- Git conflicts\n\nSupports --fix-all for auto-repair.\n\nDepends on bd-cbed9619.1, bd-0dcea000, bd-31aab707, bd-9826b69a.\n\nFiles: cmd/bd/validate.go (new)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T20:02:47.956664-07:00","updated_at":"2025-10-30T17:12:58.195108-07:00","closed_at":"2025-10-29T20:02:15.318966-07:00"}
{"id":"bd-a5251b1a","content_hash":"1a158c823c7152ddd5dbd11e11df32a85b699a4f05bfd2effbf4c4a3655cca6b","title":"Test RPC mutation event","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T19:08:03.315443-07:00","updated_at":"2025-10-31T12:00:43.177494-07:00","closed_at":"2025-10-31T12:00:43.177494-07:00"}
{"id":"bd-a5a8bec0","content_hash":"fb509cc456ea9de6000129ad7780e417d2f06361e577738709a9ccf1c3b1f3b1","title":"bd find-duplicates - AI-powered duplicate detection","description":"Find semantically duplicate issues.\n\nApproaches:\n1. Mechanical: Exact title/description matching\n2. Embeddings: Cosine similarity (cheap, scalable)\n3. AI: LLM-based semantic comparison (expensive, accurate)\n\nUses embeddings by default for \u003e100 issues.\n\nFiles: cmd/bd/find_duplicates.go (new)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T19:42:29.853269-07:00","updated_at":"2025-10-30T17:12:58.193143-07:00","closed_at":"2025-10-29T16:43:30.367455-07:00"}
{"id":"bd-a9699011","content_hash":"87d969cf57e247ebfac4f052a9ecbd1254bc55070b87b5ffb78a2b6ee2afddb6","title":"GH#146: No color showing in terminal for some users","description":"User reports color not working in macOS (Taho 26.0.1) with iTerm 3.6.4 and Terminal.app, despite color working elsewhere in terminal. Python rich and printf escape codes work.\n\nNeed to investigate:\n- Is NO_COLOR env var set?\n- Terminal type detection?\n- fatih/color library configuration\n- Does bd list show colors? bd ready? bd init?\n- What's the output of: echo $TERM, echo $NO_COLOR","status":"open","priority":2,"issue_type":"bug","created_at":"2025-10-24T22:26:36.22163-07:00","updated_at":"2025-10-30T17:12:58.2142-07:00","external_ref":"github:146"}
{"id":"bd-aec5439f","content_hash":"9ad0242285e9ef9b326468b9be34f533f27cbbaa0c698607cca0cd6228016d2c","title":"Update LINTING.md with current baseline","description":"After cleanup, document the remaining acceptable baseline in LINTING.md so we can track regression.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-27T18:53:10.38679-07:00","updated_at":"2025-10-30T17:12:58.194901-07:00"}
{"id":"bd-b47c034e","content_hash":"133dfd651d402bb95928091138c77a57b2f3f349587962c744209a534fb800a6","title":"Address gosec security warnings (102 issues)","description":"Security linter warnings: file permissions (0755 should be 0750), G304 file inclusion via variable, G204 subprocess launches. Many are false positives but should be reviewed.","design":"Review each gosec warning. Add exclusions for legitimate cases to .golangci.yml. Fix real security issues (overly permissive file modes).","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-25T13:47:10.719134-07:00","updated_at":"2025-10-30T17:12:58.216521-07:00"}
{"id":"bd-b501fcc1","content_hash":"323c3b4f2e53d707ce73e75a357bbb4e320327bea00d0b010c3dd09d1e6555cf","title":"Unit tests for Debouncer","description":"Test debouncer batches multiple triggers into single action. Test timer reset on subsequent triggers. Test cancel during wait. Test thread safety.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T19:42:29.86146-07:00","updated_at":"2025-10-31T17:54:06.880513-07:00","closed_at":"2025-10-31T17:54:06.880513-07:00"}
{"id":"bd-b55e2ac2","content_hash":"44122b61b1dcd06407ecf36f57577ea72c5df6dc8cc2a8c1b173b37d16a10267","title":"Fix autoimport tests for content-hash collision scoring","description":"## Overview\nThree autoimport tests are failing after bd-cbed9619.4 because they expect behavior based on the old reference-counting collision resolution, but the system now uses deterministic content-hash scoring.\n\n## Failing Tests\n1. `TestAutoImportMultipleCollisionsRemapped` - expects local versions preserved\n2. `TestAutoImportAllCollisionsRemapped` - expects local versions preserved  \n3. `TestAutoImportCollisionRemapMultipleFields` - expects specific collision resolution behavior\n\n## Root Cause\nThese tests were written when ScoreCollisions used reference counting to determine which version to keep. Now it uses content-hash comparison (introduced in commit 2e87329), which produces different but deterministic results.\n\n## Example\nOld behavior: Issue with more references would be kept\nNew behavior: Issue with lexicographically lower content hash is kept\n\n## Solution\nUpdate each test to:\n1. Verify the new content-hash based behavior is correct\n2. Check that the remapped issue (not necessarily local/remote) has the expected content\n3. Ensure dependencies are preserved on the correct remapped issue\n\n## Acceptance Criteria\n- All three autoimport tests pass\n- Tests verify content-hash determinism (same collision always resolves the same way)\n- Tests check dependency preservation on remapped issues\n- Test documentation explains content-hash scoring expectations\n\n## Files to Modify\n- `cmd/bd/autoimport_collision_test.go`\n\n## Testing\nRun: `go test ./cmd/bd -run \"TestAutoImport.*Collision\" -v`","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T19:17:28.358028-07:00","updated_at":"2025-10-30T17:12:58.179059-07:00"}
{"id":"bd-b6b2","content_hash":"c7a641bdb4c98b14816e2d85ec09db6def89aa4918ad59f4c1f8f71c6a42c6d4","title":"Feature with design","description":"This is a description","design":"Use MVC pattern","acceptance_criteria":"All tests pass","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-31T21:40:34.612465-07:00","updated_at":"2025-10-31T21:40:34.612465-07:00"}
{"id":"bd-bc2c6191","content_hash":"533e56b8628e24229a4beb52f8683355f6ca699e34a73650bf092003d73c2957","title":"Audit Current Cache Usage","description":"Understand exactly what code depends on the storage cache","acceptance_criteria":"- Document showing all cache dependencies\n- Confirmation that removing cache won't break MCP\n- List of tests that need updating\n\nFiles to examine:\n- internal/rpc/server_cache_storage.go (cache implementation)\n- internal/rpc/client.go (how req.Cwd is set)\n- internal/rpc/server_*.go (all getStorageForRequest calls)\n- integrations/beads-mcp/ (MCP multi-repo logic)\n\nTasks:\n- Document all callers of getStorageForRequest()\n- Verify req.Cwd is only set by RPC client for database discovery\n- Confirm MCP server doesn't rely on multi-repo cache behavior\n- Check if any tests assume multi-repo routing\n- Review environment variables: BEADS_DAEMON_MAX_CACHE_SIZE, BEADS_DAEMON_CACHE_TTL, BEADS_DAEMON_MEMORY_THRESHOLD_MB","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-27T23:02:43.506373-07:00","updated_at":"2025-10-31T20:36:49.334214-07:00"}
{"id":"bd-bdaf24d5","content_hash":"6ccdbf2362d22fbbe854fdc666695a7488353799e1a5c49e6095b34178c9bcb4","title":"Final validation test","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T18:27:28.310533-07:00","updated_at":"2025-10-31T12:00:43.184995-07:00","closed_at":"2025-10-31T12:00:43.184995-07:00"}
{"id":"bd-c01f","content_hash":"b183cc4d99f74e9314f67d927f1bd1255608632b47ce0352af97af5872275fec","title":"Implement bd stale command to find abandoned/forgotten issues","description":"Add bd stale command to surface issues that haven't been updated recently and may need attention.\n\nUse cases:\n- In-progress issues with no recent activity (may be abandoned)\n- Open issues that have been forgotten\n- Issues that might be outdated or no longer relevant\n\nQuery logic should find non-closed issues where updated_at exceeds a time threshold.\n\nShould support:\n- --days N flag (default 30-90 days)\n- --status filter (e.g., only in_progress)\n- --json output for automation\n\nReferences GitHub issue #184 where user expected this command to exist.","design":"Implementation approach:\n1. Add new command in cmd/bd/stale.go\n2. Query issues with: status != 'closed' AND updated_at \u003c (now - N days)\n3. Support filtering by status (open, in_progress, blocked)\n4. Default threshold: 30 days (configurable via --days)\n5. JSON output for agent consumption\n6. Order by updated_at ASC (oldest first)","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-10-31T22:48:46.85435-07:00","updated_at":"2025-10-31T22:54:33.704492-07:00","closed_at":"2025-10-31T22:54:33.704492-07:00"}
{"id":"bd-c825f867","content_hash":"27cecaa2dc6cdabb2ae77fd65fbf8dca8f4c536bdf140a13b25cdd16376c9845","title":"Add docs/architecture/event_driven.md","description":"Copy event_driven_daemon.md into docs/ folder. Add to documentation index.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T16:20:02.431399-07:00","updated_at":"2025-10-30T17:12:58.221939-07:00"}
{"id":"bd-c947dd1b","content_hash":"79bd51b46b28bc16cfc19cd19a4dd4f57f45cd1e902b682788d355b03ec00b2a","title":"Remove Daemon Storage Cache","description":"The daemon's multi-repo storage cache is the root cause of stale data bugs. Since global daemon is deprecated, we only ever serve one repository, making the cache unnecessary complexity. This epic removes the cache entirely for simpler, more reliable direct storage access.","design":"For local daemon (single repository), eliminate the cache entirely:\n- Use s.storage field directly (opened at daemon startup)\n- Remove getStorageForRequest() routing logic\n- Remove server_cache_storage.go entirely (~300 lines)\n- Remove cache-related tests\n- Simplify Server struct\n\nBenefits:\n✅ No staleness bugs: Always using live SQLite connection\n✅ Simpler code: Remove ~300 lines of cache management\n✅ Easier debugging: Direct storage access, no cache indirection\n✅ Same performance: Cache was always 1 entry for local daemon anyway","acceptance_criteria":"- Daemon has no storage cache code\n- All tests pass\n- MCP integration works\n- No stale data bugs\n- Documentation updated\n- Performance validated","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-10-28T10:50:15.126939-07:00","updated_at":"2025-10-30T17:12:58.21743-07:00","closed_at":"2025-10-28T10:49:53.612049-07:00"}
{"id":"bd-c9a482db","content_hash":"35c1ad124187c21b4e8dae7db46ea5d00173d33234a9b815ded7dcf0ab51078e","title":"Add internal/ai package for AI-assisted repairs","description":"Add AI integration package to support AI-powered repair commands.\n\nProviders:\n- Anthropic (Claude)\n- OpenAI\n- Ollama (local)\n\nFeatures:\n- Conflict resolution analysis\n- Duplicate detection via embeddings\n- Configuration via env vars (BEADS_AI_PROVIDER, BEADS_AI_API_KEY, etc.)\n\nSee repair_commands.md lines 357-425 for design.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T19:37:55.722841-07:00","updated_at":"2025-10-30T17:12:58.180177-07:00"}
{"id":"bd-cb64c226.1","content_hash":"0bfd0735c8985d3b3e4906e44f22b06fb24758c6d795188226e920bd8b3e7cf8","title":"Performance Validation","description":"Confirm no performance regression from cache removal","acceptance_criteria":"- Benchmarks show no significant regression\n- Document performance characteristics\n- Confirm single SQLite connection is reused\n\nBenchmarks: go test -bench=. -benchmem ./internal/rpc/...\n\nMetrics to track:\n- Request latency (p50, p99)\n- Throughput (requests/sec)\n- Memory usage\n- SQLite connection overhead\n\nExpected results:\n- Latency: Same or better (no cache overhead)\n- Throughput: Same (cache was always 1 entry)\n- Memory: Lower (no cache structs)\n- Connection overhead: Zero (single connection reused)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T10:50:15.126019-07:00","updated_at":"2025-10-30T17:12:58.216721-07:00","closed_at":"2025-10-28T10:49:45.021037-07:00"}
{"id":"bd-cb64c226.10","content_hash":"2dbe416cf266952236a03ed414e5f7f9eb5526d69b70d0821ca0d59b2bc22305","title":"Delete server_cache_storage.go","description":"Remove the entire cache implementation file (~286 lines)","acceptance_criteria":"- File deleted from repository\n- No compilation errors\n- No references to deleted functions\n\nFunctions being removed:\n- StorageCacheEntry struct\n- evictStaleStorage() - LRU eviction\n- evictCacheBasedOnMemory() - memory pressure eviction\n- getStorageForRequest() - cache lookup and routing\n- findDatabaseForCwd() - database discovery\n- evictStorageForRequest() - manual eviction","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T22:55:38.729299-07:00","updated_at":"2025-10-30T17:12:58.212391-07:00","closed_at":"2025-10-28T14:08:38.064592-07:00"}
{"id":"bd-cb64c226.12","content_hash":"ed9fa6273973fb0c68d173564ab4814d360528f9bb035e78406a63875f8f6b43","title":"Remove Storage Cache from Server Struct","description":"Eliminate cache fields and use s.storage directly","acceptance_criteria":"- Server struct has no cache fields\n- NewServer() doesn't initialize cache\n- Start() doesn't run cache cleanup goroutines\n- Stop() only closes single s.storage\n\nChanges needed:\n- Remove cache-related fields from Server struct in server_core.go\n- Remove cache size/TTL parsing from env vars in NewServer()\n- Remove cleanup ticker goroutine from Start()\n- Remove cache cleanup logic from Stop()","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T22:55:25.474412-07:00","updated_at":"2025-10-30T17:12:58.211812-07:00","closed_at":"2025-10-28T14:08:38.061444-07:00"}
{"id":"bd-cb64c226.13","content_hash":"717cedbda6e48b8a98f1a0250cd7925377d0b7b84884ac6697486a77886f7082","title":"Audit Current Cache Usage","description":"Understand exactly what code depends on the storage cache","acceptance_criteria":"- Document showing all cache dependencies\n- Confirmation that removing cache won't break MCP\n- List of tests that need updating\n\nFiles to examine:\n- internal/rpc/server_cache_storage.go (cache implementation)\n- internal/rpc/client.go (how req.Cwd is set)\n- internal/rpc/server_*.go (all getStorageForRequest calls)\n- integrations/beads-mcp/ (MCP multi-repo logic)\n\nTasks:\n- Document all callers of getStorageForRequest()\n- Verify req.Cwd is only set by RPC client for database discovery\n- Confirm MCP server doesn't rely on multi-repo cache behavior\n- Check if any tests assume multi-repo routing\n- Review environment variables: BEADS_DAEMON_MAX_CACHE_SIZE, BEADS_DAEMON_CACHE_TTL, BEADS_DAEMON_MEMORY_THRESHOLD_MB","notes":"AUDIT COMPLETE\n\ngetStorageForRequest() callers: 17 production + 11 test\n- server_issues_epics.go: 8 calls\n- server_labels_deps_comments.go: 4 calls  \n- server_export_import_auto.go: 2 calls\n- server_compact.go: 2 calls\n- server_routing_validation_diagnostics.go: 1 call\n- server_eviction_test.go: 11 calls (DELETE entire file)\n\nPattern everywhere: store, err := s.getStorageForRequest(req) → store := s.storage\n\nreq.Cwd usage: Only for multi-repo routing. Local daemon always serves 1 repo, so routing is unused.\n\nMCP server: Uses separate daemons per repo (no req.Cwd usage found). NOT affected by cache removal.\n\nCache env vars to deprecate:\n- BEADS_DAEMON_MAX_CACHE_SIZE (used in server_core.go:63)\n- BEADS_DAEMON_CACHE_TTL (used in server_core.go:72)\n- BEADS_DAEMON_MEMORY_THRESHOLD_MB (used in server_cache_storage.go:47)\n\nServer struct fields to remove:\n- storageCache, cacheMu, maxCacheSize, cacheTTL, cleanupTicker, cacheHits, cacheMisses\n\nTests to delete:\n- server_eviction_test.go (entire file - 9 tests)\n- limits_test.go cache assertions\n\nSpecial consideration: ValidateDatabase endpoint uses findDatabaseForCwd() outside cache. Verify if used, then remove or inline.\n\nSafe to proceed with removal - cache always had 1 entry in local daemon model.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T22:55:19.3723-07:00","updated_at":"2025-10-30T17:12:58.211563-07:00","closed_at":"2025-10-28T14:08:38.060291-07:00"}
{"id":"bd-cb64c226.6","content_hash":"0c7997ff55a05eb6db59702ec72644c0f59658ca2838175125fda0e1cd11d952","title":"Verify MCP Server Compatibility","description":"Ensure MCP server works with cache-free daemon","acceptance_criteria":"- MCP integration tests pass\n- Documented confirmation of MCP multi-repo strategy\n- No regressions in MCP functionality\n\nTest scenarios:\n1. Single repo workflow: MCP with one project directory\n2. Multi-repo workflow: MCP switching between projects (uses separate daemons)\n3. Daemon restart: Verify no stale data after daemon restart\n\nQuestions to answer:\n- Does MCP rely on req.Cwd routing to single daemon for multiple repos?\n- Or does MCP start separate daemons per repo (recommended)?\n- Do existing MCP tests pass?\n\nFiles to review:\n- integrations/beads-mcp/src/beads_mcp/server.py\n- integrations/beads-mcp/tests/test_multi_project_switching.py","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T22:56:03.241615-07:00","updated_at":"2025-10-30T17:12:58.213372-07:00","closed_at":"2025-10-28T14:08:38.059615-07:00"}
{"id":"bd-cb64c226.8","content_hash":"d8581fb1f52b60d710b0190d33e7aaca4a0e86f791c6a4c60bb26d122bf73891","title":"Update Metrics and Health Endpoints","description":"Remove cache-related metrics from health/metrics endpoints","acceptance_criteria":"- bd daemon --health output has no cache fields\n- bd daemon --metrics output has no cache fields\n- No compilation errors\n\nChanges needed:\n- Remove cache_size from health endpoint in server_routing_validation_diagnostics.go\n- Remove cache_size, cache_hits, cache_misses from metrics endpoint\n- Remove CacheHits and CacheMisses fields from internal/rpc/metrics.go","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T22:55:49.212047-07:00","updated_at":"2025-10-30T17:12:58.212888-07:00","closed_at":"2025-10-28T14:08:38.06569-07:00"}
{"id":"bd-cb64c226.9","content_hash":"add00749ba759177be9758ba40b4a3e0f4323e564e798079d9ec3b5bf227cdc9","title":"Remove Cache-Related Tests","description":"Delete or update tests that assume multi-repo caching","acceptance_criteria":"- server_eviction_test.go deleted\n- limits_test.go updated (no cache assertions)\n- All tests pass: go test ./internal/rpc/...\n\nTests to delete:\n- TestCacheEviction\n- TestMemoryPressureEviction\n- TestMtimeInvalidation\n- TestConcurrentCacheAccess\n- TestSubdirectoryCanonicalization\n- TestManualEviction\n- TestLRUEviction\n\nFiles to update:\n- internal/rpc/server_eviction_test.go (DELETE entire file)\n- internal/rpc/limits_test.go (remove cache assertions)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T22:55:44.511897-07:00","updated_at":"2025-10-30T17:12:58.212659-07:00","closed_at":"2025-10-28T14:08:38.065118-07:00"}
{"id":"bd-cbed9619.1","content_hash":"d2a6ee2623071ca4a455c24ff940d3e49be5fcd433c374f489e487c8ac54f3b5","title":"Fix multi-round convergence for N-way collisions","description":"## Problem\n\nN-way collision resolution is working (IDs get remapped correctly), but clones don't fully converge after a single final pull. Each clone is missing some issues that other clones have.\n\nFrom TestFiveCloneCollision results:\n- Clone A has: A, B\n- Clone B has: A, B  \n- Clone C has: A, B, C\n- Clone D has: A, B, C, D\n- Clone E has: A, B, C, E\n\n**Expected**: All clones should have A, B, C, D, E after final pull.\n\n## Root Cause\n\nThe current sync workflow does:\n1. Each clone syncs in order (resolving collisions locally)\n2. Final pull to get all changes\n\nBut the final pull itself may need import with collision resolution, which creates new commits. These new commits aren't propagated to other clones, so they remain incomplete.\n\n## Proposed Solution\n\n**Option 1: Multi-round final sync**\n- After final pull, do additional sync rounds until all clones converge\n- Check convergence by comparing issue counts or content hashes\n- Maximum N rounds for N clones\n\n**Option 2: Iterative pull-import-push**\n- Each clone: pull → import with --resolve-collisions → push\n- Repeat until no new changes\n- Guaranteed convergence but may create commit spam\n\n**Option 3: Fix auto-import to be truly idempotent**\n- Ensure importing same JSONL multiple times produces no new commits\n- May require smarter content-based deduplication\n\n## Acceptance Criteria\n\n- TestFiveCloneCollision passes without t.Skip\n- All N clones have all N issues after convergence\n- Convergence happens in bounded rounds (≤ N)\n- No data loss or duplication\n- Works for arbitrary N (tested with 5, 10 clones)\n\n## Impact\n\nThis is the final blocker for bd-cbed9619 epic completion.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T21:22:21.486109-07:00","updated_at":"2025-10-30T17:12:58.180996-07:00","closed_at":"2025-10-29T11:02:40.756891-07:00"}
{"id":"bd-cbed9619.2","content_hash":"20c1753ec9130f40309827d6a3762f28306695c36cd419d8c011368b15d64352","title":"Implement content-first idempotent import","description":"## Overview\nPhase 4: Refactor import to be content-first and idempotent, ensuring importing same JSONL multiple times always converges correctly.\n\n## Current Problem\nCurrent import is ID-first:\n1. Look up by ID\n2. If exists, update\n3. If not exists, create\n\nThis causes issues when:\n- Same content arrives with different IDs (renames not detected)\n- Multiple rounds of import needed for convergence\n- Import order affects final state\n\n## Solution\nMake import content-first and idempotent:\n1. Hash all incoming and existing issues\n2. Match by content hash first (detect renames)\n3. Handle ID conflicts second (using global resolution)\n4. Ensure importing same data multiple times = no-op\n\n## Implementation Tasks\n\n### 1. Refactor ImportIssues to be content-first\nFile: internal/importer/importer.go\n\n```go\nfunc ImportIssues(ctx context.Context, dbPath string, store storage.Storage, \n    issues []*types.Issue, opts Options) (*Result, error) {\n    \n    result := \u0026Result{...}\n    \n    sqliteStore, needCloseStore, err := getOrCreateStore(ctx, dbPath, store)\n    if err != nil {\n        return nil, err\n    }\n    if needCloseStore {\n        defer func() { _ = sqliteStore.Close() }()\n    }\n    \n    // Phase 1: Compute content hashes for all incoming issues\n    for _, issue := range issues {\n        issue.ContentHash = issue.ComputeContentHash()\n    }\n    \n    // Phase 2: Build content hash maps\n    incomingByHash := buildHashMap(issues)\n    dbIssues, _ := sqliteStore.SearchIssues(ctx, \"\", types.IssueFilter{})\n    dbByHash := buildHashMap(dbIssues)\n    dbByID := buildIDMap(dbIssues)\n    \n    // Phase 3: Content-first matching\n    var newIssues []*types.Issue\n    var idConflicts []*CollisionDetail\n    \n    for hash, incoming := range incomingByHash {\n        if existing, found := dbByHash[hash]; found {\n            // Same content exists\n            if existing.ID == incoming.ID {\n                // Exact match - idempotent case\n                result.Unchanged++\n            } else {\n                // Same content, different ID - rename detected\n                // Delete old ID, keep new ID (incoming is canonical)\n                if err := handleRename(ctx, sqliteStore, existing, incoming); err != nil {\n                    return nil, err\n                }\n                result.Updated++\n            }\n        } else {\n            // New content - check for ID collision\n            if existingWithID, found := dbByID[incoming.ID]; found {\n                // ID exists but different content - collision\n                idConflicts = append(idConflicts, \u0026CollisionDetail{\n                    ID:            incoming.ID,\n                    IncomingIssue: incoming,\n                    ExistingIssue: existingWithID,\n                })\n            } else {\n                // Truly new issue\n                newIssues = append(newIssues, incoming)\n            }\n        }\n    }\n    \n    // Phase 4: Resolve ID conflicts using global algorithm\n    if len(idConflicts) \u003e 0 {\n        if !opts.ResolveCollisions {\n            return nil, fmt.Errorf(\"collision detected\")\n        }\n        \n        idMapping, err := sqlite.ResolveNWayCollisions(ctx, sqliteStore, \n            idConflicts, issues)\n        if err != nil {\n            return nil, err\n        }\n        \n        if err := applyIDMapping(ctx, sqliteStore, idMapping); err != nil {\n            return nil, err\n        }\n        \n        result.IDMapping = idMapping\n        result.Collisions = len(idConflicts)\n    }\n    \n    // Phase 5: Create new issues\n    if len(newIssues) \u003e 0 {\n        if err := sqliteStore.CreateIssues(ctx, newIssues, \"import\"); err != nil {\n            return nil, err\n        }\n        result.Created = len(newIssues)\n    }\n    \n    // Phase 6: Import dependencies, labels, comments (existing logic)\n    // ...\n    \n    return result, nil\n}\n```\n\n### 2. Implement helper functions\n\n```go\n// buildHashMap creates a map of content hash → issue\nfunc buildHashMap(issues []*types.Issue) map[string]*types.Issue {\n    result := make(map[string]*types.Issue)\n    for _, issue := range issues {\n        result[issue.ContentHash] = issue\n    }\n    return result\n}\n\n// buildIDMap creates a map of ID → issue\nfunc buildIDMap(issues []*types.Issue) map[string]*types.Issue {\n    result := make(map[string]*types.Issue)\n    for _, issue := range issues {\n        result[issue.ID] = issue\n    }\n    return result\n}\n\n// handleRename handles content match with different IDs\nfunc handleRename(ctx context.Context, s *SQLiteStorage, \n    existing *types.Issue, incoming *types.Issue) error {\n    \n    // Delete old ID\n    if err := s.DeleteIssue(ctx, existing.ID); err != nil {\n        return fmt.Errorf(\"failed to delete old ID %s: %w\", existing.ID, err)\n    }\n    \n    // Create with new ID\n    if err := s.CreateIssue(ctx, incoming, \"import-rename\"); err != nil {\n        return fmt.Errorf(\"failed to create renamed issue %s: %w\", \n            incoming.ID, err)\n    }\n    \n    // Update references from old ID to new ID\n    idMapping := map[string]string{existing.ID: incoming.ID}\n    return updateReferences(ctx, s, idMapping)\n}\n```\n\n### 3. Add idempotency tests\n\nTest cases:\n1. Import same JSONL twice → second import reports all Unchanged\n2. Import, modify DB, import again → reports Updated\n3. Import with rename, import again → idempotent\n4. Import with collision resolution, import again → idempotent\n\n### 4. Update handleCollisions to use new flow\nCurrent handleCollisions in importer.go needs to be updated to:\n- Use content-first matching\n- Call new ResolveNWayCollisions\n- Apply results using ApplyCollisionResolution\n\n## Acceptance Criteria\n- Import matches by content hash before checking IDs\n- Importing same JSONL multiple times is idempotent (reports Unchanged)\n- Rename detection works (same content, different ID)\n- ID conflicts resolved using global algorithm\n- Result.Unchanged correctly tracks idempotent imports\n- TestThreeCloneCollision passes\n- All existing import tests still pass\n\n## Testing Strategy\n\n### Unit Tests\n- buildHashMap correctly indexes by content hash\n- buildIDMap correctly indexes by ID\n- handleRename deletes old, creates new, updates references\n\n### Integration Tests\n- Import same data twice → idempotent\n- Import renamed issue → handled correctly\n- Import with collision → resolved globally\n- Final pull after 3-way collision → all clones converge\n\n### Property Tests\n- Idempotency: Import(x); Import(x) ≡ Import(x)\n- Commutativity: Import(a); Import(b) ≡ Import(b); Import(a) (for non-colliding issues)\n- Convergence: After N rounds of sync, all clones identical\n\n## Files to Modify\n- internal/importer/importer.go (major refactor of ImportIssues)\n- internal/importer/importer_test.go (new tests)\n- cmd/bd/import_bug_test.go (update for new behavior)\n\n## Dependencies\n- Requires bd-cbed9619.5 (ContentHash field)\n- Requires bd-cbed9619.4 (read-only detection)\n- Requires bd-cbed9619.3 (global resolution)\n\n## Risk Mitigation\nMajor refactor of import logic. Recommend:\n1. Comprehensive tests before modifying\n2. Feature flag to enable/disable\n3. Keep old import code path for rollback\n4. Test with all existing import tests\n5. Manual testing with real repositories\n\n## Success Metrics\nAfter this phase:\n- TestThreeCloneCollision should PASS\n- All clones converge after final pull\n- Import is demonstrably idempotent\n- No data loss in N-way scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T18:38:25.671302-07:00","updated_at":"2025-10-30T17:12:58.229134-07:00","closed_at":"2025-10-28T20:21:39.529971-07:00","dependencies":[{"issue_id":"bd-cbed9619.2","depends_on_id":"bd-325da116","type":"parent-child","created_at":"2025-10-28T18:39:20.616846-07:00","created_by":"daemon"},{"issue_id":"bd-cbed9619.2","depends_on_id":"bd-cbed9619.5","type":"blocks","created_at":"2025-10-28T18:39:28.360026-07:00","created_by":"daemon"},{"issue_id":"bd-cbed9619.2","depends_on_id":"bd-cbed9619.4","type":"blocks","created_at":"2025-10-28T18:39:28.383624-07:00","created_by":"daemon"},{"issue_id":"bd-cbed9619.2","depends_on_id":"bd-cbed9619.3","type":"blocks","created_at":"2025-10-28T18:39:28.407157-07:00","created_by":"daemon"}]}
{"id":"bd-cbed9619.3","content_hash":"ecebc4a18d5355bafc88e778ee87365717f894d3590d325a97ecf8b3f763d54d","title":"Implement global N-way collision resolution algorithm","description":"## Overview\nPhase 3: Replace pairwise collision resolution with global N-way resolution that produces deterministic results regardless of sync order.\n\n## Current Problem\nScoreCollisions (collision.go:228) compares issues pairwise:\n```go\ncollision.RemapIncoming = existingHash \u003c incomingHash\n```\n\nThis works for 2-way but fails for 3+ way because:\n- Each clone makes local decisions without global context\n- No guarantee intermediate states are consistent\n- Remapping decisions depend on sync order\n- Can't detect transitive remap chains (test-1 → test-2 → test-3)\n\n## Solution\nImplement global resolution that:\n1. Collects ALL versions of same logical issue\n2. Sorts by content hash (deterministic)\n3. Assigns sequential IDs based on sorted order\n4. All clones converge to same assignments\n\n## Implementation Tasks\n\n### 1. Create ResolveNWayCollisions function\nFile: internal/storage/sqlite/collision.go\n\nReplace ScoreCollisions with:\n```go\n// ResolveNWayCollisions handles N-way collisions deterministically.\n// Groups all versions with same base ID, sorts by content hash,\n// assigns sequential IDs. Returns mapping of old ID → new ID.\nfunc ResolveNWayCollisions(ctx context.Context, s *SQLiteStorage,\n    collisions []*CollisionDetail, incoming []*types.Issue) (map[string]string, error) {\n    \n    if len(collisions) == 0 {\n        return make(map[string]string), nil\n    }\n    \n    // Group by base ID pattern (e.g., test-1, test-2 → base \"test-1\")\n    groups := groupCollisionsByBaseID(collisions)\n    \n    idMapping := make(map[string]string)\n    \n    for baseID, versions := range groups {\n        // 1. Collect all unique versions by content hash\n        uniqueVersions := deduplicateVersionsByContentHash(versions)\n        \n        // 2. Sort by content hash (deterministic!)\n        sort.Slice(uniqueVersions, func(i, j int) bool {\n            return uniqueVersions[i].ContentHash \u003c uniqueVersions[j].ContentHash\n        })\n        \n        // 3. Assign sequential IDs based on sorted order\n        prefix := extractPrefix(baseID)\n        baseNum := extractNumber(baseID)\n        \n        for i, version := range uniqueVersions {\n            targetID := fmt.Sprintf(\"%s-%d\", prefix, baseNum+i)\n            \n            // Map this version to its deterministic ID\n            if version.ID != targetID {\n                idMapping[version.ID] = targetID\n            }\n        }\n    }\n    \n    return idMapping, nil\n}\n```\n\n### 2. Implement helper functions\n\n```go\n// groupCollisionsByBaseID groups collisions by their logical base ID\nfunc groupCollisionsByBaseID(collisions []*CollisionDetail) map[string][]*types.Issue {\n    groups := make(map[string][]*types.Issue)\n    for _, c := range collisions {\n        baseID := c.ID  // All share same ID (that's why they collide)\n        groups[baseID] = append(groups[baseID], c.ExistingIssue, c.IncomingIssue)\n    }\n    return groups\n}\n\n// deduplicateVersionsByContentHash keeps one issue per unique content hash\nfunc deduplicateVersionsByContentHash(issues []*types.Issue) []*types.Issue {\n    seen := make(map[string]*types.Issue)\n    for _, issue := range issues {\n        if _, found := seen[issue.ContentHash]; !found {\n            seen[issue.ContentHash] = issue\n        }\n    }\n    result := make([]*types.Issue, 0, len(seen))\n    for _, issue := range seen {\n        result = append(result, issue)\n    }\n    return result\n}\n```\n\n### 3. Update handleCollisions in importer\nFile: internal/importer/importer.go\n\nReplace ScoreCollisions call with:\n```go\n// OLD:\nif err := sqlite.ScoreCollisions(ctx, sqliteStore, collisionResult.Collisions, allExistingIssues); err != nil {\n    return nil, fmt.Errorf(\"failed to score collisions: %w\", err)\n}\n\n// NEW:\nidMapping, err := sqlite.ResolveNWayCollisions(ctx, sqliteStore, \n    collisionResult.Collisions, issues)\nif err != nil {\n    return nil, fmt.Errorf(\"failed to resolve collisions: %w\", err)\n}\n```\n\n### 4. Update RemapCollisions\nRemapCollisions currently uses collision.RemapIncoming field. Update to use idMapping directly:\n- Remove RemapIncoming logic\n- Use idMapping to determine what to remap\n- Simplify to just apply the computed mapping\n\n### 5. Add comprehensive tests\n\nTest cases:\n1. 3-way collision with different content → 3 sequential IDs\n2. 3-way collision with 2 identical content → 2 IDs (dedupe works)\n3. Sync order independence (A→B→C vs C→A→B produce same result)\n4. Content hash ordering is respected\n5. Works with 5+ clones\n\n## Acceptance Criteria\n- ResolveNWayCollisions implemented and replaces ScoreCollisions\n- Groups all versions of same ID together\n- Deduplicates by content hash\n- Sorts by content hash deterministically\n- Assigns sequential IDs starting from base ID\n- Returns complete mapping (old ID → new ID)\n- All clones converge to same ID assignments\n- Works for arbitrary N-way collisions\n- TestThreeCloneCollision passes (or gets much closer)\n\n## Files to Modify\n- internal/storage/sqlite/collision.go (new function, helpers)\n- internal/importer/importer.go (call new function)\n- internal/storage/sqlite/collision_test.go (comprehensive tests)\n\n## Testing Strategy\n\n### Unit Tests\n- groupCollisionsByBaseID correctly groups\n- deduplicateVersionsByContentHash removes duplicates\n- Sorting by hash is stable and deterministic\n- Sequential ID assignment is correct\n\n### Integration Tests\n- 3-way collision resolves to 3 issues\n- Sync order doesn't affect final IDs\n- Content hash ordering determines winner\n\n### Property Tests\n- For any N clones with same content, all converge to same IDs\n- Idempotent: running resolution twice produces same result\n\n## Dependencies\n- Requires bd-cbed9619.5 (ContentHash field) to be completed first\n- Requires bd-cbed9619.4 (read-only detection) for clean integration\n\n## Notes\nThis is the core algorithm that enables convergence. The key insight:\n**Sort by content hash globally, not pairwise comparison.**","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T18:37:42.85616-07:00","updated_at":"2025-10-30T17:12:58.228707-07:00","closed_at":"2025-10-28T20:03:26.675257-07:00","dependencies":[{"issue_id":"bd-cbed9619.3","depends_on_id":"bd-325da116","type":"parent-child","created_at":"2025-10-28T18:39:20.593102-07:00","created_by":"daemon"},{"issue_id":"bd-cbed9619.3","depends_on_id":"bd-cbed9619.5","type":"blocks","created_at":"2025-10-28T18:39:28.30886-07:00","created_by":"daemon"},{"issue_id":"bd-cbed9619.3","depends_on_id":"bd-cbed9619.4","type":"blocks","created_at":"2025-10-28T18:39:28.336312-07:00","created_by":"daemon"}]}
{"id":"bd-cbed9619.4","content_hash":"49aad5fa2497f7f88fb74d54553825b93c1021ed7db04cfb2e58682699d8dca9","title":"Make DetectCollisions read-only (separate detection from modification)","description":"## Overview\nPhase 2: Separate collision detection from state modification to enable safe, composable collision resolution.\n\n## Current Problem\nDetectCollisions (collision.go:38-111) modifies database state during detection:\n- Line 83-86: Deletes issues when content matches but ID differs\n- This violates separation of concerns\n- Causes race conditions when processing multiple issues\n- Makes contentToDBIssue map stale after first deletion\n- Partial failures leave DB in inconsistent state\n\n## Solution\nMake DetectCollisions purely read-only. Move all modifications to a separate ApplyCollisionResolution function.\n\n## Implementation Tasks\n\n### 1. Add RenameDetail to CollisionResult\nFile: internal/storage/sqlite/collision.go\n```go\ntype CollisionResult struct {\n    ExactMatches []string\n    Collisions   []*CollisionDetail\n    NewIssues    []string\n    Renames      []*RenameDetail  // NEW\n}\n\ntype RenameDetail struct {\n    OldID string        // ID in database\n    NewID string        // ID in incoming\n    Issue *types.Issue  // The issue with new ID\n}\n```\n\n### 2. Remove deletion from DetectCollisions\nReplace lines 83-86:\n```go\n// OLD (DELETE THIS):\nif err := s.DeleteIssue(ctx, dbMatch.ID); err != nil {\n    return nil, fmt.Errorf(\"failed to delete renamed issue...\")\n}\n\n// NEW (ADD THIS):\nresult.Renames = append(result.Renames, \u0026RenameDetail{\n    OldID: dbMatch.ID,\n    NewID: incoming.ID,\n    Issue: incoming,\n})\ncontinue  // Don't mark as NewIssue yet\n```\n\n### 3. Create ApplyCollisionResolution function\nNew function to apply all modifications atomically:\n```go\nfunc ApplyCollisionResolution(ctx context.Context, s *SQLiteStorage,\n    result *CollisionResult, mapping map[string]string) error {\n    \n    // Phase 1: Handle renames (delete old IDs)\n    for _, rename := range result.Renames {\n        if err := s.DeleteIssue(ctx, rename.OldID); err != nil {\n            return fmt.Errorf(\"failed to delete renamed issue %s: %w\", \n                rename.OldID, err)\n        }\n    }\n    \n    // Phase 2: Create new IDs (from mapping)\n    // Phase 3: Update references\n    return nil\n}\n```\n\n### 4. Update callers to use two-phase approach\nFile: internal/importer/importer.go (handleCollisions)\n```go\n// Phase 1: Detect (read-only)\ncollisionResult, err := sqlite.DetectCollisions(ctx, sqliteStore, issues)\n\n// Phase 2: Resolve (compute mapping)\nmapping, err := sqlite.ResolveNWayCollisions(ctx, sqliteStore, collisionResult)\n\n// Phase 3: Apply (modify DB)\nerr = sqlite.ApplyCollisionResolution(ctx, sqliteStore, collisionResult, mapping)\n```\n\n### 5. Update tests\n- Verify DetectCollisions doesn't modify DB\n- Test ApplyCollisionResolution separately\n- Add test for rename detection without modification\n\n## Acceptance Criteria\n- DetectCollisions performs zero writes to database\n- DetectCollisions returns RenameDetail entries for content matches\n- ApplyCollisionResolution handles all modifications\n- All existing tests still pass\n- New test verifies read-only detection\n- contentToDBIssue map stays consistent throughout detection\n\n## Files to Modify\n- internal/storage/sqlite/collision.go (DetectCollisions, new function)\n- internal/importer/importer.go (handleCollisions caller)\n- internal/storage/sqlite/collision_test.go (add tests)\n\n## Testing\n- Unit test: DetectCollisions with content match doesn't delete DB issue\n- Unit test: RenameDetail correctly populated\n- Unit test: ApplyCollisionResolution applies renames\n- Integration test: Full flow still works end-to-end\n\n## Risk Mitigation\nThis is a significant refactor of core collision logic. Recommend:\n1. Add comprehensive tests before modifying\n2. Use feature flag to enable/disable new behavior\n3. Test thoroughly with TestTwoCloneCollision first","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T18:37:09.652326-07:00","updated_at":"2025-10-30T17:12:58.228266-07:00","closed_at":"2025-10-28T19:08:17.715416-07:00","dependencies":[{"issue_id":"bd-cbed9619.4","depends_on_id":"bd-325da116","type":"parent-child","created_at":"2025-10-28T18:39:20.570276-07:00","created_by":"daemon"},{"issue_id":"bd-cbed9619.4","depends_on_id":"bd-cbed9619.5","type":"blocks","created_at":"2025-10-28T18:39:28.285653-07:00","created_by":"daemon"}]}
{"id":"bd-cbed9619.5","content_hash":"12cd30dee3c08ba58d03e4468e6fe261a47d58c3b75397d9f14f38ee644fab6e","title":"Add content-addressable identity to Issue type","description":"## Overview\nPhase 1: Add content hashing to enable global identification of issues regardless of their assigned IDs.\n\n## Current Problem\nThe system identifies issues only by ID (e.g., test-1, test-2). When multiple clones create the same ID with different content, there's no way to identify that these are semantically different issues without comparing all fields.\n\n## Solution\nAdd a ContentHash field to the Issue type that represents the canonical content fingerprint.\n\n## Implementation Tasks\n\n### 1. Add ContentHash field to Issue type\nFile: internal/types/types.go\n```go\ntype Issue struct {\n    ID          string\n    ContentHash string  // SHA256 of canonical content\n    // ... existing fields\n}\n```\n\n### 2. Add content hash computation method\nUse existing hashIssueContent from collision.go:186 as foundation:\n```go\nfunc (i *Issue) ComputeContentHash() string {\n    return hashIssueContent(i)\n}\n```\n\n### 3. Compute hash at creation time\n- Modify CreateIssue to compute and store ContentHash\n- Modify CreateIssues (batch) to compute hashes\n\n### 4. Compute hash at import time  \n- Modify ImportIssues to compute ContentHash for all incoming issues\n- Store hash in database\n\n### 5. Add database column\n- Add migration to add content_hash column to issues table\n- Update SELECT/INSERT statements to include content_hash\n- Index on content_hash for fast lookups\n\n### 6. Populate existing issues\n- Add migration step to compute ContentHash for all existing issues\n- Use hashIssueContent function\n\n## Acceptance Criteria\n- Issue type has ContentHash field\n- Hash is computed automatically at creation time\n- Hash is computed for imported issues\n- Database stores content_hash column\n- All existing issues have non-empty ContentHash\n- Hash is deterministic (same content → same hash)\n- Hash excludes ID, timestamps (only semantic content)\n\n## Files to Modify\n- internal/types/types.go\n- internal/storage/sqlite/sqlite.go (schema, CreateIssue, CreateIssues)\n- internal/storage/sqlite/migrations.go (new migration)\n- internal/importer/importer.go (compute hash during import)\n- cmd/bd/create.go (compute hash at creation)\n\n## Testing\n- Unit test: same content produces same hash\n- Unit test: different content produces different hash  \n- Unit test: hash excludes ID and timestamps\n- Integration test: hash persists in database\n- Migration test: existing issues get hashes populated","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T18:36:44.914967-07:00","updated_at":"2025-10-30T17:12:58.2279-07:00","closed_at":"2025-10-28T18:57:10.985198-07:00","dependencies":[{"issue_id":"bd-cbed9619.5","depends_on_id":"bd-325da116","type":"parent-child","created_at":"2025-10-28T18:39:20.547325-07:00","created_by":"daemon"}]}
{"id":"bd-ce37850f","content_hash":"3ef2872c3fcb1e5acc90d33fd5a76291742cbcecfbf697b611aa5b4d8ce80078","title":"Add embedding generation for duplicate detection","description":"Use embeddings for scalable duplicate detection.\n\nModel: text-embedding-3-small (OpenAI) or all-MiniLM-L6-v2 (local)\nStorage: SQLite vector extension or in-memory\nCost: ~/bin/bash.0002 per 100 issues\n\nMuch cheaper than LLM comparisons for large databases.\n\nFiles: internal/embeddings/ (new package)","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T14:48:29.072913-07:00","updated_at":"2025-10-30T17:12:58.219921-07:00"}
{"id":"bd-cf349eb3","content_hash":"1b42289a0cb1da0626a69c6f004bf62fc9ba6e3a0f8eb70159c5f1446497020b","title":"Update LINTING.md with current baseline","description":"After cleanup, document the remaining acceptable baseline in LINTING.md so we can track regression.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T23:20:10.39272-07:00","updated_at":"2025-10-30T17:12:58.215471-07:00","closed_at":"2025-10-27T23:05:31.945614-07:00"}
{"id":"bd-d355a07d","content_hash":"b4f98403e209eadf33dd4913660c1538fd922c89339a9ed034ef504aac358662","title":"Import validation falsely reports data loss on collision resolution","description":"## Problem\n\nPost-import validation reports 'data loss detected!' when import count reduces due to legitimate collision resolution.\n\n## Example\n\n```\nImport complete: 1 created, 8 updated, 142 unchanged, 19 skipped, 1 issues remapped\nPost-import validation failed: import reduced issue count: 165 → 164 (data loss detected!)\n```\n\nThis was actually successful collision resolution (bd-70419816 duplicated → remapped to-70419816), not data loss.\n\n## Impact\n\n- False alarms waste investigation time\n- Undermines confidence in import validation\n- Confuses users/agents about sync health\n\n## Solution\n\nImprove validation to distinguish:\n- Collision-resolution merges (expected count reduction)\n- Actual data loss (unexpected disappearance)\n\nTrack remapped issue count and adjust expected post-import count accordingly.","status":"open","priority":2,"issue_type":"bug","created_at":"2025-10-29T23:15:00.815227-07:00","updated_at":"2025-10-31T19:38:09.19996-07:00"}
{"id":"bd-d4ec5a82","content_hash":"872448809bfa26d39d68ba6cac5071379756c30bcd3b08dc75de6da56c133956","title":"Add MCP functions for repair commands","description":"Add repair commands to beads-mcp for agent access:\n- beads_resolve_conflicts()\n- beads_find_duplicates()\n- beads_detect_pollution()\n- beads_validate()\n\nFiles: integrations/beads-mcp/src/beads_mcp/server.py","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-28T14:48:29.071495-07:00","updated_at":"2025-10-30T17:12:58.219499-07:00"}
{"id":"bd-d7e88238","content_hash":"b69ec861618b03129fad7807b085ee6365860cfd2e9901b49eb846e192b95a0d","title":"Rapid 3","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T19:11:57.459655-07:00","updated_at":"2025-10-30T17:12:58.189494-07:00"}
{"id":"bd-da4d8951","content_hash":"a4e81b23d88d41c8fd3fe31fb7ef387f99cb54ea42a6baa210ede436ecce3288","title":"Replace getStorageForRequest with Direct Access","description":"Replace all getStorageForRequest(req) calls with s.storage","acceptance_criteria":"- No references to getStorageForRequest() in codebase (except in deleted file)\n- All handlers use s.storage directly\n- Code compiles without errors\n\nFiles to update:\n- internal/rpc/server_issues_epics.go (~8 calls)\n- internal/rpc/server_labels_deps_comments.go (~4 calls)\n- internal/rpc/server_compact.go (~2 calls)\n- internal/rpc/server_export_import_auto.go (~2 calls)\n- internal/rpc/server_routing_validation_diagnostics.go (~1 call)\n\nPattern: store, err := s.getStorageForRequest(req) → store := s.storage","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-28T16:20:02.430127-07:00","updated_at":"2025-10-30T17:12:58.22099-07:00","closed_at":"2025-10-28T19:20:58.312809-07:00"}
{"id":"bd-dcd6f14b","content_hash":"efc3565abad1605a8bc16b151fa067d0584a36e3e86e0baa2fb5e5a470c64444","title":"Batch test 4","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T15:29:02.053523-07:00","updated_at":"2025-10-31T12:00:43.182861-07:00","closed_at":"2025-10-31T12:00:43.182861-07:00"}
{"id":"bd-dd6f6d26","content_hash":"dbcecb8b95f9f2939d97c61bd8cbe331bea866f47600bded213d3122e311c356","title":"Fix autoimport tests for content-hash collision scoring","description":"## Overview\nThree autoimport tests are failing after bd-cbed9619.4 because they expect behavior based on the old reference-counting collision resolution, but the system now uses deterministic content-hash scoring.\n\n## Failing Tests\n1. `TestAutoImportMultipleCollisionsRemapped` - expects local versions preserved\n2. `TestAutoImportAllCollisionsRemapped` - expects local versions preserved  \n3. `TestAutoImportCollisionRemapMultipleFields` - expects specific collision resolution behavior\n\n## Root Cause\nThese tests were written when ScoreCollisions used reference counting to determine which version to keep. Now it uses content-hash comparison (introduced in commit 2e87329), which produces different but deterministic results.\n\n## Example\nOld behavior: Issue with more references would be kept\nNew behavior: Issue with lexicographically lower content hash is kept\n\n## Solution\nUpdate each test to:\n1. Verify the new content-hash based behavior is correct\n2. Check that the remapped issue (not necessarily local/remote) has the expected content\n3. Ensure dependencies are preserved on the correct remapped issue\n\n## Acceptance Criteria\n- All three autoimport tests pass\n- Tests verify content-hash determinism (same collision always resolves the same way)\n- Tests check dependency preservation on remapped issues\n- Test documentation explains content-hash scoring expectations\n\n## Files to Modify\n- `cmd/bd/autoimport_collision_test.go`\n\n## Testing\nRun: `go test ./cmd/bd -run \"TestAutoImport.*Collision\" -v`","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-28T19:12:56.344193-07:00","updated_at":"2025-10-30T17:12:58.178703-07:00","closed_at":"2025-10-28T19:18:35.106895-07:00","dependencies":[{"issue_id":"bd-dd6f6d26","depends_on_id":"bd-cbed9619.4","type":"discovered-from","created_at":"2025-10-28T19:12:56.345276-07:00","created_by":"daemon"}]}
{"id":"bd-df190564","content_hash":"4f4f22b210c0a5cabd1beebb9c291993adf25843a36ef2ea07227f35de578018","title":"bd repair-deps - Orphaned dependency cleaner","description":"Find and fix orphaned dependency references.\n\nImplementation:\n- Scan all issues for dependencies pointing to non-existent issues\n- Report orphaned refs\n- Auto-fix with --fix flag\n- Interactive mode with --interactive\n\nFiles: cmd/bd/repair_deps.go (new)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T19:42:29.852745-07:00","updated_at":"2025-10-31T18:24:19.418221-07:00","closed_at":"2025-10-31T18:24:19.418221-07:00"}
{"id":"bd-e1085716","content_hash":"f180247fd30176bb37125a69c1c9361815d52e3437f930b81ec164d4cb92c4dd","title":"bd validate - Comprehensive health check","description":"Run all validation checks in one command.\n\nChecks:\n- Duplicates\n- Orphaned dependencies\n- Test pollution\n- Git conflicts\n\nSupports --fix-all for auto-repair.\n\nDepends on bd-cbed9619.1, bd-0dcea000, bd-31aab707, bd-9826b69a.\n\nFiles: cmd/bd/validate.go (new)","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-29T23:05:13.980679-07:00","updated_at":"2025-10-30T17:12:58.19736-07:00"}
{"id":"bd-e1d645e8","content_hash":"38eb74773fec37584ddaeb23f64a7ebbbb94893a2f1ab047740bf9f0cfca88c0","title":"Rapid 4","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T19:11:57.484329-07:00","updated_at":"2025-10-30T17:12:58.189715-07:00"}
{"id":"bd-e55c","content_hash":"1204ddc254f51c686f5586fe540d36abe0a225176e0eb8418147e46cbd3aa298","title":"Import overwrites newer local issues with older remote versions","description":"## Problem\n\nDuring git pull + import, local issues with newer updated_at timestamps get overwritten by older versions from remote JSONL.\n\n## What Happened\n\nTimeline:\n1. 17:52 - Closed bd-df190564 and bd-b501fcc1 locally (updated_at: 2025-10-31)\n2. 17:51 - Remote pushed same issues with status=open (updated_at: 2025-10-30)\n3. 17:52 - Local sync pulled remote commit and imported JSONL\n4. Result: Issues reverted to open despite local version being newer\n\n## Root Cause\n\nDetectCollisions (internal/storage/sqlite/collision.go:67-79) compares fields but doesn't check timestamps:\n\n```go\nconflictingFields := compareIssues(existing, incoming)\nif len(conflictingFields) == 0 {\n    result.ExactMatches = append(result.ExactMatches, incoming.ID)\n} else {\n    // Same ID, different content - treats as UPDATE\n    result.Collisions = append(result.Collisions, \u0026CollisionDetail{...})\n}\n```\n\nImport applies incoming version regardless of which is newer.\n\n## Expected Behavior\n\nImport should:\n1. Compare updated_at timestamps when collision detected\n2. Skip update if local version is newer\n3. Apply update only if remote version is newer\n4. Warn on timestamp conflicts\n\n## Solution\n\nAdd timestamp checking to DetectCollisions or importIssues:\n\n```go\nif len(conflictingFields) \u003e 0 {\n    // Check timestamps\n    if !incoming.UpdatedAt.After(existing.UpdatedAt) {\n        // Local is newer or same - skip update\n        result.ExactMatches = append(result.ExactMatches, incoming.ID)\n        continue\n    }\n    // Remote is newer - apply update\n    result.Collisions = append(result.Collisions, \u0026CollisionDetail{...})\n}\n```\n\n## Files\n- internal/storage/sqlite/collision.go\n- internal/importer/importer.go\n\n## References\n- Discovered during bd-df190564, bd-b501fcc1 re-opening","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-31T17:56:43.919306-07:00","updated_at":"2025-10-31T18:05:55.521427-07:00","closed_at":"2025-10-31T18:05:55.521427-07:00"}
{"id":"bd-e652","content_hash":"6e43bbf6e0c51b81a70e56ad25a5c8f6d08e6e5fcb33e691029027e151707432","title":"bd doctor doesn't detect version mismatches or stale daemons","description":"","status":"open","priority":1,"issue_type":"bug","created_at":"2025-10-31T21:07:56.957214-07:00","updated_at":"2025-10-31T21:07:56.957214-07:00","dependencies":[{"issue_id":"bd-e652","depends_on_id":"bd-2752a7a2","type":"discovered-from","created_at":"2025-10-31T21:07:56.958708-07:00","created_by":"stevey"}]}
{"id":"bd-e6d71828","content_hash":"51e2a90a6200df1bf26535e7421b485a3c76e4162c5b68c165a2ad42a09df6b3","title":"Add transaction + retry logic for N-way collision resolution","description":"## Problem\nCurrent N-way collision resolution fails on UNIQUE constraint violations during convergence rounds when 5+ clones sync. The RemapCollisions function is non-atomic and performs operations sequentially:\n1. Delete old issues (CASCADE deletes dependencies)\n2. Create remapped issues (can fail with UNIQUE constraint)\n3. Recreate dependencies\n4. Update text references\n\nFailure at step 2 leaves database in inconsistent state.\n\n## Solution\nWrap collision resolution in database transaction with retry logic:\n- Make entire RemapCollisions operation atomic\n- Retry up to 3 times on UNIQUE constraint failures\n- Re-sync counters between retries\n- Add better error messages for debugging\n\n## Implementation\nLocation: internal/storage/sqlite/collision.go:342 (RemapCollisions function)\n\n```go\n// Retry up to 3 times on UNIQUE constraint failures\nfor attempt := 0; attempt \u003c 3; attempt++ {\n    err := s.db.ExecInTransaction(func(tx *sql.Tx) error {\n        // All collision resolution operations\n    })\n    if !isUniqueConstraintError(err) {\n        return err\n    }\n    s.SyncAllCounters(ctx)\n}\n```\n\n## Success Criteria\n- 5-clone collision test passes reliably\n- No partial state on UNIQUE constraint errors\n- Automatic recovery from transient ID conflicts\n\n## References\n- See beads_nway_test.go:124 for the KNOWN LIMITATION comment\n- Related to-7c5915ae (transaction support)","notes":"## Progress Made\n\n1. Added `ExecInTransaction` helper to SQLiteStorage for atomic database operations\n2. Added `IsUniqueConstraintError` function to detect UNIQUE constraint violations\n3. Wrapped `RemapCollisions` with retry logic (up to 3 attempts) with counter sync between retries\n4. Enhanced `handleRename` to detect and handle race conditions where target ID already exists\n5. Added defensive checks for when old ID has been deleted by another clone\n\n## Test Results\n\nThe changes improve N-way collision handling but don't fully solve the problem:\n- Original error: `UNIQUE constraint failed: issues.id` during first convergence round\n- With changes: Test proceeds further but encounters different collision scenarios\n- New error: `target ID already exists with different content` in later convergence rounds\n\n## Root Cause Analysis\n\nThe issue is more complex than initially thought. In N-way scenarios:\n1. Clone A remaps bd-1c63eb84 → test-2 → test-4\n2. Clone B remaps bd-1c63eb84 → test-3 → test-4  \n3. Both try to create test-4, but with different intermediate states\n4. This creates legitimate content collisions that require additional resolution\n\n## Next Steps  \n\nThe full solution requires:\n1. Making remapping fully deterministic across clones (same input → same remapped ID)\n2. OR making `handleRename` more tolerant of mid-flight collisions\n3. OR implementing full transaction support for multi-step collision resolution -7c5915ae)\n\nThe retry logic added here provides a foundation but isn't sufficient for complex N-way scenarios.","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-29T10:22:32.716678-07:00","updated_at":"2025-10-31T20:36:49.288841-07:00","dependencies":[{"issue_id":"bd-e6d71828","depends_on_id":"bd-cbed9619.1","type":"related","created_at":"2025-10-29T10:44:44.14653-07:00","created_by":"daemon"}]}
{"id":"bd-e8be4224","content_hash":"15cf7306a1c279137aba5515692e560047a56355504285c68a5ff8a006aef3f6","title":"Batch test 3","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T15:29:01.964091-07:00","updated_at":"2025-10-31T12:00:43.183212-07:00","closed_at":"2025-10-31T12:00:43.183212-07:00"}
{"id":"bd-e98221b3","content_hash":"39107dceb86c0f5588342036585cca9cb320d0df2814fe470e688c4172644890","title":"Update AGENTS.md and README.md with \"bd daemons\" documentation","description":"Document the new \"bd daemons\" command and all subcommands in AGENTS.md and README.md. Include examples and troubleshooting guidance.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-26T19:41:11.099254-07:00","updated_at":"2025-10-30T17:12:58.181671-07:00"}
{"id":"bd-eb3c","content_hash":"6922e5dc2f24e0fb84ecdb7bea11284f38c3f9e7fed43b90eeef4d6372a96fd5","title":"UX nightmare: multiple ways daemon can fail with misleading messages","description":"","status":"open","priority":0,"issue_type":"epic","created_at":"2025-10-31T21:08:09.090553-07:00","updated_at":"2025-10-31T21:08:09.090553-07:00"}
{"id":"bd-eef03e0a","content_hash":"f075e26fe762aa3fc5484f97441c0cc0b296fa49e9c7b1242bda1c5b6c8ec894","title":"Stress test: event storm handling","description":"Simulate 100+ rapid JSONL writes. Verify debouncer batches to single import. Verify no data loss. Test daemon stability.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T20:49:49.138725-07:00","updated_at":"2025-10-31T19:18:50.682925-07:00","closed_at":"2025-10-31T19:18:50.682925-07:00"}
{"id":"bd-ef72b864","content_hash":"81f5c4fcc229c3ba653d29fc71c9ae3be75ed672296e3e790a88498ee2df3a64","title":"Add MCP server functions for repair commands","description":"Expose new repair commands via MCP server for agent access:\n\nFunctions to add:\n- beads_repair_deps()\n- beads_detect_pollution()\n- beads_validate()\n- beads_resolve_conflicts() (when implemented)\n\nUpdate integrations/beads-mcp/src/beads_mcp/server.py\n\nSee repair_commands.md lines 803-884 for design.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-28T19:38:02.227921-07:00","updated_at":"2025-10-30T17:12:58.180404-07:00","closed_at":"2025-10-29T23:14:44.187562-07:00"}
{"id":"bd-ef85","content_hash":"9c3f57a10718db484253639c857ed8e7c7b71c9983358af17afc26efa8d1bd86","title":"Add --json flags to all bd commands for agent-friendly output","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-10-31T22:39:45.312496-07:00","updated_at":"2025-10-31T22:39:50.157022-07:00","closed_at":"2025-10-31T22:39:50.157022-07:00"}
{"id":"bd-f0d9bcf2","content_hash":"d4c343a7d3ee7985fcde6f9438d9f4a4a98780e4abd75de0d7a7310c31e2cc94","title":"Batch test 1","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T15:29:01.795728-07:00","updated_at":"2025-10-31T12:00:43.184078-07:00","closed_at":"2025-10-31T12:00:43.184078-07:00"}
{"id":"bd-f8b764c9","content_hash":"9f22cba5111b9e92f2880670226689ac818f5006267bceb36e0502433413f332","title":"Hash-based IDs with aliasing system","description":"Replace sequential auto-increment IDs (bd-1c63eb84, bd-9063acda) with content-hash based IDs (bd-af78e9a2) plus human-friendly aliases (#1, #2).\n\n## Motivation\nCurrent sequential IDs cause collision problems when multiple clones work offline:\n- Non-deterministic convergence in N-way scenarios (bd-cbed9619.1, bd-e6d71828)\n- Complex collision resolution logic (~2,100 LOC)\n- UNIQUE constraint violations during import\n- Requires coordination between workers\n\nHash-based IDs eliminate collisions entirely while aliases preserve human readability.\n\n## Benefits\n- ✅ Collision-free distributed ID generation\n- ✅ Eliminates ~2,100 LOC of collision handling code\n- ✅ Better git merge behavior (different IDs = different JSONL lines)\n- ✅ True offline-first workflows\n- ✅ Simpler auto-import (no remapping needed)\n- ✅ Enables parallel CI/CD workers without coordination\n\n## Design\n- Canonical ID: bd-af78e9a2 (8-char SHA256 prefix of title+desc+timestamp+creator)\n- Alias: #42 (auto-increment per workspace, mutable, display-only)\n- CLI accepts both: bd show bd-af78e9a2 OR bd show #42\n- JSONL stores hash IDs only (aliases reconstructed on import)\n- Alias conflicts resolved via content-hash ordering (deterministic)\n\n## Breaking Change\nThis is a v2.0 feature requiring migration. Provide bd migrate --hash-ids tool.\n\n## Timeline\n~9 weeks (Phase 1: Hash IDs 4w, Phase 2: Aliases 3w, Phase 3: Testing 2w)\n\n## Dependencies\nShould complete after bd-7c5915ae (cleanup validation) and before bd-710a4916 (CRDT).","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-10-29T21:23:49.592315-07:00","updated_at":"2025-10-31T12:32:32.6038-07:00","closed_at":"2025-10-31T12:32:32.6038-07:00"}
{"id":"bd-f8b764c9.1","content_hash":"4b348a47b8819c70bed5407a8a785605238738f5e56e344a8140a13de2c5dfd8","title":"Dogfood: Migrate beads repo to hash IDs","description":"Final validation: migrate the beads project itself to hash-based IDs.\n\n## Purpose\nDogfooding the migration on beads' own issue database to:\n1. Validate migration tool works on real data\n2. Discover edge cases\n3. Verify all workflows still work\n4. Build confidence for users\n\n## Pre-Migration Checklist\n- [ ] All bd-f8b764c9 child tasks completed\n- [ ] All tests pass: `go test ./...`\n- [ ] Migration tool tested on test databases\n- [ ] Documentation updated\n- [ ] MCP server updated and published\n- [ ] Clean git status\n\n## Migration Steps\n\n### 1. Create Backup\n```bash\n# Backup database\ncp -r .beads .beads.backup-1761798568\n\n# Backup JSONL\ncp .beads/beads.jsonl .beads/beads.jsonl.backup\n\n# Create git branch for migration\ngit checkout -b hash-id-migration\ngit add .beads.backup-*\ngit commit -m \"Pre-migration backup\"\n```\n\n### 2. Run Migration (Dry Run)\n```bash\nbd migrate --hash-ids --dry-run \u003e migration-plan.txt\ncat migration-plan.txt\n\n# Review:\n# - Number of issues to migrate\n# - Hash collision check (should be zero)\n# - Text reference updates\n# - Dependency updates\n```\n\n### 3. Run Migration (Real)\n```bash\nbd migrate --hash-ids 2\u003e\u00261 | tee migration-log.txt\n\n# Expected output:\n# ✓ Backup created: .beads/beads.db.backup-1234567890\n# ✓ Generated 150 hash IDs\n# ✓ No hash collisions detected\n# ✓ Updated issues table schema\n# ✓ Updated 150 issue IDs\n# ✓ Updated 87 dependencies\n# ✓ Updated 234 text references\n# ✓ Exported to .beads/beads.jsonl\n# ✓ Migration complete!\n```\n\n### 4. Validation\n\n#### Database Integrity\n```bash\n# Check all issues have hash IDs\nbd list | grep -v \"bd-[a-f0-9]\\{8\\}\" \u0026\u0026 echo \"FAIL: Non-hash IDs found\"\n\n# Check all issues have aliases\nsqlite3 .beads/beads.db \"SELECT COUNT(*) FROM issues WHERE alias IS NULL\"\n# Should be 0\n\n# Check no alias duplicates\nsqlite3 .beads/beads.db \"SELECT alias, COUNT(*) FROM issues GROUP BY alias HAVING COUNT(*) \u003e 1\"\n# Should be empty\n```\n\n#### Functionality Tests\n```bash\n# Test show by hash ID\nbd show bd-\n\n# Test show by alias\nbd show #1\n\n# Test create new issue\nbd create \"Test issue after migration\" -p 2\n# Should get hash ID + alias\n\n# Test update\nbd update #1 --priority 1\n\n# Test dependencies\nbd dep tree #1\n\n# Test export\nbd export\ngit diff .beads/beads.jsonl\n# Should show hash IDs\n```\n\n#### Text Reference Validation\n```bash\n# Check that old IDs were updated in descriptions\ngrep -r \"bd-[0-9]\\{1,3\\}[^a-f0-9]\" .beads/beads.jsonl \u0026\u0026 echo \"FAIL: Old ID format found\"\n\n# Verify hash ID references exist\ngrep -o \"bd-[a-f0-9]\\{8\\}\" .beads/beads.jsonl | sort -u | wc -l\n# Should match number of hash IDs\n```\n\n### 5. Commit Migration\n```bash\ngit add .beads/beads.jsonl .beads/beads.db\ngit commit -m \"Migrate to hash-based IDs (v2.0)\n\n- Migrated 150 issues to hash IDs\n- Preserved aliases (#1-#150)\n- Updated 87 dependencies\n- Updated 234 text references\n- Zero hash collisions\n\nMigration log: migration-log.txt\"\n\ngit push origin hash-id-migration\n```\n\n### 6. Create PR\n```bash\ngh pr create --title \"Migrate to hash-based IDs (v2.0)\" --body \"## Summary\nMigrates beads project to hash-based IDs as part of v2.0 release.\n\n## Migration Stats\n- Issues migrated: 150\n- Dependencies updated: 87\n- Text references updated: 234\n- Hash collisions: 0\n- Aliases assigned: 150\n\n## Validation\n- ✅ All tests pass\n- ✅ Database integrity verified\n- ✅ All workflows tested (show, update, create, deps)\n- ✅ Text references updated correctly\n- ✅ Export produces valid JSONL\n\n## Files Changed\n- `.beads/beads.jsonl` - Hash IDs in all entries\n- `.beads/beads.db` - Schema updated with aliases\n\n## Rollback\nIf issues arise:\n\\`\\`\\`bash\nmv .beads.backup-1234567890 .beads\nbd export\n\\`\\`\\`\n\nSee migration-log.txt for full details.\"\n```\n\n### 7. Merge and Cleanup\n```bash\n# After PR approval\ngit checkout main\ngit merge hash-id-migration\ngit push origin main\n\n# Tag release\ngit tag v2.0.0\ngit push origin v2.0.0\n\n# Cleanup\nrm migration-log.txt migration-plan.txt\ngit checkout .beads.backup-*  # Keep in git history\n```\n\n## Rollback Procedure\nIf migration fails or has issues:\n\n```bash\n# Restore backup\nmv .beads .beads.failed-migration\nmv .beads.backup-1234567890 .beads\n\n# Regenerate JSONL\nbd export\n\n# Verify restoration\nbd list\ngit diff .beads/beads.jsonl\n\n# Cleanup\ngit checkout hash-id-migration\ngit reset --hard main\n```\n\n## Post-Migration Communication\n\n### GitHub Issue/Discussion\n```markdown\n## Beads v2.0 Released: Hash-Based IDs\n\nWe've migrated beads to hash-based IDs! 🎉\n\n**What changed:**\n- Issues now use hash IDs (bd-af78e9a2) instead of sequential (bd-cb64c226.3)\n- Human-friendly aliases (#42) for easy reference\n- Zero collision risk in distributed workflows\n\n**Action required:**\nIf you have a local clone, you need to migrate:\n\n\\`\\`\\`bash\ngit pull origin main\nbd migrate --hash-ids\ngit push origin main\n\\`\\`\\`\n\nSee MIGRATION.md for details.\n\n**Benefits:**\n- ✅ No more ID collisions\n- ✅ Work offline without coordination\n- ✅ Simpler codebase (-2,100 LOC)\n\nQuestions? Reply here or see docs/HASH_IDS.md\n```\n\n## Success Criteria\n- [ ] Migration completes without errors\n- [ ] All validation checks pass\n- [ ] PR merged to main\n- [ ] v2.0.0 tagged and released\n- [ ] Documentation updated\n- [ ] Community notified\n- [ ] No rollback needed within 1 week\n\n## Files to Create\n- migration-log.txt (transient)\n- migration-plan.txt (transient)\n\n## Timeline\nExecute after all other bd-f8b764c9 tasks complete (estimated: ~8 weeks from start)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:29:28.591526-07:00","updated_at":"2025-10-31T12:32:32.607092-07:00","closed_at":"2025-10-31T12:32:32.607092-07:00","dependencies":[{"issue_id":"bd-f8b764c9.1","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:29:28.59248-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.1","depends_on_id":"bd-f8b764c9.4","type":"blocks","created_at":"2025-10-29T21:29:28.593033-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.1","depends_on_id":"bd-f8b764c9.3","type":"blocks","created_at":"2025-10-29T21:29:28.593437-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.1","depends_on_id":"bd-f8b764c9.12","type":"blocks","created_at":"2025-10-29T21:29:28.593876-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.1","depends_on_id":"bd-f8b764c9.2","type":"blocks","created_at":"2025-10-29T21:29:28.594521-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.10","content_hash":"0315167c9165d2bf5f9e782f760a6350529126f9d1010d9ac206be9d8b9cc017","title":"Add alias field to database schema","description":"Extend database schema to support human-friendly aliases alongside hash IDs.\n\n## Database Changes\n\n### 1. Add alias column to issues table\n```sql\nALTER TABLE issues ADD COLUMN alias INTEGER UNIQUE;\nCREATE INDEX idx_issues_alias ON issues(alias);\n```\n\n### 2. Add alias counter table\n```sql\nCREATE TABLE alias_counter (\n    id INTEGER PRIMARY KEY CHECK (id = 1),\n    next_alias INTEGER NOT NULL DEFAULT 1\n);\nINSERT INTO alias_counter (id, next_alias) VALUES (1, 1);\n```\n\n### 3. Add alias conflict tracking (for multi-clone scenarios)\n```sql\nCREATE TABLE alias_history (\n    issue_id TEXT NOT NULL,\n    alias INTEGER NOT NULL,\n    assigned_at TIMESTAMP NOT NULL,\n    workspace_id TEXT NOT NULL,\n    PRIMARY KEY (issue_id, alias)\n);\n```\n\n## API Changes\n\n### CreateIssue\n- Generate hash ID\n- Assign next available alias\n- Store both in database\n\n### ResolveAliasConflicts (new function)\n- Detect conflicting alias assignments after import\n- Apply resolution strategy (content-hash ordering)\n- Reassign losers to next available aliases\n\n## Migration Path\n```bash\nbd migrate --add-aliases  # Adds columns, assigns aliases to existing issues\n```\n\n## Files to Modify\n- internal/storage/sqlite/schema.go\n- internal/storage/sqlite/sqlite.go (CreateIssue, GetIssue)\n- internal/storage/sqlite/aliases.go (new file for alias logic)\n- internal/storage/sqlite/migrations.go\n\n## Testing\n- Test alias auto-assignment on create\n- Test alias uniqueness constraint\n- Test alias lookup performance\n- Test alias conflict resolution","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:24:13.968241-07:00","updated_at":"2025-10-31T12:32:32.610663-07:00","closed_at":"2025-10-31T12:32:32.610663-07:00","dependencies":[{"issue_id":"bd-f8b764c9.10","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:24:13.96959-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.10","depends_on_id":"bd-f8b764c9.11","type":"blocks","created_at":"2025-10-29T21:29:45.952824-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.11","content_hash":"ab5665f7fb44bf9207919cf5b67eb1d64bd2ab49607f563b307ded2fb28925e1","title":"Design hash ID generation algorithm","description":"Design and specify the hash-based ID generation algorithm.\n\n## Requirements\n- Deterministic: same inputs → same ID\n- Collision-resistant: ~2^32 space for 8-char hex\n- Fast: \u003c1μs per generation\n- Includes timestamp for uniqueness\n- Includes creator/workspace for distributed uniqueness\n\n## Proposed Algorithm\n```go\nfunc GenerateIssueID(title, desc string, created time.Time, workspaceID string) string {\n    h := sha256.New()\n    h.Write([]byte(title))\n    h.Write([]byte(desc))\n    h.Write([]byte(created.Format(time.RFC3339Nano)))\n    h.Write([]byte(workspaceID))\n    hash := hex.EncodeToString(h.Sum(nil))\n    return \"bd-\" + hash[:8]  // 8-char prefix = 2^32 space\n}\n```\n\n## Open Questions\n1. 8 chars (2^32) or 16 chars (2^64) for collision resistance?\n2. Include priority/type in hash? (Pro: more entropy. Con: immutable)\n3. How to handle workspace ID generation? (hostname? UUID?)\n4. What if title+desc change? (Answer: ID stays same - hash only used at creation)\n\n## Deliverables\n- Design doc: docs/HASH_ID_DESIGN.md\n- Collision probability analysis\n- Performance benchmarks\n- Prototype implementation in internal/types/id_generator.go","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:24:01.843634-07:00","updated_at":"2025-10-31T12:32:32.610902-07:00","closed_at":"2025-10-31T12:32:32.610902-07:00","dependencies":[{"issue_id":"bd-f8b764c9.11","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:24:01.844994-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.12","content_hash":"4b63fd2a65d45bfabe57dfe896015343682813978c76071c1cb1df747659fd2c","title":"Update documentation for hash IDs and aliases","description":"Update all documentation to explain hash-based IDs and aliasing system.\n\n## Files to Update\n\n### 1. README.md\nAdd section explaining hash IDs:\n```markdown\n## Issue IDs\n\nBeads uses **hash-based IDs** for collision-free distributed issue tracking:\n\n- **Hash ID**: `bd-af78e9a2` (8-char SHA256 prefix, immutable, globally unique)\n- **Alias**: `#42` (sequential number, mutable, human-friendly)\n\n### Using IDs\n```bash\nbd show bd-af78e9a2   # Use hash ID\nbd show #42           # Use alias\nbd show 42            # Use alias (shorthand)\n```\n\n### Why Hash IDs?\n- **Collision-free**: Work offline without ID conflicts\n- **Distributed**: No coordination needed between clones\n- **Git-friendly**: Different IDs = different JSONL lines, fewer merge conflicts\n\n### Aliases\nAliases are workspace-local shortcuts for hash IDs. They're:\n- Automatically assigned on issue creation\n- Reassigned deterministically on sync (if conflicts)\n- Can be manually controlled with `bd alias` commands\n```\n\n### 2. AGENTS.md\nUpdate agent workflow:\n```markdown\n## Hash-Based IDs (v2.0+)\n\nBeads v2.0 uses hash-based IDs to eliminate collision problems:\n\n**When creating issues**:\n```bash\nbd create \"Fix bug\" -p 1\n# → Creates bd-af78e9a2 with alias #1\n```\n\n**When referencing issues**:\n- In text: Use hash IDs (stable): \"See bd-af78e9a2 for details\"\n- In CLI: Use aliases (readable): `bd update #42 --status done`\n\n**After sync**:\n- Alias conflicts resolved automatically (content-hash ordering)\n- No ID collisions possible\n- No remapping needed\n\n**Migration from v1.x**:\n```bash\nbd migrate --hash-ids  # One-time migration\n```\n```\n\n### 3. QUICKSTART.md (if exists)\nShow alias usage in examples:\n```bash\n# Create issue (gets hash ID + alias)\nbd create \"Fix authentication bug\" -p 1\n# → Created bd-af78e9a2 (alias: #1)\n\n# Reference by alias\nbd show #1\nbd update #1 --status in_progress\nbd close #1 --reason \"Fixed\"\n```\n\n### 4. ADVANCED.md\nAdd section on hash ID internals:\n```markdown\n## Hash ID Generation\n\nHash IDs are generated deterministically:\n\n```go\nSHA256(title || description || timestamp || workspace_id)[:8]\n```\n\n**Collision probability**:\n- 8 hex chars = 2^32 space = ~4 billion IDs\n- Birthday paradox: 50% collision probability at ~65,000 issues\n- For typical projects (\u003c10,000 issues), collision risk is negligible\n\n**Collision detection**:\nIf a hash collision occurs (extremely rare), beads:\n1. Detects on insert (UNIQUE constraint)\n2. Appends random suffix: `bd-af78e9a2-a1b2`\n3. Retries insert\n\n## Alias Conflict Resolution\n\nWhen multiple clones assign same alias to different issues:\n\n**Strategy**: Content-hash ordering (deterministic)\n- Sort conflicting issue IDs lexicographically\n- Lowest hash ID keeps the alias\n- Others reassigned to next available aliases\n\n**Example**:\n```\nClone A: Assigns #42 to bd-a1b2c3d4\nClone B: Assigns #42 to bd-e5f6a7b8\nAfter sync: bd-a1b2c3d4 keeps #42 (lower hash)\n            bd-e5f6a7b8 gets #100 (next available)\n```\n```\n\n### 5. MIGRATION.md (new file)\n```markdown\n# Migrating to Hash-Based IDs (v2.0)\n\n## Overview\nBeads v2.0 introduces hash-based IDs to eliminate collision problems. This is a **breaking change** requiring migration.\n\n## Migration Steps\n\n### 1. Backup\n```bash\ncp -r .beads .beads.backup\ngit commit -am \"Pre-migration backup\"\n```\n\n### 2. Run Migration\n```bash\n# Dry run first\nbd migrate --hash-ids --dry-run\n\n# Apply migration\nbd migrate --hash-ids\n```\n\n### 3. Commit Changes\n```bash\ngit add .beads/issues.jsonl\ngit commit -m \"Migrate to hash-based IDs (v2.0)\"\ngit push origin main\n```\n\n### 4. Coordinate with Collaborators\nAll clones must migrate before syncing:\n1. Notify team: \"Migrating to v2.0 on [date]\"\n2. All collaborators pull latest\n3. All run `bd migrate --hash-ids`\n4. All push changes\n5. Resume normal work\n\n## Rollback\n```bash\n# Restore backup\nmv .beads.backup .beads\nbd export  # Regenerate JSONL\ngit checkout .beads/issues.jsonl\n```\n\n## FAQ\n\n**Q: Can I mix v1.x and v2.0 clones?**\nA: No. All clones must be on same version.\n\n**Q: Will my old issue IDs work?**\nA: No, but aliases preserve the numbers: bd-1c63eb84 → #1\n\n**Q: What happens to links like \"see bd-cb64c226.3\"?**\nA: Migration updates all text references automatically.\n```\n\n### 6. CHANGELOG.md\n```markdown\n## v2.0.0 (YYYY-MM-DD)\n\n### Breaking Changes\n- **Hash-based IDs**: Issues now use collision-free hash IDs (bd-af78e9a2)\n  instead of sequential IDs (bd-1c63eb84, bd-9063acda)\n- **Aliasing system**: Human-friendly aliases (#42) for hash IDs\n- **Migration required**: Run `bd migrate --hash-ids` to convert v1.x databases\n\n### Added\n- `bd alias` command for manual alias control\n- `bd migrate --hash-ids` migration tool\n- Alias conflict resolution (deterministic, content-hash ordering)\n\n### Removed\n- ID collision detection and resolution (~2,100 LOC)\n- `bd import --resolve-collisions` flag (no longer needed)\n\n### Benefits\n- ✅ Zero ID collisions in distributed workflows\n- ✅ Simpler codebase (-1,350 net LOC)\n- ✅ Better git merge behavior\n- ✅ True offline-first operation\n```\n\n## Testing\n- Build docs locally (if using doc generator)\n- Check all links work\n- Verify examples are correct\n- Spellcheck\n\n## Files to Create/Modify\n- README.md (hash ID section)\n- AGENTS.md (workflow updates)\n- ADVANCED.md (internals)\n- MIGRATION.md (new)\n- CHANGELOG.md (v2.0 entry)\n- docs/ (any other docs)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T21:28:10.979971-07:00","updated_at":"2025-10-31T12:32:32.611114-07:00","closed_at":"2025-10-31T12:32:32.611114-07:00","dependencies":[{"issue_id":"bd-f8b764c9.12","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:28:10.981344-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.12","depends_on_id":"bd-f8b764c9.4","type":"blocks","created_at":"2025-10-29T21:28:10.981767-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.12","depends_on_id":"bd-f8b764c9.13","type":"blocks","created_at":"2025-10-29T21:28:10.982167-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.13","content_hash":"190b3d6ce773ffbd7240de9617cadceee4803e0484a1970f12782b2424529766","title":"Add bd alias command for manual alias control","description":"Add command for users to manually view and reassign aliases.\n\n## Command: bd alias\n\n### Subcommands\n\n#### 1. bd alias list\nShow all alias mappings:\n```bash\n$ bd alias list\n#1    → bd-af78e9a2  Fix authentication bug\n#2    → bd-e5f6a7b8  Add logging to daemon\n#42   → bd-1a2b3c4d  Investigate jujutsu integration\n#100  → bd-9a8b7c6d  (reassigned after conflict)\n```\n\n#### 2. bd alias set \u003calias\u003e \u003chash-id\u003e\nManually assign alias to specific issue:\n```bash\n$ bd alias set 42 bd-1a2b3c4d\n✓ Assigned alias #42 to bd-1a2b3c4d\n\n$ bd alias set 1 bd-af78e9a2\n✗ Error: Alias #1 already assigned to bd-e5f6a7b8\nUse --force to override\n```\n\n#### 3. bd alias compact\nRenumber all aliases to fill gaps:\n```bash\n$ bd alias compact [--dry-run]\n\nCurrent aliases: #1, #2, #5, #7, #100, #101\nAfter compacting: #1, #2, #3, #4, #5, #6\n\nRenumbering:\n  #5   → #3\n  #7   → #4\n  #100 → #5\n  #101 → #6\n\nApply changes? [y/N]\n```\n\n#### 4. bd alias reset\nRegenerate all aliases (sequential from 1):\n```bash\n$ bd alias reset [--sort-by=priority|created|id]\n\nWARNING: This will reassign ALL aliases. Continue? [y/N]\n\nReassigning 150 issues by priority:\n  bd-a1b2c3d4 → #1   (P0: Critical security bug)\n  bd-e5f6a7b8 → #2   (P0: Data loss fix)\n  bd-1a2b3c4d → #3   (P1: Jujutsu integration)\n  ...\n```\n\n#### 5. bd alias find \u003chash-id\u003e\nLook up alias for hash ID:\n```bash\n$ bd alias find bd-af78e9a2\n#1\n\n$ bd alias find bd-nonexistent\n✗ Error: Issue not found\n```\n\n## Use Cases\n\n### 1. Keep Important Issues Low-Numbered\n```bash\n# After closing many P0 issues, compact to free low numbers\nbd alias compact\n\n# Or manually set\nbd alias set 1 bd-\u003ccritical-bug-hash\u003e\n```\n\n### 2. Consistent Aliases Across Clones\n```bash\n# After migration, coordinator assigns canonical aliases\nbd alias reset --sort-by=id\ngit add .beads/aliases.jsonl\ngit commit -m \"Canonical alias assignments\"\ngit push\n\n# Other clones pull and adopt\ngit pull\nbd import  # Alias conflicts resolved automatically\n```\n\n### 3. Debug Alias Conflicts\n```bash\n# See which aliases were reassigned\nbd alias list | grep \"#100\"\n```\n\n## Flags\n\n### Global\n- `--dry-run`: Preview changes without applying\n- `--force`: Override existing alias assignments\n\n### bd alias reset\n- `--sort-by=priority`: Assign by priority (P0 first)\n- `--sort-by=created`: Assign by creation time (oldest first)\n- `--sort-by=id`: Assign by hash ID (lexicographic)\n\n## Implementation\n\nFile: cmd/bd/alias.go\n```go\nfunc aliasListCmd() *cobra.Command {\n    return \u0026cobra.Command{\n        Use:   \"list\",\n        Short: \"List all alias mappings\",\n        Run: func(cmd *cobra.Command, args []string) {\n            aliases := storage.GetAllAliases()\n            for _, a := range aliases {\n                fmt.Printf(\"#%-4d → %s  %s\\n\", \n                    a.Alias, a.IssueID, a.Title)\n            }\n        },\n    }\n}\n\nfunc aliasSetCmd() *cobra.Command {\n    return \u0026cobra.Command{\n        Use:   \"set \u003calias\u003e \u003chash-id\u003e\",\n        Short: \"Manually assign alias to issue\",\n        Args:  cobra.ExactArgs(2),\n        Run: func(cmd *cobra.Command, args []string) {\n            alias, _ := strconv.Atoi(args[0])\n            hashID := args[1]\n            \n            force, _ := cmd.Flags().GetBool(\"force\")\n            if err := storage.SetAlias(alias, hashID, force); err != nil {\n                fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n                os.Exit(1)\n            }\n            fmt.Printf(\"✓ Assigned alias #%d to %s\\n\", alias, hashID)\n        },\n    }\n}\n```\n\n## Files to Create\n- cmd/bd/alias.go\n\n## Testing\n- Test alias list output\n- Test alias set with/without force\n- Test alias compact removes gaps\n- Test alias reset with different sort orders\n- Test alias find lookup","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T21:26:53.751795-07:00","updated_at":"2025-10-31T12:32:32.611358-07:00","closed_at":"2025-10-31T12:32:32.611358-07:00","dependencies":[{"issue_id":"bd-f8b764c9.13","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:26:53.753259-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.13","depends_on_id":"bd-f8b764c9.7","type":"blocks","created_at":"2025-10-29T21:26:53.753733-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.13","depends_on_id":"bd-f8b764c9.6","type":"blocks","created_at":"2025-10-29T21:26:53.754112-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.2","content_hash":"cf15dbd5b7dbc10b54ea8d0d173899983bcdc0775b799e77c9334ec3f9fcba14","title":"Update MCP server for hash IDs","description":"Update beads-mcp server to support hash IDs and aliases.\n\n## Changes Needed\n\n### 1. MCP Function Signatures (No Change)\nFunctions already use issue IDs as strings, so they work with hash IDs:\n\n```python\n# These already work!\nbeads_show(issue_id: str)           # Accepts bd-af78e9a2 or #42\nbeads_update(issue_id: str, ...)    # Accepts both formats\nbeads_close(issue_ids: List[str])   # Accepts both formats\n```\n\n### 2. Add Alias Resolution Helper\nFile: integrations/beads-mcp/src/beads_mcp/server.py\n\n```python\ndef resolve_issue_id(issue_id: str) -\u003e str:\n    \"\"\"Resolve alias to hash ID if needed.\"\"\"\n    # Hash ID: pass through\n    if issue_id.startswith('bd-') and len(issue_id) == 11:\n        return issue_id\n    \n    # Alias: #42 or 42\n    alias_str = issue_id.lstrip('#')\n    try:\n        alias = int(alias_str)\n        # Call bd to resolve\n        result = subprocess.run(\n            ['bd', 'alias', 'find', f'bd-{alias}'],\n            capture_output=True, text=True\n        )\n        if result.returncode == 0:\n            return result.stdout.strip()\n    except ValueError:\n        pass\n    \n    # Invalid format\n    raise ValueError(f\"Invalid issue ID: {issue_id}\")\n```\n\n### 3. Update Response Formatting\nShow aliases in responses:\n\n```python\n@server.call_tool()\nasync def beads_show(issue_id: str) -\u003e List[TextContent]:\n    resolved_id = resolve_issue_id(issue_id)\n    \n    result = subprocess.run(['bd', 'show', resolved_id], ...)\n    \n    # Parse response and add alias info\n    # Format: \"bd-af78e9a2 (alias: #42)\"\n    ...\n```\n\n### 4. Add beads_alias_* Functions\n\n```python\n@server.call_tool()\nasync def beads_alias_list() -\u003e List[TextContent]:\n    \"\"\"List all alias mappings.\"\"\"\n    result = subprocess.run(['bd', 'alias', 'list'], ...)\n    return [TextContent(type=\"text\", text=result.stdout)]\n\n@server.call_tool()\nasync def beads_alias_set(alias: int, issue_id: str) -\u003e List[TextContent]:\n    \"\"\"Manually assign alias to issue.\"\"\"\n    result = subprocess.run(['bd', 'alias', 'set', str(alias), issue_id], ...)\n    return [TextContent(type=\"text\", text=result.stdout)]\n\n@server.call_tool()\nasync def beads_alias_compact() -\u003e List[TextContent]:\n    \"\"\"Compact aliases to fill gaps.\"\"\"\n    result = subprocess.run(['bd', 'alias', 'compact'], ...)\n    return [TextContent(type=\"text\", text=result.stdout)]\n```\n\n### 5. Update Documentation\nFile: integrations/beads-mcp/README.md\n\n```markdown\n## Issue IDs (v2.0+)\n\nThe MCP server accepts both hash IDs and aliases:\n\n```python\n# Using hash IDs\nawait beads_show(issue_id=\"bd-af78e9a2\")\n\n# Using aliases\nawait beads_show(issue_id=\"#42\")\nawait beads_show(issue_id=\"42\")  # Shorthand\n```\n\n## Alias Management\n\nNew functions for alias control:\n\n- `beads_alias_list()` - List all alias mappings\n- `beads_alias_set(alias, issue_id)` - Manually assign alias\n- `beads_alias_compact()` - Compact aliases to fill gaps\n\n## Migration\n\nAfter migrating to hash IDs:\n1. Update beads-mcp: `pip install --upgrade beads-mcp`\n2. Restart MCP server\n3. All existing workflows continue to work\n```\n\n### 6. Version Compatibility\nDetect and handle both v1.x and v2.0 formats:\n\n```python\ndef detect_beads_version() -\u003e str:\n    \"\"\"Detect if beads is using sequential or hash IDs.\"\"\"\n    result = subprocess.run(['bd', 'list', '-n', '1'], ...)\n    first_id = parse_first_issue_id(result.stdout)\n    \n    if first_id.startswith('bd-') and len(first_id) \u003e 11:\n        return '2.0'  # Hash ID\n    else:\n        return '1.x'  # Sequential ID\n\n# On startup\nbeads_version = detect_beads_version()\nlogger.info(f\"Detected beads version: {beads_version}\")\n```\n\n## Testing\n\n### Unit Tests\nFile: integrations/beads-mcp/tests/test_hash_ids.py\n\n```python\ndef test_resolve_hash_id():\n    \"\"\"Hash IDs pass through unchanged.\"\"\"\n    assert resolve_issue_id(\"bd-af78e9a2\") == \"bd-af78e9a2\"\n\ndef test_resolve_alias():\n    \"\"\"Aliases resolve to hash IDs.\"\"\"\n    # Mock bd alias find command\n    assert resolve_issue_id(\"#42\") == \"bd-af78e9a2\"\n    assert resolve_issue_id(\"42\") == \"bd-af78e9a2\"\n\ndef test_invalid_id():\n    \"\"\"Invalid IDs raise ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        resolve_issue_id(\"invalid\")\n```\n\n### Integration Tests\n```python\nasync def test_show_with_hash_id(mcp_server):\n    result = await mcp_server.beads_show(issue_id=\"bd-af78e9a2\")\n    assert \"bd-af78e9a2\" in result[0].text\n\nasync def test_show_with_alias(mcp_server):\n    result = await mcp_server.beads_show(issue_id=\"#42\")\n    assert \"bd-af78e9a2\" in result[0].text  # Resolved\n```\n\n## Backward Compatibility\nThe MCP server should work with both:\n- Beads v1.x (sequential IDs)\n- Beads v2.0+ (hash IDs)\n\nDetection happens at runtime based on issue ID format.\n\n## Files to Modify\n- integrations/beads-mcp/src/beads_mcp/server.py\n- integrations/beads-mcp/README.md\n- integrations/beads-mcp/tests/test_hash_ids.py (new)\n- integrations/beads-mcp/pyproject.toml (bump version)\n\n## Deployment\n```bash\ncd integrations/beads-mcp\n# Bump version to 2.0.0\npoetry version 2.0.0\n# Publish to PyPI\npoetry publish --build\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:28:45.256074-07:00","updated_at":"2025-10-31T12:32:32.60786-07:00","closed_at":"2025-10-31T12:32:32.60786-07:00","dependencies":[{"issue_id":"bd-f8b764c9.2","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:28:45.257315-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.2","depends_on_id":"bd-f8b764c9.7","type":"blocks","created_at":"2025-10-29T21:28:45.258057-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.3","content_hash":"56929e57c09610ede74cd5d6f9e8dfa71c74412183cc53e646f72a2324025ad0","title":"Test: N-clone scenario with hash IDs (no collisions)","description":"Comprehensive test to verify hash IDs eliminate collision problems.\n\n## Test: TestHashIDsNClones\n\n### Purpose\nVerify that N clones can work offline and sync without ID collisions using hash IDs.\n\n### Test Scenario\n```\nSetup:\n- 1 bare remote repo\n- 5 clones (A, B, C, D, E)\n\nOffline Work:\n- Each clone creates 10 issues with different titles\n- No coordination, no network access\n- Total: 50 unique issues\n\nSync:\n- Clones sync in random order\n- Each pull/import other clones' issues\n\nExpected Result:\n- All 5 clones converge to 50 issues\n- Zero ID collisions\n- Zero remapping needed\n- Alias conflicts resolved deterministically\n```\n\n### Implementation\nFile: cmd/bd/beads_hashid_test.go (new)\n\n```go\nfunc TestHashIDsFiveClones(t *testing.T) {\n    tmpDir := t.TempDir()\n    remoteDir := setupBareRepo(t, tmpDir)\n    \n    // Setup 5 clones\n    clones := make(map[string]string)\n    for _, name := range []string{\"A\", \"B\", \"C\", \"D\", \"E\"} {\n        clones[name] = setupClone(t, tmpDir, remoteDir, name)\n    }\n    \n    // Each clone creates 10 issues offline\n    for name, dir := range clones {\n        for i := 0; i \u003c 10; i++ {\n            createIssue(t, dir, fmt.Sprintf(\"%s-issue-%d\", name, i))\n        }\n        // No sync yet!\n    }\n    \n    // Sync in random order\n    syncOrder := []string{\"C\", \"A\", \"E\", \"B\", \"D\"}\n    for _, name := range syncOrder {\n        syncClone(t, clones[name], name)\n    }\n    \n    // Final convergence round\n    for _, name := range []string{\"A\", \"B\", \"C\", \"D\", \"E\"} {\n        finalPull(t, clones[name], name)\n    }\n    \n    // Verify all clones have all 50 issues\n    for name, dir := range clones {\n        issues := getIssues(t, dir)\n        if len(issues) != 50 {\n            t.Errorf(\"Clone %s: expected 50 issues, got %d\", name, len(issues))\n        }\n        \n        // Verify all issue IDs are hash-based\n        for _, issue := range issues {\n            if !strings.HasPrefix(issue.ID, \"bd-\") || len(issue.ID) != 11 {\n                t.Errorf(\"Invalid hash ID: %s\", issue.ID)\n            }\n        }\n    }\n    \n    // Verify no collision resolution occurred\n    // (This would be in logs if it happened)\n    \n    t.Log(\"✓ All 5 clones converged to 50 issues with zero collisions\")\n}\n```\n\n### Edge Case Tests\n\n#### Test: Hash Collision Detection (Artificial)\n```go\nfunc TestHashCollisionDetection(t *testing.T) {\n    // Artificially inject collision by mocking hash function\n    // Verify system detects and handles it\n}\n```\n\n#### Test: Alias Conflicts Resolved Deterministically\n```go\nfunc TestAliasConflictsNClones(t *testing.T) {\n    // Two clones assign same alias to different issues\n    // Verify deterministic resolution (content-hash ordering)\n    // Verify all clones converge to same alias assignments\n}\n```\n\n#### Test: Mixed Sequential and Hash IDs (Should Fail)\n```go\nfunc TestMixedIDsRejected(t *testing.T) {\n    // Try to import JSONL with sequential IDs into hash-ID database\n    // Verify error or warning\n}\n```\n\n### Performance Test\n\n#### Benchmark: Hash ID Generation\n```go\nfunc BenchmarkHashIDGeneration(b *testing.B) {\n    for i := 0; i \u003c b.N; i++ {\n        GenerateHashID(\"title\", \"description\", time.Now(), \"workspace-id\")\n    }\n}\n\n// Expected: \u003c 1μs per generation\n```\n\n#### Benchmark: N-Clone Convergence Time\n```go\nfunc BenchmarkNCloneConvergence(b *testing.B) {\n    for _, n := range []int{3, 5, 10, 20} {\n        b.Run(fmt.Sprintf(\"N=%d\", n), func(b *testing.B) {\n            // Measure total convergence time\n        })\n    }\n}\n\n// Expected: Linear scaling O(N)\n```\n\n### Acceptance Criteria\n- TestHashIDsFiveClones passes reliably (10/10 runs)\n- Zero ID collisions in any scenario\n- All clones converge in single round (not multi-round like old system)\n- Alias conflicts resolved deterministically\n- Performance benchmarks meet targets (\u003c1μs hash gen)\n\n## Files to Create\n- cmd/bd/beads_hashid_test.go\n\n## Comparison to Old System\nThis test replaces:\n- TestTwoCloneCollision (bd-71107098) - no longer needed\n- TestThreeCloneCollision (bd-cbed9619) - no longer needed\n- TestFiveCloneCollision (bd-a40f374f) - no longer needed\n\nOld system required complex collision resolution and multi-round convergence.\nNew system: single-round convergence with zero collisions.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:27:26.954107-07:00","updated_at":"2025-10-31T12:32:32.608225-07:00","closed_at":"2025-10-31T12:32:32.608225-07:00","dependencies":[{"issue_id":"bd-f8b764c9.3","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:27:26.955522-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.3","depends_on_id":"bd-f8b764c9.5","type":"blocks","created_at":"2025-10-29T21:27:26.956175-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.4","content_hash":"5c3a805d030dbbcc44e33d28c39d6acb98086ea26ab7f5405c0138e29b1d58dd","title":"Migration tool: sequential → hash IDs","description":"Create migration tool to convert existing sequential-ID databases to hash-ID format.\n\n## Command: bd migrate --hash-ids\n\n```bash\nbd migrate --hash-ids [--dry-run]\n```\n\n## Migration Process\n\n### 1. Backup Database\n```bash\ncp .beads/beads.db .beads/beads.db.backup-1761798384\necho \"✓ Backup created: .beads/beads.db.backup-1234567890\"\n```\n\n### 2. Generate Hash IDs for Existing Issues\n```go\nfunc migrateToHashIDs(db *SQLiteStorage) error {\n    // Read all issues\n    issues, err := db.ListIssues(ctx, ListOptions{Status: \"all\"})\n    \n    // Generate mapping: old ID → new hash ID\n    mapping := make(map[string]string)\n    for _, issue := range issues {\n        hashID := GenerateHashID(\n            issue.Title,\n            issue.Description,\n            issue.CreatedAt,\n            db.workspaceID,\n        )\n        mapping[issue.ID] = hashID\n    }\n    \n    // Detect hash collisions (extremely rare)\n    if hasCollisions(mapping) {\n        return fmt.Errorf(\"hash collision detected, aborting\")\n    }\n    \n    return nil\n}\n```\n\n### 3. Update Database Schema\n```sql\n-- Add alias column\nALTER TABLE issues ADD COLUMN alias INTEGER UNIQUE;\n\n-- Populate aliases from old IDs\nUPDATE issues SET alias = CAST(SUBSTR(id, 4) AS INTEGER)\n  WHERE id LIKE 'bd-%' AND SUBSTR(id, 4) GLOB '[0-9]*';\n\n-- Create new issues_new table with hash IDs\nCREATE TABLE issues_new (\n    id TEXT PRIMARY KEY,  -- Hash IDs now\n    alias INTEGER UNIQUE,\n    title TEXT NOT NULL,\n    -- ... rest of schema\n);\n\n-- Copy data with ID mapping\nINSERT INTO issues_new SELECT \n    \u003cnew_hash_id\u003e,  -- From mapping\n    alias,\n    title,\n    -- ...\nFROM issues;\n\n-- Drop old table, rename new\nDROP TABLE issues;\nALTER TABLE issues_new RENAME TO issues;\n```\n\n### 4. Update Dependencies\n```sql\n-- Update depends_on_id using mapping\nUPDATE dependencies \nSET issue_id = \u003cnew_hash_id\u003e,\n    depends_on_id = \u003cnew_depends_on_hash_id\u003e\nFROM mapping;\n```\n\n### 5. Update Text References\n```go\n// Update all text fields that mention old IDs\nfunc updateTextReferences(db *SQLiteStorage, mapping map[string]string) error {\n    for oldID, newID := range mapping {\n        // Update description, notes, design, acceptance_criteria\n        db.Exec(`UPDATE issues SET \n            description = REPLACE(description, ?, ?),\n            notes = REPLACE(notes, ?, ?),\n            design = REPLACE(design, ?, ?),\n            acceptance_criteria = REPLACE(acceptance_criteria, ?, ?)\n        `, oldID, newID, oldID, newID, oldID, newID, oldID, newID)\n    }\n}\n```\n\n### 6. Export to JSONL\n```bash\nbd export  # Writes hash IDs to .beads/issues.jsonl\ngit add .beads/issues.jsonl\ngit commit -m \"Migrate to hash-based IDs\"\n```\n\n## Output\n```bash\n$ bd migrate --hash-ids\nMigrating to hash-based IDs...\n✓ Backup created: .beads/beads.db.backup-1730246400\n✓ Generated 150 hash IDs\n✓ No hash collisions detected\n✓ Updated issues table schema\n✓ Updated 150 issue IDs\n✓ Updated 87 dependencies\n✓ Updated 234 text references\n✓ Exported to .beads/issues.jsonl\n✓ Migration complete!\n\nNext steps:\n  1. Test: bd list, bd show #1, etc.\n  2. Commit: git commit -m \"Migrate to hash-based IDs\"\n  3. Push: git push origin main\n  4. Notify collaborators to pull and re-init\n```\n\n## Dry Run Mode\n```bash\n$ bd migrate --hash-ids --dry-run\n[DRY RUN] Would migrate 150 issues:\n  bd-1c63eb84   → bd-af78e9a2  (alias: #1)\n  bd-9063acda   → bd-e5f6a7b8  (alias: #2)\n  ...\n  bd-150 → bd-9a8b7c6d  (alias: #150)\n\n[DRY RUN] Would update:\n  - 150 issue IDs\n  - 87 dependencies\n  - 234 text references in descriptions/notes\n\nNo changes made. Run without --dry-run to apply.\n```\n\n## Files to Create\n- cmd/bd/migrate.go (new command)\n- internal/storage/sqlite/migrations/hash_ids.go\n\n## Testing\n- Test migration on small database (10 issues)\n- Test migration on large database (1000 issues)\n- Test hash collision detection (inject collision artificially)\n- Test text reference updates\n- Test rollback (restore from backup)\n- Test migrated database works correctly\n\n## Rollback Procedure\n```bash\n# If migration fails or has issues\nmv .beads/beads.db.backup-1234567890 .beads/beads.db\nbd export  # Restore JSONL from backup DB\n```\n\n## Multi-Clone Coordination\n**Important**: All clones must migrate before syncing:\n\n1. Coordinator sends message: \"Migrating to hash IDs on 2025-10-30 at 10:00 UTC\"\n2. All collaborators pull latest changes\n3. All run: `bd migrate --hash-ids`\n4. All push changes\n5. New work can continue with hash IDs\n\n**Do NOT**:\n- Mix sequential and hash IDs in same database\n- Sync before all clones migrate","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:26:24.563993-07:00","updated_at":"2025-10-31T12:32:32.608574-07:00","closed_at":"2025-10-31T12:32:32.608574-07:00","dependencies":[{"issue_id":"bd-f8b764c9.4","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:26:24.565325-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.4","depends_on_id":"bd-f8b764c9.9","type":"blocks","created_at":"2025-10-29T21:26:24.565945-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.5","content_hash":"cb24777a804129f91ae8d96937c762ba4877e2a0273d389d099f678ed2080a54","title":"Delete collision resolution code","description":"Remove ~2,100 LOC of ID collision detection and resolution code (no longer needed with hash IDs).\n\n## Files to Delete Entirely\n```\ninternal/storage/sqlite/collision.go              (~800 LOC)\ninternal/storage/sqlite/collision_test.go         (~300 LOC)\ncmd/bd/autoimport_collision_test.go               (~400 LOC)\n```\n\n## Code to Remove from Existing Files\n\n### internal/importer/importer.go\nRemove:\n- `DetectCollisions()` calls\n- `ScoreCollisions()` logic\n- `RemapCollisions()` calls\n- `handleRename()` function\n- All collision-related error handling\n\nKeep:\n- Basic import logic\n- Exact match detection (idempotent import)\n\n### beads_twoclone_test.go\nRemove:\n- `TestTwoCloneCollision` (bd-71107098)\n- `TestThreeCloneCollision` (bd-cbed9619)\n- `TestFiveCloneCollision` (bd-a40f374f)\n- All N-way collision tests\n\n### cmd/bd/import.go\nRemove:\n- `--resolve-collisions` flag\n- `--dry-run` collision preview\n- Collision reporting\n\n## Issues Closed by This Change\n- bd-71107098: Add test for symmetric collision\n--89: Content-hash collision resolution\n- bd-cbed9619: N-way collision resolution epic\n- bd-cbed9619.5: Add ScoreCollisions (already done but now unnecessary)\n- bd-cbed9619.4: Make DetectCollisions read-only\n- bd-cbed9619.3: ResolveNWayCollisions function\n- bd-cbed9619.2: Multi-round import convergence\n- bd-cbed9619.1: Multi-round convergence for N-way collisions\n- bd-e6d71828: Transaction + retry logic for collisions\n- bd-70419816: Test case for symmetric collision\n\n## Verification Steps\n1. `grep -r \"collision\" --include=\"*.go\"` → should only find alias conflicts\n2. `go test ./...` → all tests pass\n3. `go build ./cmd/bd` → clean build\n4. Check LOC reduction: `git diff --stat`\n\n## Expected Metrics\n- **Files deleted**: 3\n- **LOC removed**: ~2,100\n- **Test coverage**: Should increase (less untested code)\n- **Binary size**: Slightly smaller\n\n## Caution\nDo NOT delete:\n- Alias conflict resolution (new code in bd-f8b764c9.6)\n- Duplicate detection (bd-581b80b3, bd-149) - different from ID collisions\n- Merge conflict resolution (bd-7e7ddffa.1, bd-5f483051) - git conflicts, not ID collisions\n\n## Files to Modify\n- internal/importer/importer.go (remove collision handling)\n- cmd/bd/import.go (remove --resolve-collisions flag)\n- beads_twoclone_test.go (remove collision tests)\n- Delete: internal/storage/sqlite/collision.go\n- Delete: internal/storage/sqlite/collision_test.go  \n- Delete: cmd/bd/autoimport_collision_test.go\n\n## Testing\n- Ensure all remaining tests pass\n- Manual test: create issue on two clones, sync → no collisions\n- Verify error if somehow hash collision occurs (extremely unlikely)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:25:50.976383-07:00","updated_at":"2025-10-31T12:32:32.608942-07:00","closed_at":"2025-10-31T12:32:32.608942-07:00","dependencies":[{"issue_id":"bd-f8b764c9.5","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:25:50.977857-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.5","depends_on_id":"bd-f8b764c9.9","type":"blocks","created_at":"2025-10-29T21:25:50.978395-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.5","depends_on_id":"bd-f8b764c9.8","type":"blocks","created_at":"2025-10-29T21:25:50.978842-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.6","content_hash":"ce799a029bab632dd71cc6935ec0f8da8c6b49d9d766760645f7af7c7d06d60b","title":"Implement alias conflict resolution","description":"Handle alias conflicts when multiple clones assign same alias to different issues.\n\n## Scenario\n```\nClone A: Creates bd-a1b2c3d4, assigns alias #42\nClone B: Creates bd-e5f6a7b8, assigns alias #42\nAfter sync: Conflict! Which issue gets #42?\n```\n\n## Resolution Strategy: Content-Hash Ordering\nDeterministic, same result on all clones:\n```go\nfunc ResolveAliasConflicts(conflicts []AliasConflict) []AliasRemapping {\n    for _, conflict := range conflicts {\n        // Sort by hash ID (lexicographic)\n        sort.Strings(conflict.IssueIDs)\n        \n        // Winner: lowest hash ID (arbitrary but deterministic)\n        winner := conflict.IssueIDs[0]\n        \n        // Losers: reassign to next available aliases\n        for _, loser := range conflict.IssueIDs[1:] {\n            newAlias := getNextAlias()\n            remappings = append(remappings, AliasRemapping{\n                IssueID:  loser,\n                OldAlias: conflict.Alias,\n                NewAlias: newAlias,\n            })\n        }\n    }\n    return remappings\n}\n```\n\n## Detection During Import\nFile: internal/importer/importer.go\n```go\nfunc handleAliasConflicts(imported []Issue, existing []Issue) error {\n    // Build alias map from imported issues\n    aliasMap := make(map[int][]string)  // alias → issue IDs\n    \n    for _, issue := range imported {\n        aliasMap[issue.Alias] = append(aliasMap[issue.Alias], issue.ID)\n    }\n    \n    // Check against existing aliases\n    for alias, importedIDs := range aliasMap {\n        existingID := storage.GetIssueIDByAlias(alias)\n        if existingID != \"\" {\n            // Conflict! Resolve it\n            allIDs := append(importedIDs, existingID)\n            conflicts = append(conflicts, AliasConflict{\n                Alias:    alias,\n                IssueIDs: allIDs,\n            })\n        }\n    }\n    \n    // Resolve and apply\n    remappings := ResolveAliasConflicts(conflicts)\n    applyAliasRemappings(remappings)\n}\n```\n\n## Alternative Strategies (For Future Consideration)\n\n### Priority-Based\n```go\n// Higher priority keeps alias\nif issueA.Priority \u003c issueB.Priority {\n    winner = issueA\n}\n```\n\n### Timestamp-Based (Last-Write-Wins)\n```go\n// Newer issue keeps alias\nif issueA.UpdatedAt.After(issueB.UpdatedAt) {\n    winner = issueA\n}\n```\n\n### Manual Resolution\n```bash\nbd resolve-aliases --manual\n# Interactive prompt for each conflict\n```\n\n## User Notification\n```bash\n$ bd sync\n✓ Synced 5 issues\n⚠ Alias conflicts resolved:\n  - Issue bd-e5f6a7b8: alias changed from #42 to #100\n  - Issue bd-9a8b7c6d: alias changed from #15 to #101\n```\n\n## Files to Create/Modify\n- internal/storage/sqlite/alias_conflicts.go (new)\n- internal/importer/importer.go (detect conflicts)\n- cmd/bd/sync.go (show conflict notifications)\n\n## Testing\n- Test two clones assign same alias to different issues\n- Test conflict resolution is deterministic (same on all clones)\n- Test loser gets new alias\n- Test winner keeps original alias\n- Test multiple conflicts resolved in one import","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:25:27.389191-07:00","updated_at":"2025-10-31T12:32:32.609245-07:00","closed_at":"2025-10-31T12:32:32.609245-07:00","dependencies":[{"issue_id":"bd-f8b764c9.6","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:25:27.390611-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.6","depends_on_id":"bd-f8b764c9.10","type":"blocks","created_at":"2025-10-29T21:25:27.391127-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.6","depends_on_id":"bd-f8b764c9.8","type":"blocks","created_at":"2025-10-29T21:25:27.39154-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.7","content_hash":"0cd1edbd677f73f3a21e571709eca026db7c6e0d158a3d41d7c4e37deb8bc4c2","title":"CLI accepts both hash IDs and aliases","description":"Update all CLI commands to accept both hash IDs (bd-af78e9a2) and aliases (#42, or just 42).\n\n## Parsing Logic\n```go\n// internal/utils/id_parser.go\nfunc ParseIssueID(input string) (issueID string, err error) {\n    // Hash ID: bd-af78e9a2\n    if strings.HasPrefix(input, \"bd-\") {\n        return input, nil\n    }\n    \n    // Alias: #42 or 42\n    aliasStr := strings.TrimPrefix(input, \"#\")\n    alias, err := strconv.Atoi(aliasStr)\n    if err != nil {\n        return \"\", fmt.Errorf(\"invalid issue ID: %s\", input)\n    }\n    \n    // Resolve alias to hash ID\n    return storage.GetIssueIDByAlias(alias)\n}\n```\n\n## Commands to Update\nAll commands that accept issue IDs:\n\n### 1. bd show\n```bash\nbd show bd-af78e9a2        # Hash ID\nbd show #42                # Alias\nbd show 42                 # Alias (shorthand)\nbd show bd-af78e9a2 #42    # Mixed (multiple IDs)\n```\n\n### 2. bd update\n```bash\nbd update #42 --status in_progress\nbd update bd-af78e9a2 --priority 1\n```\n\n### 3. bd close\n```bash\nbd close #42 --reason \"Done\"\n```\n\n### 4. bd dep add/tree\n```bash\nbd dep add #42 #1 --type blocks\nbd dep tree bd-af78e9a2\n```\n\n### 5. bd label add/remove\n```bash\nbd label add #42 critical\n```\n\n### 6. bd merge\n```bash\nbd merge #42 #43 --into #41\n```\n\n## Display Format\nDefault to showing aliases in output:\n```bash\n$ bd list\n#1   Fix authentication bug          P1  open\n#2   Add logging to daemon           P2  open  \n#42  Investigate jujutsu integration P3  open\n```\n\nWith `--format=hash` flag:\n```bash\n$ bd list --format=hash\nbd-af78e9a2  Fix authentication bug          P1  open\nbd-e5f6a7b8  Add logging to daemon           P2  open\nbd-1a2b3c4d  Investigate jujutsu integration P3  open\n```\n\n## Files to Modify\n- internal/utils/id_parser.go (new)\n- cmd/bd/show.go\n- cmd/bd/update.go\n- cmd/bd/close.go\n- cmd/bd/reopen.go\n- cmd/bd/dep.go\n- cmd/bd/label.go\n- cmd/bd/merge.go\n- cmd/bd/list.go (add --format flag)\n\n## Testing\n- Test hash ID parsing\n- Test alias parsing (#42, 42)\n- Test mixed IDs in single command\n- Test error on invalid ID\n- Test alias resolution failure","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:25:06.256317-07:00","updated_at":"2025-10-31T12:32:32.609634-07:00","closed_at":"2025-10-31T12:32:32.609634-07:00","dependencies":[{"issue_id":"bd-f8b764c9.7","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:25:06.257796-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.7","depends_on_id":"bd-f8b764c9.10","type":"blocks","created_at":"2025-10-29T21:25:06.258307-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.7","depends_on_id":"bd-f8b764c9.8","type":"blocks","created_at":"2025-10-29T21:29:45.993274-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.8","content_hash":"d047b706654f9e5b0cc59fde73e88fed242932c3c024d90af22327a5c2f2fced","title":"Update JSONL format to use hash IDs","description":"Update JSONL import/export to use hash IDs, store aliases separately.\n\n## Current JSONL Format\n```jsonl\n{\"id\":\"bd-1c63eb84\",\"title\":\"Fix bug\",\"status\":\"open\",...}\n{\"id\":\"bd-9063acda\",\"title\":\"Add test\",\"status\":\"open\",...}\n```\n\n## New JSONL Format (Option A: Include Alias)\n```jsonl\n{\"id\":\"bd-af78e9a2\",\"alias\":1,\"title\":\"Fix bug\",\"status\":\"open\",...}\n{\"id\":\"bd-e5f6a7b8\",\"alias\":2,\"title\":\"Add test\",\"status\":\"open\",...}\n```\n\n## New JSONL Format (Option B: Hash ID Only)\n```jsonl\n{\"id\":\"bd-af78e9a2\",\"title\":\"Fix bug\",\"status\":\"open\",...}\n{\"id\":\"bd-e5f6a7b8\",\"title\":\"Add test\",\"status\":\"open\",...}\n```\n\nStore aliases in separate .beads/aliases.jsonl (local only, git-ignored):\n```jsonl\n{\"hash\":\"bd-af78e9a2\",\"alias\":1}\n{\"hash\":\"bd-e5f6a7b8\",\"alias\":2}\n```\n\n**Recommendation**: Option B (hash only in main JSONL)\n- Cleaner git diffs (no alias conflicts)\n- Aliases are workspace-local preference\n- Main JSONL is canonical, portable\n\n## Export Changes\nFile: cmd/bd/export.go\n```go\n// Export issues with hash IDs\nfor _, issue := range issues {\n    json := marshalIssue(issue)  // Uses issue.ID (hash)\n    // Don't include alias in JSONL\n}\n\n// Separately export aliases to .beads/aliases.jsonl\nexportAliases(issues)\n```\n\n## Import Changes  \nFile: cmd/bd/import.go, internal/importer/importer.go\n```go\n// Import issues by hash ID\nissue := unmarshalIssue(line)\n// Assign new alias on import (don't use incoming alias)\nissue.Alias = getNextAlias()\n\n// No collision detection needed! Hash IDs are globally unique\n```\n\n## Dependency Reference Format\nNo change needed - already uses issue IDs:\n```json\n{\"depends_on_id\":\"bd-af78e9a2\",\"type\":\"blocks\"}\n```\n\n## Files to Modify\n- cmd/bd/export.go (use hash IDs)\n- cmd/bd/import.go (import hash IDs, assign aliases)\n- internal/importer/importer.go (remove collision detection!)\n- .gitignore (add .beads/aliases.jsonl)\n\n## Testing\n- Test export produces hash IDs\n- Test import assigns new aliases\n- Test dependencies preserved with hash IDs\n- Test no collision detection triggered","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:24:47.408106-07:00","updated_at":"2025-10-31T12:32:32.609925-07:00","closed_at":"2025-10-31T12:32:32.609925-07:00","dependencies":[{"issue_id":"bd-f8b764c9.8","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:24:47.409489-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.8","depends_on_id":"bd-f8b764c9.9","type":"blocks","created_at":"2025-10-29T21:24:47.409977-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.8","depends_on_id":"bd-f8b764c9.10","type":"blocks","created_at":"2025-10-29T21:29:45.975499-07:00","created_by":"stevey"}]}
{"id":"bd-f8b764c9.9","content_hash":"5b040bec47ef5353a04d90d73ac8237f0302137c27ef7f6bfc84379b84cbb7ec","title":"Implement hash ID generation in CreateIssue","description":"Replace sequential ID generation with hash-based IDs in CreateIssue function.\n\n## Current Behavior (internal/storage/sqlite/sqlite.go)\n```go\nfunc (s *SQLiteStorage) CreateIssue(ctx context.Context, issue *types.Issue) error {\n    // ID comes from auto-increment counter\n    // Collisions possible across clones\n}\n```\n\n## New Behavior\n```go\nfunc (s *SQLiteStorage) CreateIssue(ctx context.Context, issue *types.Issue) error {\n    // Generate hash ID if not provided\n    if issue.ID == \"\" {\n        issue.ID = idgen.GenerateHashID(\n            issue.Title,\n            issue.Description,\n            time.Now(),\n            s.workspaceID,\n        )\n    }\n    \n    // Assign next alias\n    issue.Alias = s.getNextAlias()\n    \n    // Insert with hash ID + alias\n    // ...\n}\n```\n\n## Workspace ID Generation\nAdd to database initialization:\n```go\n// Generate stable workspace ID (persisted in .beads/workspace_id)\nworkspaceID := getOrCreateWorkspaceID()\n```\n\nOptions for workspace ID:\n1. Hostname + random suffix\n2. UUID (random)\n3. Git remote URL hash (deterministic per repo)\n\nRecommended: Option 3 (git remote hash) for reproducibility\n\n## Hash Collision Detection\n```go\n// On insert, check for collision (unlikely but possible)\nexisting, err := s.GetIssue(ctx, issue.ID)\nif err == nil {\n    // Hash collision! Add random suffix and retry\n    issue.ID = issue.ID + \"-\" + randomSuffix(4)\n}\n```\n\n## Files to Create/Modify\n- internal/types/id_generator.go (new)\n- internal/storage/sqlite/sqlite.go (CreateIssue)\n- internal/storage/sqlite/workspace.go (new - workspace ID management)\n- .beads/workspace_id (new file, git-ignored)\n\n## Testing\n- Test hash ID generation is deterministic\n- Test collision detection and retry\n- Test workspace ID persistence\n- Benchmark: hash generation performance (\u003c1μs)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-29T21:24:29.412237-07:00","updated_at":"2025-10-31T12:32:32.610403-07:00","closed_at":"2025-10-31T12:32:32.610403-07:00","dependencies":[{"issue_id":"bd-f8b764c9.9","depends_on_id":"bd-f8b764c9","type":"parent-child","created_at":"2025-10-29T21:24:29.413417-07:00","created_by":"stevey"},{"issue_id":"bd-f8b764c9.9","depends_on_id":"bd-f8b764c9.11","type":"blocks","created_at":"2025-10-29T21:24:29.413823-07:00","created_by":"stevey"}]}
{"id":"bd-fb95094c","content_hash":"99f456d7a5d3a4288c3f60dd65212480c54d3b0161e57d7eccffe01875d2eb5e","title":"Code Health \u0026 Technical Debt Cleanup","description":"Comprehensive codebase cleanup to remove dead code, refactor monolithic files, deduplicate utilities, and improve maintainability. Based on ultrathink code health analysis conducted 2025-10-27.\n\nGoals:\n- Remove ~1,500 LOC of dead/unreachable code\n- Split 2 monolithic files (server.go 2,273 LOC, sqlite.go 2,136 LOC) into focused modules\n- Deduplicate scattered utility functions (normalizeLabels, BD_DEBUG checks)\n- Consolidate test coverage (2,019 LOC of collision tests)\n- Improve code navigation and reduce merge conflicts\n\nImpact: Reduces codebase by ~6-8%, improves maintainability, faster CI/CD\n\nEstimated Effort: 11 days across 4 phases","acceptance_criteria":"- All unreachable code identified by `deadcode` analyzer is removed\n- RPC server split into \u003c500 LOC files with clear responsibilities\n- Duplicate utility functions centralized\n- Test coverage maintained or improved\n- All tests passing\n- Documentation updated","status":"open","priority":2,"issue_type":"epic","created_at":"2025-10-27T20:39:22.22227-07:00","updated_at":"2025-10-30T17:12:58.210295-07:00","labels":["cleanup","epic"]}
{"id":"bd-fb95094c.1","content_hash":"d28bd9b00ae5586a782aec012344d1c29eec3bc9fdfa06d5804984a3b3c78e4f","title":"Run final validation and cleanup checks","description":"Final validation pass to ensure all cleanup objectives met and no regressions introduced.\n\nValidation checklist:\n1. Dead code verification: `go run golang.org/x/tools/cmd/deadcode@latest -test ./...`\n2. Test coverage: `go test -cover ./...`\n3. Build verification: `go build ./cmd/bd/`\n4. Linting: `golangci-lint run`\n5. Integration tests\n6. Metrics verification\n7. Git clean check\n\nFinal metrics to report:\n- LOC removed: ~____\n- Files deleted: ____\n- Files created: ____\n- Test coverage: ____%\n- Build time: ____ (before/after)\n- Test run time: ____ (before/after)\n\nImpact: Confirms all cleanup objectives achieved successfully","acceptance_criteria":"- Zero unreachable functions per deadcode analyzer\n- All tests pass: `go test ./...`\n- Test coverage maintained or improved\n- Builds cleanly: `go build ./...`\n- Linting shows improvements\n- Integration tests all pass\n- LOC reduction target achieved (~2,500 LOC)\n- No unintended behavior changes\n- Git commit messages document all changes","notes":"Validation completed:\n- LOC: 52,372 lines total\n- Dead code: 4 functions in import_shared.go (tracked in bd-6fe4622f)\n- Build: ✓ Successful\n- Test coverage: ~20-82% across packages\n- Test failure: TestTwoCloneCollision (timeout issue)\n- Linting: errcheck warnings present (defer close, fmt errors)\n- Test time: ~20s\n\nIssues found:\n1. bd-6fe4622f: Remove unreachable import functions (renameImportedIssuePrefixes, etc)\n2. TestTwoCloneCollision: Daemon killall timeout causing test failure\n3. Linting: errcheck violations need fixing","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T20:32:00.14166-07:00","updated_at":"2025-10-30T17:12:58.209988-07:00","closed_at":"2025-10-28T14:11:25.218801-07:00","labels":["phase-4","validation"],"dependencies":[{"issue_id":"bd-fb95094c.1","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:32:00.144113-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.10","content_hash":"0d499f79a6336ca36c7e459e3393cd7cfe471d184e5e443fa9757a22740744ab","title":"Consider central serialization package for JSON handling","description":"Multiple parts of the codebase handle JSON serialization of issues with slightly different approaches. Consider creating a centralized serialization package to ensure consistency.\n\nCurrent serialization locations:\n- `cmd/bd/export.go` - JSONL export (issues to file)\n- `cmd/bd/import.go` - JSONL import (file to issues)\n- `internal/rpc/protocol.go` - RPC JSON marshaling\n- `internal/storage/memory/memory.go` - In-memory marshaling\n\nPotential benefits:\n- Single source of truth for JSON format\n- Consistent field naming\n- Easier to add new fields\n- Centralized validation\n\nNote: This is marked **optional** because:\n- Current serialization mostly works\n- May not provide enough benefit to justify refactor\n- Risk of breaking compatibility\n\nDecision point: Evaluate if benefits outweigh refactoring cost\n\nImpact: TBD based on investigation - may defer to future work","acceptance_criteria":"- Create serialization package with documented JSON format\n- Migrate export/import to use centralized serialization\n- All existing JSONL files can be read with new code\n- All tests pass: `go test ./...`\n- Export/import round-trip works perfectly\n- RPC protocol unchanged (or backwards compatible)","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-27T20:31:19.090608-07:00","updated_at":"2025-10-30T17:12:58.208871-07:00","labels":["deduplication","optional","phase-3","refactor","serialization"],"dependencies":[{"issue_id":"bd-fb95094c.10","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:31:19.092328-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.2","content_hash":"685c91a6de8e1610feb5dbda18412f3eee178a37064d9ddf55511fb693dec9ba","title":"Delete skipped tests for \"old buggy behavior\"","description":"Three test functions are permanently skipped with comments indicating they test behavior that was fixed in GH#120. These tests will never run again and should be deleted.\n\nTest functions to remove:\n\n1. `cmd/bd/import_collision_test.go:228`\n   ```go\n   t.Skip(\"Test expects old buggy behavior - needs rewrite for GH#120 fix\")\n   ```\n\n2. `cmd/bd/import_collision_test.go:505`\n   ```go\n   t.Skip(\"Test expects old buggy behavior - needs rewrite for GH#120 fix\")\n   ```\n\n3. `internal/storage/sqlite/collision_test.go:919`\n   ```go\n   t.Skip(\"Test expects old buggy behavior - needs rewrite for GH#120 fix\")\n   ```\n\nImpact: Removes ~150 LOC of permanently skipped tests","acceptance_criteria":"- Delete the 3 test functions entirely (~150 LOC total)\n- Update test file comments to reference GH#120 fix if needed\n- All remaining tests pass: `go test ./...`\n- No reduction in meaningful test coverage (these test fixed bugs)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-27T20:30:19.961185-07:00","updated_at":"2025-10-30T17:12:58.196387-07:00","closed_at":"2025-10-28T14:09:21.642632-07:00","labels":["cleanup","dead-code","phase-1","test-cleanup"],"dependencies":[{"issue_id":"bd-fb95094c.2","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:30:19.962815-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.3","content_hash":"7c3b871ac8f2041b1a2f9e2096d4328d5d388728c392f18c727c6b3f39242c92","title":"Update documentation after code health cleanup","description":"Update all documentation to reflect code structure changes after cleanup phases complete.\n\nDocumentation to update:\n1. **AGENTS.md** - Update file structure references\n2. **CONTRIBUTING.md** (if exists) - Update build/test instructions\n3. **Code comments** - Update any outdated references\n4. **Package documentation** - Update godoc for reorganized packages\n\nNew documentation to add:\n1. **internal/util/README.md** - Document shared utilities\n2. **internal/debug/README.md** - Document debug logging\n3. **internal/rpc/README.md** - Document new file organization\n4. **internal/storage/sqlite/migrations/README.md** - Migration system docs\n\nImpact: Keeps documentation in sync with code","acceptance_criteria":"- All documentation references to deleted files removed\n- New package READMEs written\n- Code comments updated for reorganized code\n- Migration guide for developers (if needed)\n- Architecture diagrams updated (if they exist)","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-27T20:32:00.141028-07:00","updated_at":"2025-10-30T17:12:58.209614-07:00","labels":["documentation","phase-4"],"dependencies":[{"issue_id":"bd-fb95094c.3","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:32:00.1423-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.4","content_hash":"0ef6c61539f399e3a94386a3eaa3eb7e38c49d1fb9a807004c30ab5e7e01228a","title":"Audit and consolidate collision test coverage","description":"The codebase has 2,019 LOC of collision detection tests across 3 files. Run coverage analysis to identify redundant test cases and consolidate.\n\nTest files:\n- `cmd/bd/import_collision_test.go` - 974 LOC\n- `cmd/bd/autoimport_collision_test.go` - 750 LOC\n- `cmd/bd/import_collision_regression_test.go` - 295 LOC\n\nTotal: 2,019 LOC of collision tests\n\nAnalysis steps:\n1. Run coverage analysis\n2. Identify redundant tests\n3. Document findings\n\nConsolidation strategy:\n- Keep regression tests for critical bugs\n- Merge overlapping table-driven tests\n- Remove redundant edge case tests covered elsewhere\n- Ensure all collision scenarios still tested\n\nExpected outcome: Reduce to ~1,200 LOC (save ~800 lines) while maintaining coverage\n\nImpact: Faster test runs, easier maintenance, clearer test intent","acceptance_criteria":"- Coverage analysis completed and documented\n- Redundant tests identified (~800 LOC estimated)\n- Consolidated test suite maintains or improves coverage\n- All remaining tests pass: `go test ./cmd/bd/...`\n- Test run time unchanged or faster\n- Document which tests were removed and why\n- Coverage percentage maintained: `go test -cover ./cmd/bd/` shows same %","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-27T20:32:00.130855-07:00","updated_at":"2025-10-30T17:12:58.209218-07:00","labels":["phase-4","test-cleanup"],"dependencies":[{"issue_id":"bd-fb95094c.4","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:32:00.132251-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.5","content_hash":"3e37bcf3e5090c1971f300f95fc904762857be05d4d47acfa2bfa049c8302043","title":"Centralize BD_DEBUG logging into debug package","description":"The codebase has 43 scattered instances of `if os.Getenv(\"BD_DEBUG\") != \"\"` debug checks across 6 files. Centralize into a debug logging package.\n\nCurrent locations:\n- `cmd/bd/main.go` - 15 checks\n- `cmd/bd/autoflush.go` - 6 checks\n- `cmd/bd/nodb.go` - 4 checks\n- `internal/rpc/server.go` - 2 checks\n- `internal/rpc/client.go` - 5 checks\n- `cmd/bd/daemon_autostart.go` - 11 checks\n\nTarget structure:\n```\ninternal/debug/\n└── debug.go\n```\n\nBenefits:\n- Centralized debug logging\n- Easier to add structured logging later\n- Testable (can mock debug output)\n- Consistent debug message format\n\nImpact: Removes 43 scattered checks, improves code clarity","acceptance_criteria":"- Create `internal/debug/debug.go` with `Enabled`, `Logf`, `Printf`\n- Add unit tests in `internal/debug/debug_test.go` (test with/without BD_DEBUG)\n- Replace all 43 instances of `os.Getenv(\"BD_DEBUG\")` checks with `debug.Logf()`\n- Verify debug output works: run with `BD_DEBUG=1 bd status`\n- All tests pass: `go test ./...`\n- No behavior change (output identical to before)","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-27T20:31:19.089078-07:00","updated_at":"2025-10-30T17:12:58.208577-07:00","labels":["deduplication","logging","phase-3","refactor"],"dependencies":[{"issue_id":"bd-fb95094c.5","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T21:48:41.542395-07:00","created_by":"stevey"}]}
{"id":"bd-fb95094c.6","content_hash":"b853675236e96269afb97649cc1a7b27451f15babf611a2abfea58986d0f5a2f","title":"Extract normalizeLabels to shared utility package","description":"The `normalizeLabels` function appears in multiple locations with identical implementation. Extract to a shared utility package.\n\nCurrent locations:\n- `internal/rpc/server.go:37` (53 lines) - full implementation\n- `cmd/bd/list.go:50-52` - uses the server version (needs to use new shared version)\n\nFunction purpose:\n- Trims whitespace from labels\n- Removes empty strings\n- Deduplicates labels\n- Preserves order\n\nTarget structure:\n```\ninternal/util/\n├── strings.go         # String utilities\n    └── NormalizeLabels([]string) []string\n```\n\nImpact: DRY principle, single source of truth, easier to test","acceptance_criteria":"- Create `internal/util/strings.go` with `NormalizeLabels`\n- Add comprehensive unit tests in `internal/util/strings_test.go`\n- Update `internal/rpc/server.go` to import and use `util.NormalizeLabels`\n- Update `cmd/bd/list.go` to import and use `util.NormalizeLabels`\n- Remove duplicate implementations\n- All tests pass: `go test ./...`\n- Verify label normalization works: test `bd list --label` commands","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-27T20:31:19.078622-07:00","updated_at":"2025-10-30T17:12:58.208284-07:00","labels":["deduplication","phase-3","refactor"],"dependencies":[{"issue_id":"bd-fb95094c.6","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:31:19.08015-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.7","content_hash":"af7f41ff73c3aaba006d9cfbf8e35332e25d5b42f9e620b5e94d41c05550ea81","title":"Extract SQLite migrations into separate files","description":"The file `internal/storage/sqlite/sqlite.go` is 2,136 lines and contains 11 sequential migrations alongside core storage logic. Extract migrations into a versioned system.\n\nCurrent issues:\n- 11 migration functions mixed with core logic\n- Hard to see migration history\n- Sequential migrations slow database open\n- No clear migration versioning\n\nMigration functions to extract:\n- `migrateDirtyIssuesTable()`\n- `migrateIssueCountersTable()`\n- `migrateExternalRefColumn()`\n- `migrateCompositeIndexes()`\n- `migrateClosedAtConstraint()`\n- `migrateCompactionColumns()`\n- `migrateSnapshotsTable()`\n- `migrateCompactionConfig()`\n- `migrateCompactedAtCommitColumn()`\n- `migrateExportHashesTable()`\n- Plus 1 more (11 total)\n\nTarget structure:\n```\ninternal/storage/sqlite/\n├── sqlite.go          # Core storage (~800 lines)\n├── schema.go          # Table definitions (~200 lines)\n├── migrations.go      # Migration orchestration (~200 lines)\n└── migrations/        # Individual migrations\n    ├── 001_initial_schema.go\n    ├── 002_dirty_issues.go\n    ├── 003_issue_counters.go\n    [... through 011_export_hashes.go]\n```\n\nBenefits:\n- Clear migration history\n- Each migration self-contained\n- Easier to review migration changes in PRs\n- Future migrations easier to add","acceptance_criteria":"- All 11 migrations extracted to separate files\n- Migration version tracking in database\n- Migrations run in order on fresh database\n- Existing databases upgrade correctly\n- All tests pass: `go test ./internal/storage/sqlite/...`\n- Database initialization time unchanged or improved\n- Add migration rollback capability (optional, nice-to-have)","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-27T20:30:47.870671-07:00","updated_at":"2025-10-30T17:12:58.207682-07:00","labels":["database","phase-2","refactor"],"dependencies":[{"issue_id":"bd-fb95094c.7","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:30:47.875564-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.8","content_hash":"8a8df680150f73fef6ac9cede6a1b2b0033406b35553a8a3795b13a542cd62f1","title":"Remove unreachable utility functions","description":"Several small utility functions are unreachable:\n\nFiles to clean:\n1. `internal/storage/sqlite/hash.go` - `computeIssueContentHash` (line 17)\n   - Check if entire file can be deleted if only contains this function\n\n2. `internal/config/config.go` - `FileUsed` (line 151)\n   - Delete unused config helper\n\n3. `cmd/bd/git_sync_test.go` - `verifyIssueOpen` (line 300)\n   - Delete dead test helper\n\n4. `internal/compact/haiku.go` - `HaikuClient.SummarizeTier2` (line 81)\n   - Tier 2 summarization not implemented\n   - Options: implement feature OR delete method\n\nImpact: Removes 50-100 LOC depending on decisions","acceptance_criteria":"- Remove unreachable functions\n- If entire files can be deleted (like hash.go), delete them\n- For SummarizeTier2: decide to implement or delete, document decision\n- All tests pass: `go test ./...`\n- Verify no callers exist for each function","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T20:30:19.963392-07:00","updated_at":"2025-10-30T17:12:58.206334-07:00","closed_at":"2025-10-28T14:14:55.724226-07:00","labels":["cleanup","dead-code","phase-1"],"dependencies":[{"issue_id":"bd-fb95094c.8","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:30:19.968126-07:00","created_by":"daemon"}]}
{"id":"bd-fb95094c.9","content_hash":"404b82a19dde2fdece7eb6bb3b816db7906e81a03a5a05341ed631af7a2a8e87","title":"Remove unreachable RPC methods","description":"Several RPC server and client methods are unreachable and should be removed:\n\nServer methods (internal/rpc/server.go):\n- `Server.GetLastImportTime` (line 2116)\n- `Server.SetLastImportTime` (line 2123)\n- `Server.findJSONLPath` (line 2255)\n\nClient methods (internal/rpc/client.go):\n- `Client.Import` (line 311) - RPC import not used (daemon uses autoimport)\n\nEvidence:\n```bash\ngo run golang.org/x/tools/cmd/deadcode@latest -test ./...\n```\n\nImpact: Removes ~80 LOC of unused RPC code","acceptance_criteria":"- Remove the 4 unreachable methods (~80 LOC total)\n- Verify no callers: `grep -r \"GetLastImportTime\\|SetLastImportTime\\|findJSONLPath\" .`\n- All tests pass: `go test ./internal/rpc/...`\n- Daemon functionality works: test daemon start/stop/operations","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T20:30:19.962209-07:00","updated_at":"2025-10-30T17:12:58.201466-07:00","closed_at":"2025-10-28T16:07:26.103703-07:00","labels":["cleanup","dead-code","phase-1","rpc"],"dependencies":[{"issue_id":"bd-fb95094c.9","depends_on_id":"bd-fb95094c","type":"parent-child","created_at":"2025-10-27T20:30:19.965239-07:00","created_by":"daemon"}]}
{"id":"bd-fd8753d9","content_hash":"ae13fc833baa7d586a48ca62648dd4f0ee61fcc96aa1f238fb2639b6657b07da","title":"Document bd edit command and verify MCP exclusion","description":"Follow-up from PR #152:\n1. Add \"bd edit\" to AGENTS.md with \"Humans only\" note\n2. Verify MCP server doesn't expose bd edit command\n3. Consider adding test for command registration","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-26T13:23:47.982295-07:00","updated_at":"2025-10-30T17:12:58.226229-07:00"}
