<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and generate all documents in {document_output_language}</critical>
  <critical>üîß BEADS IS REQUIRED - Story selection and task creation MUST use Beads</critical>

  <step n="0" goal="Beads preflight check">
    <action>Verify Beads CLI is available:</action>
    <code>_bmad/bin/bd version</code>
    <check if="bd command fails">
      <output>üö´ BEADS CLI NOT AVAILABLE</output>
      <output>Beads is required for BMAD task tracking. Run the BMAD installer to provision it.</output>
      <action>HALT - Cannot proceed without Beads</action>
    </check>
    <check if=".beads directory missing">
      <action>Initialize Beads: _bmad/bin/bd init --quiet</action>
    </check>
    <action>Continue to step 1</action>
  </step>

  <critical>üî• CRITICAL MISSION: You are creating the ULTIMATE story context engine that prevents LLM developer mistakes, omissions or
    disasters! üî•</critical>
  <critical>Your purpose is NOT to copy from epics - it's to create a comprehensive, optimized story file that gives the DEV agent
    EVERYTHING needed for flawless implementation</critical>
  <critical>COMMON LLM MISTAKES TO PREVENT: reinventing wheels, wrong libraries, wrong file locations, breaking regressions, ignoring UX,
    vague implementations, lying about completion, not learning from past work</critical>
  <critical>üö® EXHAUSTIVE ANALYSIS REQUIRED: You must thoroughly analyze ALL artifacts to extract critical context - do NOT be lazy or skim!
    This is the most important function in the entire development process!</critical>
  <critical>üî¨ UTILIZE SUBPROCESSES AND SUBAGENTS: Use research subagents, subprocesses or parallel processing if available to thoroughly
    analyze different artifacts simultaneously and thoroughly</critical>
  <critical>‚ùì SAVE QUESTIONS: If you think of questions or clarifications during analysis, save them for the end after the complete story is
    written</critical>
  <critical>üéØ ZERO USER INTERVENTION: Process should be fully automated except for initial epic/story selection or missing documents</critical>

  <step n="1" goal="Determine target story (Beads-first)">
    <critical>üéØ BEADS IS THE SOURCE OF TRUTH for story selection</critical>

    <check if="{{story_path}} is provided by user or user provided the epic and story number such as 2-4 or 1.6 or epic 1 story 5 or Beads ID like proj-a3f8.1">
      <check if="user provided Beads ID">
        <action>Query Beads for story details: _bmad/bin/bd show {{beads_id}} --json</action>
        <action>Extract story title and parent epic from Beads</action>
        <action>Set {{beads_story_id}}, {{beads_epic_id}}, {{story_key}} from Beads data</action>
        <action>GOTO step 1b</action>
      </check>
      <action>Parse user-provided story path: extract epic_num, story_num, story_title from format like "1-2-user-auth"</action>
      <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
      <action>Look up Beads ID for this story: _bmad/bin/bd list --json --label "bmad:story" | find matching title</action>
      <action>GOTO step 1b</action>
    </check>

    <!-- Auto-discover from Beads (PRIMARY) -->
    <action>Query Beads for next backlog story:</action>
    <code>_bmad/bin/bd list --json --label "bmad:story" --label "bmad:stage:backlog"</code>

    <check if="Beads returns backlog stories">
      <action>Select FIRST backlog story (sorted by parent epic, then by creation order)</action>
      <action>Set {{beads_story_id}}, {{beads_epic_id}}, {{story_key}} from Beads data</action>
      <action>GOTO step 1b</action>
    </check>

    <!-- Fallback to sprint-status.yaml if Beads has no backlog stories -->
    <action>Check if {{sprint_status}} file exists for fallback discovery</action>
    <check if="sprint status file does NOT exist AND Beads has no backlog stories">
      <output>üö´ No backlog stories found in Beads or sprint-status.yaml</output>
      <output>
        **Required Options:**
        1. Run `sprint-planning` to initialize sprint tracking and Beads graph (recommended)
        2. Provide specific epic-story number or Beads ID to create (e.g., "1-2-user-auth" or "proj-a3f8.1")
        3. Provide path to story documents if sprint status doesn't exist yet
      </output>
      <ask>Choose option [1], provide epic-story number/Beads ID, path to story docs, or [q] to quit:</ask>

      <check if="user chooses 'q'">
        <action>HALT - No work needed</action>
      </check>

      <check if="user chooses '1'">
        <output>Run sprint-planning workflow first to create Beads graph and sprint-status.yaml</output>
        <action>HALT - User needs to run sprint-planning</action>
      </check>

      <check if="user provides epic-story number or Beads ID">
        <action>Parse user input: extract epic_num, story_num, story_title OR Beads ID</action>
        <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
        <action>GOTO step 1b</action>
      </check>

      <check if="user provides story docs path">
        <action>Use user-provided path for story documents</action>
        <action>GOTO step 1b</action>
      </check>
    </check>

    <!-- Legacy fallback: Auto-discover from sprint status only if Beads empty and no user input -->
    <check if="no user input provided AND Beads returned no stories">
      <critical>MUST read COMPLETE {sprint_status} file from start to end to preserve order</critical>
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Read ALL lines from beginning to end - do not skip any content</action>
      <action>Parse the development_status section completely</action>

      <action>Find the FIRST story (by reading in order from top to bottom) where:
        - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
        - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
        - Status value equals "backlog"
      </action>

      <check if="no backlog story found">
        <output>üìã No backlog stories found in sprint-status.yaml

          All stories are either already created, in progress, or done.

          **Options:**
          1. Run sprint-planning to refresh story tracking
          2. Load PM agent and run correct-course to add more stories
          3. Check if current sprint is complete and run retrospective
        </output>
        <action>HALT</action>
      </check>

      <action>Extract from found story key (e.g., "1-2-user-authentication"):
        - epic_num: first number before dash (e.g., "1")
        - story_num: second number after first dash (e.g., "2")
        - story_title: remainder after second dash (e.g., "user-authentication")
      </action>
      <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
      <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>

      <!-- Mark epic as in-progress if this is first story -->
      <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
      <check if="this is first story in epic {{epic_num}}">
        <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
        <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
        <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
        <action>If epic status is "in-progress" ‚Üí no change needed</action>
        <check if="epic status is 'done'">
          <output>üö´ ERROR: Cannot create story in completed epic</output>
          <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
          <output>If you need to add more work, either:</output>
          <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
          <output>2. Create a new epic for additional work</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <check if="epic status is not one of: backlog, contexted, in-progress, done">
          <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
          <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
          <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <output>üìä Epic {{epic_num}} status updated to in-progress</output>
      </check>

      <action>GOTO step 1b</action>
    </check>
    <action>Load the FULL file: {{sprint_status}}</action>
    <action>Read ALL lines from beginning to end - do not skip any content</action>
    <action>Parse the development_status section completely</action>

    <action>Find the FIRST story (by reading in order from top to bottom) where:
      - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
      - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
      - Status value equals "backlog"
    </action>

    <check if="no backlog story found">
      <output>üìã No backlog stories found in sprint-status.yaml

        All stories are either already created, in progress, or done.

        **Options:**
        1. Run sprint-planning to refresh story tracking
        2. Load PM agent and run correct-course to add more stories
        3. Check if current sprint is complete and run retrospective
      </output>
      <action>HALT</action>
    </check>

    <action>Extract from found story key (e.g., "1-2-user-authentication"):
      - epic_num: first number before dash (e.g., "1")
      - story_num: second number after first dash (e.g., "2")
      - story_title: remainder after second dash (e.g., "user-authentication")
    </action>
    <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
    <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>
    <action>Look up Beads ID if not already known: _bmad/bin/bd list --json --label "bmad:story" | find matching title</action>

    <!-- Mark epic as in-progress if this is first story -->
    <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
    <check if="this is first story in epic {{epic_num}}">
      <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
      <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
      <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
      <action>If epic status is "in-progress" ‚Üí no change needed</action>
      <check if="epic status is 'done'">
        <output>üö´ ERROR: Cannot create story in completed epic</output>
        <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
        <output>If you need to add more work, either:</output>
        <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
        <output>2. Create a new epic for additional work</output>
        <action>HALT - Cannot proceed</action>
      </check>
      <check if="epic status is not one of: backlog, contexted, in-progress, done">
        <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
        <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
        <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
        <action>HALT - Cannot proceed</action>
      </check>
      <output>üìä Epic {{epic_num}} status updated to in-progress</output>
    </check>

    <action>GOTO step 1b</action>
  </step>

  <step n="1b" goal="Create Beads task/subtask children for story">
    <critical>üéØ CREATE BEADS TASK HIERARCHY - Tasks are tracked in Beads, not just story files</critical>

    <action>If {{beads_story_id}} is not set, the story needs a Beads issue. Create one:</action>
    <check if="beads_story_id is not set">
      <action>Look up parent epic Beads ID from sprint-status.yaml or epic files</action>
      <code>_bmad/bin/bd create "{{story_title}}" --parent {{beads_epic_id}} --type task --label "bmad:story" --label "bmad:stage:backlog"</code>
      <action>Store returned ID as {{beads_story_id}}</action>
    </check>

    <action>Continue to step 2 - task children will be created after story analysis</action>
  </step>

  <step n="2" goal="Load and analyze core artifacts">
    <critical>üî¨ EXHAUSTIVE ARTIFACT ANALYSIS - This is where you prevent future developer fuckups!</critical>

    <!-- Load all available content through discovery protocol -->
    <invoke-protocol
      name="discover_inputs" />
    <note>Available content: {epics_content}, {prd_content}, {architecture_content}, {ux_content},
    {project_context}</note>

    <!-- Analyze epics file for story foundation -->
    <action>From {epics_content}, extract Epic {{epic_num}} complete context:</action> **EPIC ANALYSIS:** - Epic
    objectives and business value - ALL stories in this epic for cross-story context - Our specific story's requirements, user story
    statement, acceptance criteria - Technical requirements and constraints - Dependencies on other stories/epics - Source hints pointing to
    original documents <!-- Extract specific story requirements -->
    <action>Extract our story ({{epic_num}}-{{story_num}}) details:</action> **STORY FOUNDATION:** - User story statement
    (As a, I want, so that) - Detailed acceptance criteria (already BDD formatted) - Technical requirements specific to this story -
    Business context and value - Success criteria <!-- Previous story analysis for context continuity -->
    <check if="story_num > 1">
      <action>Load previous story file: {{story_dir}}/{{epic_num}}-{{previous_story_num}}-*.md</action> **PREVIOUS STORY INTELLIGENCE:** -
    Dev notes and learnings from previous story - Review feedback and corrections needed - Files that were created/modified and their
    patterns - Testing approaches that worked/didn't work - Problems encountered and solutions found - Code patterns established <action>Extract
    all learnings that could impact current story implementation</action>
    </check>

    <!-- Git intelligence for previous work patterns -->
    <check
      if="previous story exists AND git repository detected">
      <action>Get last 5 commit titles to understand recent work patterns</action>
      <action>Analyze 1-5 most recent commits for relevance to current story:
        - Files created/modified
        - Code patterns and conventions used
        - Library dependencies added/changed
        - Architecture decisions implemented
        - Testing approaches used
      </action>
      <action>Extract actionable insights for current story implementation</action>
    </check>
  </step>

  <step n="3" goal="Architecture analysis for developer guardrails">
    <critical>üèóÔ∏è ARCHITECTURE INTELLIGENCE - Extract everything the developer MUST follow!</critical> **ARCHITECTURE DOCUMENT ANALYSIS:** <action>Systematically
    analyze architecture content for story-relevant requirements:</action>

    <!-- Load architecture - single file or sharded -->
    <check if="architecture file is single file">
      <action>Load complete {architecture_content}</action>
    </check>
    <check if="architecture is sharded to folder">
      <action>Load architecture index and scan all architecture files</action>
    </check> **CRITICAL ARCHITECTURE EXTRACTION:** <action>For
    each architecture section, determine if relevant to this story:</action> - **Technical Stack:** Languages, frameworks, libraries with
    versions - **Code Structure:** Folder organization, naming conventions, file patterns - **API Patterns:** Service structure, endpoint
    patterns, data contracts - **Database Schemas:** Tables, relationships, constraints relevant to story - **Security Requirements:**
    Authentication patterns, authorization rules - **Performance Requirements:** Caching strategies, optimization patterns - **Testing
    Standards:** Testing frameworks, coverage expectations, test patterns - **Deployment Patterns:** Environment configurations, build
    processes - **Integration Patterns:** External service integrations, data flows <action>Extract any story-specific requirements that the
    developer MUST follow</action>
    <action>Identify any architectural decisions that override previous patterns</action>
  </step>

  <step n="4" goal="Web research for latest technical specifics">
    <critical>üåê ENSURE LATEST TECH KNOWLEDGE - Prevent outdated implementations!</critical> **WEB INTELLIGENCE:** <action>Identify specific
    technical areas that require latest version knowledge:</action>

    <!-- Check for libraries/frameworks mentioned in architecture -->
    <action>From architecture analysis, identify specific libraries, APIs, or
    frameworks</action>
    <action>For each critical technology, research latest stable version and key changes:
      - Latest API documentation and breaking changes
      - Security vulnerabilities or updates
      - Performance improvements or deprecations
      - Best practices for current version
    </action>
    **EXTERNAL CONTEXT INCLUSION:** <action>Include in story any critical latest information the developer needs:
      - Specific library versions and why chosen
      - API endpoints with parameters and authentication
      - Recent security patches or considerations
      - Performance optimization techniques
      - Migration considerations if upgrading
    </action>
  </step>

  <step n="5" goal="Create comprehensive story file">
    <critical>üìù CREATE ULTIMATE STORY FILE - The developer's master implementation guide!</critical>

    <action>Initialize from template.md:
    {default_output_file}</action>
    <template-output file="{default_output_file}">story_header</template-output>

    <!-- Story foundation from epics analysis -->
    <template-output
      file="{default_output_file}">story_requirements</template-output>

    <!-- Developer context section - MOST IMPORTANT PART -->
    <template-output file="{default_output_file}">
    developer_context_section</template-output> **DEV AGENT GUARDRAILS:** <template-output file="{default_output_file}">
    technical_requirements</template-output>
    <template-output file="{default_output_file}">architecture_compliance</template-output>
    <template-output
      file="{default_output_file}">library_framework_requirements</template-output>
    <template-output file="{default_output_file}">
    file_structure_requirements</template-output>
    <template-output file="{default_output_file}">testing_requirements</template-output>

    <!-- Previous story intelligence -->
    <check
      if="previous story learnings available">
      <template-output file="{default_output_file}">previous_story_intelligence</template-output>
    </check>

    <!-- Git intelligence -->
    <check
      if="git analysis completed">
      <template-output file="{default_output_file}">git_intelligence_summary</template-output>
    </check>

    <!-- Latest technical specifics -->
    <check if="web research completed">
      <template-output file="{default_output_file}">latest_tech_information</template-output>
    </check>

    <!-- Project context reference -->
    <template-output
      file="{default_output_file}">project_context_reference</template-output>

    <!-- Final status update -->
    <template-output file="{default_output_file}">
    story_completion_status</template-output>

    <!-- CRITICAL: Set status to ready-for-dev -->
    <action>Set story Status to: "ready-for-dev"</action>
    <action>Add completion note: "Ultimate
    context engine analysis completed - comprehensive developer guide created"</action>
  </step>

  <step n="5b" goal="Create Beads task/subtask children from story tasks">
    <critical>üéØ BEADS TASK HIERARCHY - Create child issues for each task/subtask in the story</critical>

    <action>Parse the story document for Tasks / Subtasks section</action>
    <action>For each task identified:</action>

    <code>
    # Create task as child of story
    _bmad/bin/bd create "{{task_title}}" \
      --parent {{beads_story_id}} \
      --type task \
      --label "bmad:task" \
      --label "bmad:stage:backlog"
    </code>

    <action>Store returned ID as {{beads_task_id_N}}</action>

    <action>For each subtask under a task:</action>
    <code>
    # Create subtask as child of task
    _bmad/bin/bd create "{{subtask_title}}" \
      --parent {{beads_task_id_N}} \
      --type task \
      --label "bmad:subtask" \
      --label "bmad:stage:backlog"
    </code>

    <action>Store returned ID as {{beads_subtask_id_N_M}}</action>

    <critical>üîó SEQUENTIAL BLOCKERS - Enforce task order</critical>
    <action>For each task after the first:</action>
    <code>
    # Task N is blocked by Task N-1
    _bmad/bin/bd dep add {{beads_task_id_N}} {{beads_task_id_N_minus_1}} --type blocks
    </code>

    <action>For each subtask after the first within a task:</action>
    <code>
    # Subtask M is blocked by Subtask M-1
    _bmad/bin/bd dep add {{beads_subtask_id_N_M}} {{beads_subtask_id_N_M_minus_1}} --type blocks
    </code>

    <action>Update story file with Beads IDs for each task (optional - for reference)</action>
  </step>

  <step n="6" goal="Update Beads status, sprint status, and finalize">
    <invoke-task>Validate against checklist at {installed_path}/checklist.md using _bmad/core/tasks/validate-workflow.xml</invoke-task>
    <action>Save story document unconditionally</action>

    <!-- Update Beads story status (PRIMARY) -->
    <action>Update Beads story to ready-for-dev:</action>
    <code>_bmad/bin/bd-stage {{beads_story_id}} ready-for-dev</code>

    <!-- Update sprint status (DERIVED VIEW) -->
    <check if="sprint status file exists">
      <action>Update {{sprint_status}}</action>
      <action>Load the FULL file and read all development_status entries</action>
      <action>Find development_status key matching {{story_key}}</action>
      <action>Verify current status is "backlog" (expected previous state)</action>
      <action>Update development_status[{{story_key}}] = "ready-for-dev"</action>
      <action>Add beads_id field if not present</action>
      <action>Save file, preserving ALL comments and structure including STATUS DEFINITIONS</action>
    </check>

    <action>Report completion</action>
    <output>**üéØ ULTIMATE BMad Method STORY CONTEXT CREATED, {user_name}!**

      **Story Details:**
      - Story ID: {{story_id}}
      - Story Key: {{story_key}}
      - **Beads Story ID:** {{beads_story_id}}
      - File: {{story_file}}
      - Status: ready-for-dev

      **Beads Task Hierarchy Created:**
      - Tasks: {{task_count}} (with sequential blockers)
      - Subtasks: {{subtask_count}} (with sequential blockers)

      **Next Steps:**
      1. Review the comprehensive story in {{story_file}}
      2. **Optional Quality Competition:** Run the scrum masters `*validate-create-story` to have a fresh LLM systematically review and
      improve the story context
      3. Run dev agents `dev-story` for optimized implementation
         - Dev agent will use `_bmad/bin/bd ready` to find the first unblocked task
      4. Run `code-review` when complete (creates blocking review findings if needed)

      **Beads Commands:**
      - View story tasks: `_bmad/bin/bd list --parent {{beads_story_id}}`
      - Find ready work: `_bmad/bin/bd ready --label "bmad:task"`

      **The developer now has everything needed for flawless implementation!**
    </output>
  </step>

</workflow>