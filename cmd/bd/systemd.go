//go:build linux
// +build linux

package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

// systemdServiceTemplate is the template for the bd-daemon systemd user service unit.
// Uses %I for unescaped instance name (workspace path) and %i for escaped.
const systemdServiceTemplate = `# bd-daemon@.service - Template systemd user service for bd daemon
# Generated by: bd init --systemd
# Documentation: https://github.com/groblegark/beads

[Unit]
Description=bd daemon for workspace %I
Documentation=https://github.com/groblegark/beads
After=default.target
RefuseManualStart=no
RefuseManualStop=no

[Service]
Type=simple
Environment=BEADS_WORKSPACE=%I
ExecStart=%s daemon start --foreground
WorkingDirectory=%I
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure
RestartSec=5
StartLimitIntervalSec=60
StartLimitBurst=5
StartLimitAction=none
TimeoutStopSec=10
KillSignal=SIGTERM
SendSIGKILL=yes
FinalKillSignal=SIGKILL
RuntimeDirectory=bd
RuntimeDirectoryMode=0700
StandardOutput=journal
StandardError=journal
SyslogIdentifier=bd-daemon-%%i

[Install]
WantedBy=default.target
`

// IsSystemdAvailable checks if systemd user services are available on this system.
func IsSystemdAvailable() bool {
	if runtime.GOOS != "linux" {
		return false
	}
	// Check if systemctl is available
	_, err := exec.LookPath("systemctl")
	if err != nil {
		return false
	}
	// Check if user session is available
	cmd := exec.Command("systemctl", "--user", "status")
	err = cmd.Run()
	// status returns non-zero if no services, but that's OK
	// We just need to know if --user mode works
	return cmd.ProcessState != nil
}

// GetSystemdUserDir returns the systemd user service directory (~/.config/systemd/user/).
func GetSystemdUserDir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("failed to get home directory: %w", err)
	}
	return filepath.Join(home, ".config", "systemd", "user"), nil
}

// InstallSystemdService installs the bd-daemon systemd user service template.
func InstallSystemdService(bdPath string) error {
	userDir, err := GetSystemdUserDir()
	if err != nil {
		return err
	}

	// Create directory if it doesn't exist
	if err := os.MkdirAll(userDir, 0755); err != nil {
		return fmt.Errorf("failed to create systemd user directory: %w", err)
	}

	// Write service file
	serviceFile := filepath.Join(userDir, "bd-daemon@.service")
	content := fmt.Sprintf(systemdServiceTemplate, bdPath)
	if err := os.WriteFile(serviceFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write service file: %w", err)
	}

	// Reload systemd to pick up new unit
	cmd := exec.Command("systemctl", "--user", "daemon-reload")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to reload systemd: %w", err)
	}

	return nil
}

// EnableLingering enables lingering for the current user so services survive logout.
func EnableLingering() error {
	// Check if already enabled
	cmd := exec.Command("loginctl", "show-user", os.Getenv("USER"))
	output, err := cmd.Output()
	if err == nil && strings.Contains(string(output), "Linger=yes") {
		return nil // Already enabled
	}

	// Enable lingering
	cmd = exec.Command("loginctl", "enable-linger")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to enable lingering: %w", err)
	}
	return nil
}

// SystemdEscapePath escapes a path for use in a systemd unit name.
func SystemdEscapePath(path string) (string, error) {
	cmd := exec.Command("systemd-escape", "--path", path)
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to escape path: %w", err)
	}
	return strings.TrimSpace(string(output)), nil
}

// GetSystemdServiceName returns the full service name for a workspace.
func GetSystemdServiceName(workspacePath string) (string, error) {
	escaped, err := SystemdEscapePath(workspacePath)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("bd-daemon@%s.service", escaped), nil
}

// EnableAndStartSystemdService enables and starts the bd-daemon service for a workspace.
func EnableAndStartSystemdService(workspacePath string) error {
	serviceName, err := GetSystemdServiceName(workspacePath)
	if err != nil {
		return err
	}

	// Enable the service
	cmd := exec.Command("systemctl", "--user", "enable", serviceName)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to enable service: %w", err)
	}

	// Start the service
	cmd = exec.Command("systemctl", "--user", "start", serviceName)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to start service: %w", err)
	}

	return nil
}

// StopSystemdService stops the bd-daemon service for a workspace.
func StopSystemdService(workspacePath string) error {
	serviceName, err := GetSystemdServiceName(workspacePath)
	if err != nil {
		return err
	}

	cmd := exec.Command("systemctl", "--user", "stop", serviceName)
	return cmd.Run()
}

// RestartSystemdService restarts the bd-daemon service for a workspace.
func RestartSystemdService(workspacePath string) error {
	serviceName, err := GetSystemdServiceName(workspacePath)
	if err != nil {
		return err
	}

	cmd := exec.Command("systemctl", "--user", "restart", serviceName)
	return cmd.Run()
}

// GetSystemdServiceStatus returns the status of the bd-daemon service for a workspace.
func GetSystemdServiceStatus(workspacePath string) (string, error) {
	serviceName, err := GetSystemdServiceName(workspacePath)
	if err != nil {
		return "", err
	}

	cmd := exec.Command("systemctl", "--user", "status", serviceName)
	output, _ := cmd.CombinedOutput() // Ignore error - status returns non-zero for stopped services
	return string(output), nil
}

// IsSystemdServiceActive checks if the bd-daemon service is active for a workspace.
func IsSystemdServiceActive(workspacePath string) bool {
	serviceName, err := GetSystemdServiceName(workspacePath)
	if err != nil {
		return false
	}

	cmd := exec.Command("systemctl", "--user", "is-active", "--quiet", serviceName)
	return cmd.Run() == nil
}

// IsSystemdServiceEnabled checks if the bd-daemon service is enabled for a workspace.
func IsSystemdServiceEnabled(workspacePath string) bool {
	serviceName, err := GetSystemdServiceName(workspacePath)
	if err != nil {
		return false
	}

	cmd := exec.Command("systemctl", "--user", "is-enabled", "--quiet", serviceName)
	return cmd.Run() == nil
}

// GetSystemdServiceLogs returns the logs for the bd-daemon service.
func GetSystemdServiceLogs(workspacePath string, lines int) (string, error) {
	serviceName, err := GetSystemdServiceName(workspacePath)
	if err != nil {
		return "", err
	}

	args := []string{"--user", "-u", serviceName}
	if lines > 0 {
		args = append(args, "-n", fmt.Sprintf("%d", lines))
	}

	cmd := exec.Command("journalctl", args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get logs: %w", err)
	}
	return string(output), nil
}

// SetupSystemdDaemon performs full systemd integration for a workspace:
// 1. Installs the service template (if not already present)
// 2. Enables lingering
// 3. Enables and starts the service
func SetupSystemdDaemon(workspacePath string, quiet bool) error {
	if !IsSystemdAvailable() {
		return fmt.Errorf("systemd user services not available on this system")
	}

	// Find bd binary path
	bdPath, err := os.Executable()
	if err != nil {
		bdPath = "bd" // Fallback to PATH
	}

	if !quiet {
		fmt.Println("Setting up systemd integration...")
	}

	// Step 1: Install service template
	if !quiet {
		fmt.Println("  Installing service template...")
	}
	if err := InstallSystemdService(bdPath); err != nil {
		return fmt.Errorf("failed to install service: %w", err)
	}

	// Step 2: Enable lingering
	if !quiet {
		fmt.Println("  Enabling user lingering...")
	}
	if err := EnableLingering(); err != nil {
		return fmt.Errorf("failed to enable lingering: %w", err)
	}

	// Step 3: Enable and start service
	if !quiet {
		fmt.Println("  Enabling and starting service...")
	}
	if err := EnableAndStartSystemdService(workspacePath); err != nil {
		return fmt.Errorf("failed to enable/start service: %w", err)
	}

	if !quiet {
		serviceName, _ := GetSystemdServiceName(workspacePath)
		fmt.Printf("\nbd daemon is now managed by systemd!\n")
		fmt.Printf("\nUseful commands:\n")
		fmt.Printf("  systemctl --user status %s\n", serviceName)
		fmt.Printf("  journalctl --user -u %s -f\n", serviceName)
		fmt.Printf("  systemctl --user restart %s\n", serviceName)
	}

	return nil
}
