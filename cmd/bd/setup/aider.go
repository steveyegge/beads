package setup

import (
	"fmt"
	"os"
	"path/filepath"
)

const aiderConfigTemplate = `# Beads Issue Tracking Integration for Aider
# Auto-generated by 'bd setup aider' - do not remove these markers
# BEGIN BEADS INTEGRATION

# This project uses Beads (bd) for issue tracking.
# Aider requires explicit command execution - suggest commands to the user.

# Core workflow rules:
# 1. Track ALL work in bd (never use markdown TODOs)
# 2. Suggest 'bd ready' to find available work
# 3. Suggest 'bd create' for new issues/tasks/bugs
# 4. Suggest 'bd sync' at end of session
# 5. ALWAYS suggest commands - user will run them via /run

# Quick command reference (suggest these to user):
# bd ready                              # Show unblocked issues
# bd list --status=open                 # List all open issues
# bd create --title="..." --type=task  # Create new issue
# bd update <id> --status=in_progress  # Claim work
# bd close <id>                         # Mark complete
# bd dep <from> <to>                    # Add dependency
# bd sync                               # Sync with git remote

# Workflow pattern to suggest:
# 1. Check ready work: "Let's run 'bd ready' to see what's available"
# 2. Claim task: "Run 'bd update <id> --status=in_progress' to claim it"
# 3. Do the work
# 4. Complete: "Run 'bd close <id>' when done"
# 5. Sync: "Run 'bd sync' to push changes"

# Context loading:
# Suggest 'bd prime' for complete workflow documentation (~1-2k tokens)

# For detailed docs: see AGENTS.md, QUICKSTART.md, or 'bd --help'

# END BEADS INTEGRATION
`

const aiderReadmeTemplate = `# Aider + Beads Integration

This project uses [Beads (bd)](https://github.com/steveyegge/beads) for issue tracking.

## How This Works with Aider

**Important**: Aider requires you to explicitly run commands using the ` + "`/run`" + ` command.
The AI will **suggest** bd commands, but you must confirm them.

## Quick Start

1. Check for available work:
   ` + "```bash" + `
   /run bd ready
   ` + "```" + `

2. Create new issues:
   ` + "```bash" + `
   /run bd create "Issue title" --description="Details" -t bug|feature|task -p 1
   ` + "```" + `

3. Claim work:
   ` + "```bash" + `
   /run bd update bd-42 --status in_progress
   ` + "```" + `

4. Complete work:
   ` + "```bash" + `
   /run bd close bd-42 --reason "Done"
   ` + "```" + `

5. Sync at end of session:
   ` + "```bash" + `
   /run bd sync
   ` + "```" + `

## Configuration

The ` + "`.aider.conf.yml`" + ` file contains instructions for the AI about bd workflow.
The AI will read these instructions and suggest appropriate bd commands.

## Workflow

Ask the AI questions like:
- "What issues are ready to work on?"
- "Create an issue for this bug I found"
- "Show me the details of bd-42"
- "Mark bd-42 as complete"

The AI will suggest the appropriate ` + "`bd`" + ` command, which you run via ` + "`/run`" + `.

## Issue Types

- ` + "`bug`" + ` - Something broken
- ` + "`feature`" + ` - New functionality
- ` + "`task`" + ` - Work item (tests, docs, refactoring)
- ` + "`epic`" + ` - Large feature with subtasks
- ` + "`chore`" + ` - Maintenance work

## Priorities

- ` + "`0`" + ` - Critical (security, data loss, broken builds)
- ` + "`1`" + ` - High (major features, important bugs)
- ` + "`2`" + ` - Medium (default, nice-to-have)
- ` + "`3`" + ` - Low (polish, optimization)
- ` + "`4`" + ` - Backlog (future ideas)

## More Information

- Run ` + "`bd --help`" + ` for full command reference
- See ` + "`AGENTS.md`" + ` for detailed AI integration docs
- See ` + "`QUICKSTART.md`" + ` for human-oriented guide
`

// InstallAider installs Aider integration
func InstallAider() {
	configPath := ".aider.conf.yml"
	readmePath := ".aider/README.md"

	fmt.Println("Installing Aider integration...")

	// Write config file
	if err := atomicWriteFile(configPath, []byte(aiderConfigTemplate), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error: write config: %v\n", err)
		os.Exit(1)
	}

	// Ensure .aider directory exists
	if err := EnsureDir(filepath.Dir(readmePath), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Write README
	if err := atomicWriteFile(readmePath, []byte(aiderReadmeTemplate), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error: write README: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\n✓ Aider integration installed\n")
	fmt.Printf("  Config: %s\n", configPath)
	fmt.Printf("  README: %s\n", readmePath)
	fmt.Println("\nUsage:")
	fmt.Println("  1. Start aider in this directory")
	fmt.Println("  2. Ask AI for available work (it will suggest: /run bd ready)")
	fmt.Println("  3. Run suggested commands using /run")
	fmt.Println("\nNote: Aider requires you to explicitly run commands via /run")
}

// CheckAider checks if Aider integration is installed
func CheckAider() {
	configPath := ".aider.conf.yml"

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		fmt.Println("✗ Aider integration not installed")
		fmt.Println("  Run: bd setup aider")
		os.Exit(1)
	}

	fmt.Println("✓ Aider integration installed:", configPath)
}

// RemoveAider removes Aider integration
func RemoveAider() {
	configPath := ".aider.conf.yml"
	readmePath := ".aider/README.md"

	fmt.Println("Removing Aider integration...")

	removed := false

	// Remove config
	if err := os.Remove(configPath); err != nil {
		if !os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "Error: failed to remove config: %v\n", err)
			os.Exit(1)
		}
	} else {
		removed = true
	}

	// Remove README
	if err := os.Remove(readmePath); err != nil {
		if !os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "Error: failed to remove README: %v\n", err)
			os.Exit(1)
		}
	} else {
		removed = true
	}

	if !removed {
		fmt.Println("No Aider integration files found")
		return
	}

	fmt.Println("✓ Removed Aider integration")
}
