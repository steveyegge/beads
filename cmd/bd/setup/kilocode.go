package setup

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
)

const kilocodeRulesTemplate = `# Beads Issue Tracking
# Auto-generated by 'bd setup kilocode' - do not remove these markers
# BEGIN BEADS INTEGRATION

This project uses [Beads (bd)](https://github.com/steveyegge/beads) for issue tracking.

## Core Rules
- Track ALL work in bd (never use markdown TODOs or comment-based task lists)
- Use ` + "`bd ready`" + ` to find available work
- Use ` + "`bd create`" + ` to track new issues/tasks/bugs
- Use ` + "`bd sync`" + ` at end of session to sync with git remote
- Git hooks auto-sync on commit/merge

## Quick Reference
` + "```bash" + `
bd prime                              # Load complete workflow context
bd ready                              # Show issues ready to work (no blockers)
bd list --status=open                 # List all open issues
bd create --title="..." --type=task  # Create new issue
bd update <id> --status=in_progress  # Claim work
bd close <id>                         # Mark complete
bd dep add <issue> <depends-on>       # Add dependency (issue depends on depends-on)
bd sync                               # Sync with git remote
` + "```" + `

## Workflow
1. Check for ready work: ` + "`bd ready`" + `
2. Claim an issue: ` + "`bd update <id> --status=in_progress`" + `
3. Do the work
4. Mark complete: ` + "`bd close <id>`" + `
5. Sync: ` + "`bd sync`" + ` (or let git hooks handle it)

## Context Loading
Run ` + "`bd prime`" + ` to get complete workflow documentation in AI-optimized format (~1-2k tokens).

For detailed docs: see AGENTS.md, QUICKSTART.md, or run ` + "`bd --help`" + `

# END BEADS INTEGRATION
`

var (
	kilocodeEnvProvider = defaultKiloCodeEnv
)

type kilocodeEnv struct {
	stdout     io.Writer
	stderr     io.Writer
	homeDir    string
	projectDir string
	ensureDir  func(string, os.FileMode) error
	readFile   func(string) ([]byte, error)
	writeFile  func(string, []byte) error
	removeFile func(string) error
	fileExists func(string) bool
}

func defaultKiloCodeEnv() (kilocodeEnv, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return kilocodeEnv{}, fmt.Errorf("home directory: %w", err)
	}
	workDir, err := os.Getwd()
	if err != nil {
		return kilocodeEnv{}, fmt.Errorf("working directory: %w", err)
	}
	return kilocodeEnv{
		stdout:     os.Stdout,
		stderr:     os.Stderr,
		homeDir:    home,
		projectDir: workDir,
		ensureDir:  EnsureDir,
		readFile:   os.ReadFile,
		writeFile: func(path string, data []byte) error {
			return atomicWriteFile(path, data)
		},
		removeFile: os.Remove,
		fileExists: FileExists,
	}, nil
}

func projectKiloCodeRulesPath(base string) string {
	return filepath.Join(base, ".kilocode", "rules", "bd.md")
}

func globalKiloCodeRulesPath(home string) string {
	return filepath.Join(home, ".kilocode", "rules", "bd.md")
}

// InstallKiloCode installs Kilo Code integration
func InstallKiloCode(global bool) {
	env, err := kilocodeEnvProvider()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		setupExit(1)
		return
	}
	if err := installKiloCode(env, global); err != nil {
		setupExit(1)
	}
}

func installKiloCode(env kilocodeEnv, global bool) error {
	var rulesPath string
	if global {
		rulesPath = globalKiloCodeRulesPath(env.homeDir)
		_, _ = fmt.Fprintln(env.stdout, "Installing Kilo Code rules globally...")
	} else {
		rulesPath = projectKiloCodeRulesPath(env.projectDir)
		_, _ = fmt.Fprintln(env.stdout, "Installing Kilo Code rules for this project...")
	}

	// Ensure parent directory exists
	if err := env.ensureDir(filepath.Dir(rulesPath), 0755); err != nil {
		_, _ = fmt.Fprintf(env.stderr, "Error: %v\n", err)
		return err
	}

	// Write beads rules file (overwrite if exists)
	if err := env.writeFile(rulesPath, []byte(kilocodeRulesTemplate)); err != nil {
		_, _ = fmt.Fprintf(env.stderr, "Error: write rules: %v\n", err)
		return err
	}

	_, _ = fmt.Fprintln(env.stdout, "\n✓ Kilo Code integration installed")
	_, _ = fmt.Fprintf(env.stdout, "  Rules: %s\n", rulesPath)
	_, _ = fmt.Fprintln(env.stdout, "\nKilo Code will automatically load rules on next session.")
	return nil
}

// CheckKiloCode checks if Kilo Code integration is installed
func CheckKiloCode() {
	env, err := kilocodeEnvProvider()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		setupExit(1)
		return
	}
	if err := checkKiloCode(env); err != nil {
		setupExit(1)
	}
}

func checkKiloCode(env kilocodeEnv) error {
	globalRules := globalKiloCodeRulesPath(env.homeDir)
	projectRules := projectKiloCodeRulesPath(env.projectDir)

	hasGlobal := env.fileExists(globalRules)
	hasProject := env.fileExists(projectRules)

	if hasGlobal {
		_, _ = fmt.Fprintf(env.stdout, "✓ Global rules installed: %s\n", globalRules)
	}
	if hasProject {
		_, _ = fmt.Fprintf(env.stdout, "✓ Project rules installed: %s\n", projectRules)
	}

	if !hasGlobal && !hasProject {
		_, _ = fmt.Fprintln(env.stdout, "✗ Kilo Code integration not installed")
		_, _ = fmt.Fprintln(env.stdout, "  Run: bd setup kilocode")
		return fmt.Errorf("kilocode integration not installed")
	}

	return nil
}

// RemoveKiloCode removes Kilo Code integration
func RemoveKiloCode(global bool) {
	env, err := kilocodeEnvProvider()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		setupExit(1)
		return
	}
	if err := removeKiloCode(env, global); err != nil {
		setupExit(1)
	}
}

func removeKiloCode(env kilocodeEnv, global bool) error {
	var rulesPath string
	if global {
		rulesPath = globalKiloCodeRulesPath(env.homeDir)
		_, _ = fmt.Fprintln(env.stdout, "Removing Kilo Code global rules...")
	} else {
		rulesPath = projectKiloCodeRulesPath(env.projectDir)
		_, _ = fmt.Fprintln(env.stdout, "Removing Kilo Code project rules...")
	}

	if err := env.removeFile(rulesPath); err != nil {
		if os.IsNotExist(err) {
			_, _ = fmt.Fprintln(env.stdout, "No rules file found")
			return nil
		}
		_, _ = fmt.Fprintf(env.stderr, "Error: failed to remove file: %v\n", err)
		return err
	}

	_, _ = fmt.Fprintln(env.stdout, "✓ Removed Kilo Code integration")
	return nil
}
