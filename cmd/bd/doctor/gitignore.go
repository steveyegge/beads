package doctor

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// gitignoreBase contains the common gitignore patterns shared by all modes
const gitignoreBase = `# SQLite databases
*.db
*.db?*
*.db-journal
*.db-wal
*.db-shm

# Daemon runtime files
daemon.lock
daemon.log
daemon.pid
bd.sock
sync-state.json

# Local version tracking (prevents upgrade notification spam after git ops)
.local_version

# Legacy database files
db.sqlite
bd.db

# Merge artifacts (temporary files from 3-way merge)
beads.base.jsonl
beads.base.meta.json
beads.left.jsonl
beads.left.meta.json
beads.right.jsonl
beads.right.meta.json
`

// gitignoreSyncBranchSuffix is appended when sync-branch mode is configured.
// JSONL files are explicitly ignored here; bd sync uses git add -f to force-add
// them to the sync branch worktree.
const gitignoreSyncBranchSuffix = `
# Sync-branch mode: JSONL managed via dedicated branch
# bd sync force-adds to sync-branch worktree
issues.jsonl
interactions.jsonl
`

// gitignoreDirectSuffix is appended when no sync-branch is configured.
// NOTE: We intentionally do NOT add negation patterns (e.g., !issues.jsonl) here.
// They would override fork protection in .git/info/exclude, allowing contributors
// to accidentally commit upstream issue databases (#796). JSONL files are tracked
// by git by default since no pattern above ignores them.
const gitignoreDirectSuffix = `
# Direct mode: JSONL tracked in current branch
#
# NOTE: Do NOT add negation patterns (e.g., !issues.jsonl) here.
# They would override fork protection in .git/info/exclude, allowing
# contributors to accidentally commit upstream issue databases.
# The JSONL files (issues.jsonl, interactions.jsonl) and config files
# are tracked by git by default since no pattern above ignores them.
`

// GenerateGitignoreTemplate generates the .beads/.gitignore content based on sync-branch configuration.
// When syncBranchConfigured is true, JSONL files are ignored (bd sync uses git add -f in worktree).
// When false, JSONL files are tracked and committed to the current branch.
func GenerateGitignoreTemplate(syncBranchConfigured bool) string {
	var mode string
	var suffix string

	if syncBranchConfigured {
		mode = "sync-branch (JSONL ignored, committed via worktree)"
		suffix = gitignoreSyncBranchSuffix
	} else {
		mode = "direct (JSONL tracked in current branch)"
		suffix = gitignoreDirectSuffix
	}

	header := fmt.Sprintf(`# ============================================================
# MANAGED BY BEADS - DO NOT EDIT MANUALLY
# ============================================================
# This file is auto-generated by 'bd init' and 'bd doctor --fix'.
# Manual changes will be overwritten when beads regenerates this file.
#
# Mode: %s
# To change mode: bd config set sync.branch <branch|"">
# ============================================================

`, mode)

	return header + gitignoreBase + suffix
}

// GitignoreTemplate is the canonical .beads/.gitignore content for direct mode (no sync-branch).
// Deprecated: Use GenerateGitignoreTemplate(false) instead. Kept for backward compatibility.
var GitignoreTemplate = GenerateGitignoreTemplate(false)

// requiredPatterns are patterns that MUST be in .beads/.gitignore
var requiredPatterns = []string{
	"beads.base.jsonl",
	"beads.left.jsonl",
	"beads.right.jsonl",
	"beads.base.meta.json",
	"beads.left.meta.json",
	"beads.right.meta.json",
	"*.db?*",
}

// CheckGitignore checks if .beads/.gitignore is up to date.
// Deprecated: Use CheckGitignoreWithConfig instead. Kept for backward compatibility.
func CheckGitignore() DoctorCheck {
	return CheckGitignoreWithConfig(false)
}

// CheckGitignoreWithConfig checks if .beads/.gitignore matches the expected mode.
// When syncBranchConfigured is true, expects gitignore to ignore JSONL files.
// When false, expects gitignore to track JSONL files (!issues.jsonl pattern).
func CheckGitignoreWithConfig(syncBranchConfigured bool) DoctorCheck {
	gitignorePath := filepath.Join(".beads", ".gitignore")

	// Check if file exists
	content, err := os.ReadFile(gitignorePath) // #nosec G304 -- path is hardcoded
	if err != nil {
		return DoctorCheck{
			Name:    "Gitignore",
			Status:  "warning",
			Message: ".beads/.gitignore not found",
			Fix:     "Run: bd init (safe to re-run) or bd doctor --fix",
		}
	}

	// Check for required patterns
	contentStr := string(content)
	var missing []string
	for _, pattern := range requiredPatterns {
		if !strings.Contains(contentStr, pattern) {
			missing = append(missing, pattern)
		}
	}

	if len(missing) > 0 {
		return DoctorCheck{
			Name:    "Gitignore",
			Status:  "warning",
			Message: "Outdated .beads/.gitignore (missing merge artifact patterns)",
			Detail:  "Missing: " + strings.Join(missing, ", "),
			Fix:     "Run: bd doctor --fix or bd init (safe to re-run)",
		}
	}

	// Check for sync-branch mode mismatch (GH#797) and fork protection (GH#796)
	// Note: We no longer use negation patterns (!issues.jsonl) as they override
	// fork protection in .git/info/exclude. See GH#796 for details.
	// Check for actual negation pattern (at start of line), not mentions in comments
	hasNegation := strings.Contains(contentStr, "\n!issues.jsonl")
	hasIgnore := strings.Contains(contentStr, "\nissues.jsonl\n") ||
		strings.Contains(contentStr, "\nissues.jsonl")

	// Warn if negation patterns exist - they break fork protection (GH#796)
	if hasNegation {
		return DoctorCheck{
			Name:    "Gitignore",
			Status:  "warning",
			Message: "Gitignore has negation patterns that break fork protection",
			Detail:  "Found !issues.jsonl which overrides .git/info/exclude (see GH#796)",
			Fix:     "Run: bd doctor --fix (will remove negation patterns)",
		}
	}

	// Sync-branch mode needs ignore patterns (uses git add -f to force-add)
	if syncBranchConfigured && !hasIgnore {
		return DoctorCheck{
			Name:    "Gitignore",
			Status:  "warning",
			Message: "Gitignore mode mismatch: sync-branch configured but JSONL not ignored",
			Detail:  "Expected: issues.jsonl ignored (sync-branch uses git add -f)",
			Fix:     "Run: bd doctor --fix (will regenerate for sync-branch mode)",
		}
	}

	// Direct mode should NOT have ignore patterns (files tracked by default)
	if !syncBranchConfigured && hasIgnore {
		return DoctorCheck{
			Name:    "Gitignore",
			Status:  "warning",
			Message: "Gitignore mode mismatch: no sync-branch but JSONL ignored",
			Detail:  "Expected: no JSONL patterns (files tracked by default in direct mode)",
			Fix:     "Run: bd doctor --fix (will regenerate for direct mode)",
		}
	}

	// Check assume-unchanged flag for sync-branch mode (GH#797)
	// When sync-branch is configured, JSONL files should have assume-unchanged set
	// to prevent them from showing as modified on the main branch.
	if syncBranchConfigured {
		if !hasAssumeUnchanged(".beads/issues.jsonl") {
			return DoctorCheck{
				Name:    "Gitignore",
				Status:  "warning",
				Message: "JSONL showing as modified (assume-unchanged not set)",
				Detail:  "issues.jsonl is tracked but needs assume-unchanged flag for sync-branch mode",
				Fix:     "Run: bd doctor --fix (will set assume-unchanged flag)",
			}
		}
	}

	return DoctorCheck{
		Name:    "Gitignore",
		Status:  "ok",
		Message: "Up to date",
	}
}

// hasAssumeUnchanged checks if a file has the assume-unchanged flag set.
func hasAssumeUnchanged(file string) bool {
	cmd := exec.Command("git", "ls-files", "-v", file)
	output, err := cmd.Output()
	if err != nil {
		return false
	}
	// 'h' = assume-unchanged, 'H' = tracked normally
	return len(output) > 0 && output[0] == 'h'
}

// FixGitignore updates .beads/.gitignore to the current template.
// Deprecated: Use FixGitignoreWithConfig instead. Kept for backward compatibility.
func FixGitignore() error {
	return FixGitignoreWithConfig(false)
}

// FixGitignoreWithConfig updates .beads/.gitignore based on sync-branch configuration.
// When syncBranchConfigured is true, generates gitignore for sync-branch mode (JSONL ignored).
// When false, generates gitignore for direct mode (JSONL tracked).
func FixGitignoreWithConfig(syncBranchConfigured bool) error {
	gitignorePath := filepath.Join(".beads", ".gitignore")

	// If file exists and is read-only, fix permissions first
	if info, err := os.Stat(gitignorePath); err == nil {
		if info.Mode().Perm()&0200 == 0 { // No write permission for owner
			if err := os.Chmod(gitignorePath, 0600); err != nil {
				return err
			}
		}
	}

	// Generate template based on config
	template := GenerateGitignoreTemplate(syncBranchConfigured)

	// Write template with secure file permissions
	if err := os.WriteFile(gitignorePath, []byte(template), 0600); err != nil {
		return err
	}

	// Ensure permissions are set correctly (some systems respect umask)
	if err := os.Chmod(gitignorePath, 0600); err != nil {
		return err
	}

	// For sync-branch mode, set assume-unchanged on JSONL files (GH#797)
	// This tells git to ignore local changes to already-tracked files.
	// Prevents issues.jsonl from showing as "modified" on main branch.
	if syncBranchConfigured {
		setAssumeUnchangedForJSONL(true)
	} else {
		// When switching back to direct mode, clear assume-unchanged
		setAssumeUnchangedForJSONL(false)
	}

	return nil
}

// setAssumeUnchangedForJSONL sets or clears the assume-unchanged flag for JSONL files.
// When enabled, git will ignore local modifications to these files.
// This prevents issues.jsonl from showing as "modified" on the main branch
// when sync-branch mode is active (the file is only committed to the sync branch).
//
// Note: We use assume-unchanged instead of skip-worktree because skip-worktree
// can conflict with sparse-checkout configurations in some repositories.
func setAssumeUnchangedForJSONL(enable bool) {
	flag := "--assume-unchanged"
	if !enable {
		flag = "--no-assume-unchanged"
	}

	for _, file := range []string{".beads/issues.jsonl", ".beads/interactions.jsonl"} {
		// Check if file is tracked before attempting to set flag
		checkCmd := exec.Command("git", "ls-files", "--error-unmatch", file)
		if err := checkCmd.Run(); err != nil {
			// File not tracked, skip
			continue
		}

		// Set or clear the assume-unchanged flag
		cmd := exec.Command("git", "update-index", flag, file)
		_ = cmd.Run() // Best effort - may fail if not in git repo
	}
}
