# OCI image build for bd daemon + oj CLI
# Go and Rust build natively in parallel, then a docker: true task
# assembles and pushes a minimal alpine runtime image to GHCR.

on:
  github:
    push:
      if: ${{ event.git.branch == 'main' || starts-with(event.git.tag, 'v') }}
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: ${{ event.git.ref }}
      status-checks:
        name: Image
    pull_request:
      init:
        commit-sha: ${{ event.git.sha }}
        ref-name: pr
      status-checks:
        - tasks: [build-bd, build-oj]
          name: Image
  cli:
    init:
      commit-sha: ${{ event.git.sha }}
      ref-name: cli

# Build environment — ubuntu with RWX base tools (curl, jq, git).
# The final container image is alpine:3.22, built by the push task.
base:
  image: ubuntu:24.04
  config: rwx/base 1.0.0

tasks:
  # ═══════════════════════════════════════════════════════════════════════
  # Build tasks — Go and Rust compile in parallel, output binary artifacts
  # ═══════════════════════════════════════════════════════════════════════

  # ── System deps for CGO (ICU, gcc) ──────────────────────────────────
  - key: build-deps
    run: |
      sudo apt-get update
      sudo apt-get install -y libicu-dev gcc g++

  # ── Clone beads repo ────────────────────────────────────────────────
  - key: code
    call: git/clone 2.0.3
    with:
      repository: https://github.com/groblegark/beads.git
      ref: ${{ init.commit-sha }}

  # ── Go toolchain ────────────────────────────────────────────────────
  - key: go
    call: golang/install 1.2.0
    with:
      go-version: "1.25"

  # ── Go mod download (cached by go.mod/go.sum) ──────────────────────
  - key: go-deps
    use: [code, go, build-deps]
    run: go mod download
    filter:
      - go.mod
      - go.sum

  # ── Build bd binary → artifact ─────────────────────────────────────
  - key: build-bd
    use: go-deps
    run: |
      REF_NAME="${REF_NAME#refs/tags/}"
      REF_NAME="${REF_NAME#refs/heads/}"
      CGO_ENABLED=1 GOOS=linux go build \
        -ldflags="-s -w -X main.Version=${REF_NAME} -X main.Build=${COMMIT_SHA}" \
        -o bd ./cmd/bd
    env:
      COMMIT_SHA: ${{ init.commit-sha }}
      REF_NAME: ${{ init.ref-name }}
    outputs:
      artifacts:
        - key: bd-binary
          path: bd

  # ── Build oj binary → artifact (parallel with Go build) ────────────
  - key: build-oj
    run: |
      curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain 1.93.0
      export PATH="$HOME/.cargo/bin:$PATH"

      git clone --depth 1 --branch main https://github.com/groblegark/oddjobs.git /tmp/oj
      cd /tmp/oj
      rm -f .cargo/config.toml
      cargo build --release -p oj

      # Copy to working dir for artifact (must be relative path)
      cp /tmp/oj/target/release/oj oj
    outputs:
      artifacts:
        - key: oj-binary
          path: oj

  # ═══════════════════════════════════════════════════════════════════════
  # Push — assemble alpine runtime image from artifacts, push to GHCR
  # Skipped on PRs (build-bd and build-oj validate the build).
  # ═══════════════════════════════════════════════════════════════════════

  - key: push
    use: [build-bd, build-oj]
    if: ${{ init.ref-name != 'pr' }}
    docker: true
    run: |
      # Normalize ref: refs/tags/v1.0 → v1.0, refs/heads/main → main
      REF_NAME="${REF_NAME#refs/tags/}"
      REF_NAME="${REF_NAME#refs/heads/}"

      # Build minimal runtime image from artifacts
      mkdir -p /tmp/image-ctx
      cp ${{ tasks.build-bd.artifacts.bd-binary }} /tmp/image-ctx/bd
      cp ${{ tasks.build-oj.artifacts.oj-binary }} /tmp/image-ctx/oj

      # Write Dockerfile for the push image
      printf '%s\n' \
        'FROM alpine:3.22' \
        'RUN apk add --no-cache ca-certificates tzdata icu-libs netcat-openbsd \' \
        '    && addgroup -g 1000 beads \' \
        '    && adduser -u 1000 -G beads -s /bin/sh -D beads' \
        'COPY bd oj /usr/local/bin/' \
        'RUN chmod 755 /usr/local/bin/bd /usr/local/bin/oj \' \
        '    && chown beads:beads /usr/local/bin/bd /usr/local/bin/oj' \
        'USER beads' \
        'WORKDIR /home/beads' \
        'EXPOSE 9876 9877' \
        'HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \' \
        '    CMD nc -z localhost 9877 || exit 1' \
        'ENTRYPOINT ["bd"]' \
        'CMD ["daemon", "start", "--foreground", "--tcp-addr=:9876", "--http-addr=:9877", "--log-json"]' \
        > /tmp/image-ctx/Dockerfile

      SHORT_SHA="${COMMIT_SHA:0:7}"
      docker build \
        -t ghcr.io/groblegark/beads:sha-${SHORT_SHA} \
        -t ghcr.io/groblegark/beads:latest \
        /tmp/image-ctx

      # Smoke test
      docker run --rm ghcr.io/groblegark/beads:sha-${SHORT_SHA} version

      # Push
      echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GITHUB_USER" --password-stdin
      docker push ghcr.io/groblegark/beads:sha-${SHORT_SHA}
      docker push ghcr.io/groblegark/beads:latest

      # Version tag on release
      if [[ "$REF_NAME" == v* ]]; then
        VERSION="${REF_NAME#v}"
        docker tag ghcr.io/groblegark/beads:sha-${SHORT_SHA} ghcr.io/groblegark/beads:${VERSION}
        docker push ghcr.io/groblegark/beads:${VERSION}
      fi
    env:
      COMMIT_SHA: ${{ init.commit-sha }}
      REF_NAME: ${{ init.ref-name }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      GITHUB_USER: ${{ secrets.GITHUB_USER }}
